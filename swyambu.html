<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Algorithms Portfolio | Your Name</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
<style>
/* === Base Reset === */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: 'Poppins', 'Arial', sans-serif;
  background: linear-gradient(135deg, #0f2027, #203a43, #2c5364);
  color: #f0f0f0;
  line-height: 1.6;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
}

/* === Header === */
header {
  background: rgba(0,0,0,0.7);
  padding: 15px 30px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  backdrop-filter: blur(8px);
  border-bottom: 1px solid rgba(255,255,255,0.1);
}

.nav-left {
  display: flex;
  align-items: center;
  gap: 15px;
}

.logo-circle {
  width: 45px;
  height: 45px;
  background: linear-gradient(135deg,#ff9800,#ff5722);
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: bold;
  color: #fff;
  font-size: 18px;
}

.nav-title span:first-child {
  display: block;
  font-weight: 600;
  font-size: 18px;
}

.nav-title span:last-child {
  display: block;
  font-size: 14px;
  color: #ccc;
}

.nav-links .nav-pill {
  background: linear-gradient(90deg,#ff9800,#ff5722);
  border: none;
  padding: 8px 15px;
  border-radius: 25px;
  font-weight: 500;
  color: #fff;
  cursor: pointer;
  transition: 0.3s;
  display: flex;
  align-items: center;
  gap: 5px;
}

.nav-links .nav-pill:hover {
  transform: scale(1.05);
  box-shadow: 0 4px 10px rgba(255,152,0,0.4);
}

/* === Main Layout === */
main {
  display: flex;
  flex: 1;
  padding: 20px;
  gap: 20px;
}

.sidebar {
  width: 250px;
  background: rgba(0,0,0,0.5);
  padding: 20px;
  border-radius: 15px;
  backdrop-filter: blur(8px);
  display: flex;
  flex-direction: column;
  gap: 15px;
}

.sidebar-header {
  font-weight: bold;
  margin-bottom: 10px;
  color: #ffeb3b;
}

.problem-list {
  list-style: none;
  overflow-y: auto;
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.problem-item {
  display: flex;
  justify-content: space-between;
  padding: 8px 12px;
  border-radius: 10px;
  background: rgba(255,255,255,0.05);
  cursor: pointer;
  transition: 0.3s;
}

.problem-item:hover,
.problem-item.active {
  background: rgba(255,152,0,0.3);
}

.problem-name {
  font-size: 14px;
  font-weight: 500;
}

.problem-tag {
  font-size: 12px;
  font-style: italic;
  color: #ccc;
}

.sidebar-footer {
  font-size: 11px;
  color: #aaa;
}

/* === Problem View === */
.problem-view {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 25px;
}

.crumbs {
  font-size: 12px;
  color: #ccc;
}

.problem-header-main {
  background: rgba(0,0,0,0.5);
  padding: 20px;
  border-radius: 15px;
  backdrop-filter: blur(8px);
  display: flex;
  flex-direction: column;
  gap: 15px;
}

.problem-title-block h1 {
  font-size: 22px;
  margin-bottom: 10px;
  color: #fff;
}

.problem-meta-row {
  display: flex;
  gap: 15px;
  flex-wrap: wrap;
  font-size: 13px;
}

.algo-chip {
  background: #ff9800;
  padding: 3px 10px;
  border-radius: 20px;
  font-size: 12px;
  color: #fff;
}

.sdg-chips {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

.sdg-chip {
  background: #4caf50;
  padding: 3px 10px;
  border-radius: 20px;
  font-size: 12px;
  color: #fff;
}

/* === Cards === */
.card {
  background: rgba(0,0,0,0.5);
  border-radius: 15px;
  padding: 15px 20px;
  backdrop-filter: blur(8px);
  box-shadow: 0 6px 15px rgba(0,0,0,0.3);
}

.card-header {
  display: flex;
  justify-content: space-between;
  font-weight: 600;
  margin-bottom: 10px;
  font-size: 14px;
  color: #ffeb3b;
}

.card-body {
  font-size: 14px;
  line-height: 1.5;
  color: #eee;
}

.code-card pre {
  background: rgba(0,0,0,0.3);
  padding: 12px;
  border-radius: 10px;
  overflow-x: auto;
  color: #fff;
}

/* === Footer === */
footer {
  background: rgba(0,0,0,0.7);
  text-align: center;
  padding: 15px;
  font-size: 13px;
  color: #ccc;
  display: flex;
  justify-content: space-between;
  gap: 20px;
  flex-wrap: wrap;
}

.highlight {
  color: #ff9800;
  font-weight: 600;
}

/* === Scrollbar Styling === */
.sidebar::-webkit-scrollbar {
  width: 6px;
}

.sidebar::-webkit-scrollbar-thumb {
  background: #ff9800;
  border-radius: 3px;
}

.sidebar::-webkit-scrollbar-track {
  background: rgba(255,255,255,0.05);
}

/* === Responsive === */
@media (max-width: 900px) {
  main {
    flex-direction: column;
  }
  .sidebar {
    width: 100%;
  }
}
</style>




</head>
<body>
<div class="app">
  <header>
    <div class="nav">
      <div class="nav-left">
        <div class="logo-circle">
          <div class="logo-inner">YN</div>
        </div>
        <div class="nav-title">
          <span>Algorithm Notebook</span>
          <span>Your Name</span>
        </div>
      </div>
      <div class="nav-links">
        <a href="https://ketan18-ux.github.io/CityProject.github.io/">
        <button class="nav-pill" id="glowToggle">
          <span class="icon">üè†</span>
          <span>Home</span>
        </button>
        </a>
      </div>
    </div>
  </header>

  <main>
    <!-- SIDEBAR -->
    <aside class="sidebar">
      <div class="sidebar-header">
        <strong>10 Problems</strong><br />
        Click a problem to open its dedicated page.
      </div>
      <ul class="problem-list" id="problemList">
        <!-- Filled by JS -->
      </ul>
      <div class="sidebar-footer">
        Tip: Each problem page shows<br />
        <strong>Problem ¬∑ Solution ¬∑ SDG ¬∑ Photo ¬∑ Code</strong>.
      </div>
    </aside>

    <!-- MAIN PROBLEM VIEW -->
    <section class="problem-view" id="problemView">
      <!-- Filled by JS -->
    </section>
  </main>

  <footer>
    <span>¬© <span class="highlight">Your Name</span> ¬∑ Algorithms Portfolio</span>
    <span>Hosted on <span class="highlight">GitHub Pages</span>.</span>
  </footer>
</div>

<script>
  // ==== DATA: 10 PROBLEMS ====
  const problems = [
   {
      id: 1,
      number: 1,
      title: "Air Quality Prediction Network",
      categoryTag: "",
      shortTag: "Merge Sort",
      time: "O(nlogn)",
      space: "O(n)",
      algorithm: "Merge Sort",
      sdgs: [
        
        "SDG 11 ‚Äì Sustainable Cities and Communities",
        "SDG 3 ‚Äì Good Health and Well-Being"
      ],
      problemText:
        "AQI readings are recorded at different times and need organizing. A simple method is required to sort past AQI data and predict the next value.",
      solutionText: "Historical data is sorted using Merge Sort. The average change between readings is computed and added to the latest value to estimate the next AQ.",
      code: `Merge Sort + AQI Trend Prediction

    #include <iostream>
#include <vector>
using namespace std;

// Structure to store AQI reading with timestamp
struct Reading {
    int time;
    int aqi;
};

// Merge function for merge sort
void merge(vector<Reading>& arr, int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;

    vector<Reading> L(n1), R(n2);

    for (int i = 0; i < n1; i++)
        L[i] = arr[left + i];
    for (int j = 0; j < n2; j++)
        R[j] = arr[mid + 1 + j];

    int i = 0, j = 0, k = left;

    while (i < n1 && j < n2) {
        if (L[i].time <= R[j].time)
            arr[k++] = L[i++];
        else
            arr[k++] = R[j++];
    }

    while (i < n1) arr[k++] = L[i++];
    while (j < n2) arr[k++] = R[j++];
}

// Merge Sort for AQI readings
void mergeSort(vector<Reading>& arr, int left, int right) {
    if (left < right) {
        int mid = left + (right - left) / 2;
        mergeSort(arr, left, mid);
        mergeSort(arr, mid + 1, right);
        merge(arr, left, mid, right);
    }
}

// Function to predict next AQI value
int predictAQI(const vector<Reading>& sorted) {
    if (sorted.size() < 2) return sorted.back().aqi;

    int totalSlope = 0;
    for (size_t i = 1; i < sorted.size(); i++) {
        totalSlope += (sorted[i].aqi - sorted[i - 1].aqi);
    }

    int avgSlope = totalSlope / (sorted.size() - 1);
    return sorted.back().aqi + avgSlope;
}

int main() {
    vector<Reading> data = {
        {5, 120}, {1, 80}, {4, 110}, {2, 90}, {3, 100}
    };

    // Sort data by timestamp
    mergeSort(data, 0, data.size() - 1);

    cout << "Sorted AQI data (time, AQI):\n";
    for (auto& r : data) {
        cout << r.time << " -> " << r.aqi << endl;
    }

    int predicted = predictAQI(data);
    cout << "\nPredicted next AQI: " << predicted << endl;

    return 0;
}

`,
 
    },
    {
      id: 2,
      number: 2,
      title: "Smart Waste Segregation Automation",
      categoryTag: "",
      shortTag: "AVL Tree",
      time: "O(log n)",
      space: "O(n)",
      algorithm: "AVL Tree",
      sdgs: [
        "SDG 11 ‚Äì sustainable cities and communities",
        "SDG 12 ‚Äì Responsible Consumption and Production",
        "SDG 13 ‚Äì Climate Action"
      ],
      problemText:
        "Waste items need quick classification into categories like biodegradable, recyclable, or hazardous. A structured rule-based method is required to organize and retrieve classification rules efficiently.",
      solutionText:
        "An AVL Tree stores waste-classification rules as nodes Each item checks attributes and follows the tree path to reach its correct category AVL balancing ensures fast and consistent classification.",
      
       
        code:`AVL  Tree
       #include <iostream>
#include <string>
using namespace std;

struct Node {
    string rule;
    string category;
    Node* left;
    Node* right;
    int height;

    Node(string r, string c) : rule(r), category(c), left(NULL), right(NULL), height(1) {}
};

int getHeight(Node* n) {
    return n ? n->height : 0;
}

int getBalance(Node* n) {
    return n ? getHeight(n->left) - getHeight(n->right) : 0;
}

Node* rightRotate(Node* y) {
    Node* x = y->left;
    Node* T2 = x->right;

    x->right = y;
    y->left = T2;

    y->height = max(getHeight(y->left), getHeight(y->right)) + 1;
    x->height = max(getHeight(x->left), getHeight(x->right)) + 1;

    return x;
}

Node* leftRotate(Node* x) {
    Node* y = x->right;
    Node* T2 = y->left;

    y->left = x;
    x->right = T2;

    x->height = max(getHeight(x->left), getHeight(x->right)) + 1;
    y->height = max(getHeight(y->left), getHeight(y->right)) + 1;

    return y;
}

Node* insert(Node* node, string rule, string category) {
    if (!node) return new Node(rule, category);

    if (rule < node->rule)
        node->left = insert(node->left, rule, category);
    else
        node->right = insert(node->right, rule, category);

    node->height = 1 + max(getHeight(node->left), getHeight(node->right));
    int balance = getBalance(node);

    if (balance > 1 && rule < node->left->rule)
        return rightRotate(node);

    if (balance < -1 && rule > node->right->rule)
        return leftRotate(node);

    if (balance > 1 && rule > node->left->rule) {
        node->left = leftRotate(node->left);
        return rightRotate(node);
    }

    if (balance < -1 && rule < node->right->rule) {
        node->right = rightRotate(node->right);
        return leftRotate(node);
    }

    return node;
}

string classify(Node* root, string rule) {
    Node* curr = root;
    while (curr) {
        if (rule == curr->rule) return curr->category;
        else if (rule < curr->rule) curr = curr->left;
        else curr = curr->right;
    }
    return "Unknown Category";
}

int main() {
    Node* root = NULL;

    root = insert(root, "plastic", "Recyclable");
    root = insert(root, "banana_peel", "Biodegradable");
    root = insert(root, "battery", "Hazardous");

    cout << "Classification: " << classify(root, "battery") << endl;

    return 0;
}


`,
 
    },
    {
      id: "3",
      number: 3,
      title: "Noise Barrier Placement Optimisation",
      categoryTag: "",
      shortTag: "Kruskal‚Äôs",
      time: "O(ElogE)",
      space: "O(V)",
      algorithm: "Kruskal‚Äôs Algorithm",
      sdgs: [
        "SDG 3 ‚Äì Good Health and Well-Being",
        "SDG 9 ‚Äì Industry, Innovation & Infrastructure Builds smart pipeline and distribution systems",
        "SDG 11 ‚Äì Sustainable Cities & Communities Supports sustainable water management"
      ],
      problemText:
        "Cities need to place noise barriers around loud zones like highways and construction sites. To minimize construction cost, an efficient method is needed to determine the smallest total barrier length that still encloses all noisy points.",
      solutionText:
        "Each noise source is treated as a node, and distances are edges. Kruskal‚Äôs MST algorithm selects the minimum set of edges connecting all noise points, giving the minimum total barrier layout needed to cover the area.",
      
       code:`Kruskal
   #include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>
using namespace std;

struct Edge {
    int u, v;
    double w;
};

struct DSU {
    vector<int> parent, rank;

    DSU(int n) {
        parent.resize(n);
        rank.resize(n, 0);
        for (int i = 0; i < n; i++) parent[i] = i;
    }

    int find(int x) {
        if (parent[x] != x)
            parent[x] = find(parent[x]);
        return parent[x];
    }

    void unite(int a, int b) {
        a = find(a);
        b = find(b);
        if (a != b) {
            if (rank[a] < rank[b]) swap(a, b);
            parent[b] = a;
            if (rank[a] == rank[b]) rank[a]++;
        }
    }
};

double dist(pair<int,int> a, pair<int,int> b) {
    return sqrt((a.first - b.first)*(a.first - b.first) +
                (a.second - b.second)*(a.second - b.second));
}

int main() {
    vector<pair<int,int>> points = {{0,0}, {3,4}, {4,1}, {7,5}};
    int n = points.size();

    vector<Edge> edges;
    for (int i = 0; i < n; i++) {
        for (int j = i+1; j < n; j++) {
            edges.push_back({i, j, dist(points[i], points[j])});
        }
    }

    sort(edges.begin(), edges.end(), [](Edge a, Edge b){
        return a.w < b.w;
    });

    DSU dsu(n);
    double totalWeight = 0;

    for (auto &e : edges) {
        if (dsu.find(e.u) != dsu.find(e.v)) {
            dsu.unite(e.u, e.v);
            totalWeight += e.w;
        }
    }

    cout << "Minimum barrier length (MST total): " << totalWeight << endl;
    return 0;
}

`,
 
    },
    {
      id: "4",
      number: 4,
      title: "Flood-Susceptible Zone Detection",
      categoryTag: "",
      shortTag: "Dijkstra‚Äôs",
      time: "O(ElogV)",
      space: "O(V)",
      algorithm: "Dijkstra‚Äôs Algorithm",
      sdgs: [
        "SDG 11 ‚Äì Sustainable Cities and Communities",
        "SDG 3 ‚Äì Good health and Wealth Being",
        "SDG 13 - Climate Action Reduces dependence on fossil fuels"
      ],
      problemText:
        "Flooding often affects low-elevation or high-risk areas, and cities need a simple method to detect which locations are most likely to flood. A weighted model is required to compute the safest paths and identify zones with high flood vulnerability.",
      solutionText:
        "Each land cell is treated as a graph node with risk as the weight. Dijkstra‚Äôs algorithm computes minimal-risk paths from a safe point, and cells with high accumulated cost are marked as flood-susceptible.",
     code:`Dijkstra
     #include <iostream>
#include <vector>
#include <queue>
using namespace std;

const int INF = 1e9;

struct Node {
    int v, w;
    bool operator>(const Node& other) const {
        return w > other.w;
    }
};

int main() {
    int n = 5; // number of areas
    vector<vector<Node>> graph(n);

    // Example risk edges (u -> v with risk weight)
    graph[0].push_back({1, 4});
    graph[0].push_back({2, 2});
    graph[1].push_back({3, 5});
    graph[2].push_back({3, 1});
    graph[3].push_back({4, 3});

    vector<int> dist(n, INF);
    priority_queue<Node, vector<Node>, greater<Node>> pq;

    int source = 0;
    dist[source] = 0;
    pq.push({source, 0});

    while (!pq.empty()) {
        Node curr = pq.top();
        pq.pop();

        if (curr.w != dist[curr.v]) continue;

        for (auto& nxt : graph[curr.v]) {
            if (dist[nxt.v] > dist[curr.v] + nxt.w) {
                dist[nxt.v] = dist[curr.v] + nxt.w;
                pq.push({nxt.v, dist[nxt.v]});
            }
        }
    }

    cout << "Flood risk levels (lower = safer):\n";
    for (int i = 0; i < n; i++) {
        cout << "Area " << i << " risk: " << dist[i] << endl;
    }

    return 0;
}


`,
 
    },
    {
      id: 5,
      number: 5,
      title: "Renewable Energy Distribution Optimization",
      categoryTag: "",
      shortTag: "Floyd‚ÄìWarshall",
      time: "O(n^3)",
      space: "O(n^2)",
      algorithm: "Floyd‚ÄìWarshall Algorithm",
      sdgs: [
        "SDG 7 ‚Äì Affordable and Clean Energy",
        "SDG 9 ‚Äì Industry, Innovation and Infrastructure",
        "SDG 13 ‚Äì Climate Action"
      ],
      problemText:
        "Energy stations are connected through various transmission lines, each with a cost or distance. To distribute renewable energy efficiently, cities need a method that finds the shortest energy-transfer paths between every pair of stations.",
      solutionText:
        "The Floyd‚ÄìWarshall algorithm computes shortest paths between all stations. This identifies the optimal routes for transferring renewable energy with minimal loss or cost.",
     code:
       `Floyd‚ÄìWarshall
       #include <iostream>
#include <vector>
using namespace std;

const int INF = 1e9;

int main() {
    int n = 4; // number of power stations
    vector<vector<int>> dist = {
        {0,   5, INF, 10},
        {INF, 0,   3, INF},
        {INF, INF, 0,   1},
        {INF, INF, INF, 0}
    };

    for (int k = 0; k < n; k++) {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (dist[i][k] + dist[k][j] < dist[i][j])
                    dist[i][j] = dist[i][k] + dist[k][j];
            }
        }
    }

    cout << "Shortest energy transfer paths:\n";
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (dist[i][j] == INF) cout << "INF ";
            else cout << dist[i][j] << " ";
        }
        cout << "\n";
    }

    return 0;
}


`,
 
    },
    {
      id: 6,
      number: 6,
      title: "Health Risk Heatmap Generation",
      categoryTag: "",
      shortTag: "Floyd‚ÄìWarshall",
      time: "O(n^3)",
      space: "O(n^2)",
      algorithm: "Floyd‚ÄìWarshall Algorithm",
      sdgs: [
        "SDG 3 ‚Äì Good Health and Well-Being",
        "SDG 13 ‚Äì Climate Action",
        "SDG 11 ‚Äì Sustainable Cities & Communities Efficient use of shared space and resources"
      ],
      problemText:
        "Health departments collect case data from many locations, but need a method to detect which areas have strong clustering of cases. A proximity-based system is required to identify hotspots.",
      solutionText:
        "The Floyd‚ÄìWarshall algorithm computes shortest distances between all case points. Areas with small pairwise distances and high density are marked as hotspots on the heatmap.",
     code:
       `Floyd‚ÄìWarshall
#include <iostream>
#include <vector>
using namespace std;

const int INF = 1e9;

int main() {
    int n = 4; // number of health case locations
    vector<vector<int>> dist = {
        {0,   2, INF,  3},
        {2,   0,   4, INF},
        {INF, 4,   0,   1},
        {3, INF,  1,   0}
    };

    for (int k = 0; k < n; k++) {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (dist[i][k] + dist[k][j] < dist[i][j])
                    dist[i][j] = dist[i][k] + dist[k][j];
            }
        }
    }

    cout << "Proximity matrix (lower = closer/higher risk):\n";
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (dist[i][j] == INF) cout << "INF ";
            else cout << dist[i][j] << " ";
        }
        cout << "\n";
    }

    return 0;
}

`,
 
    },
    {
      id: 7,
      number: 7,
      title: "Smart Irrigation Scheduling",
      categoryTag: "",
      shortTag: "AVL Tree",
      time: "O(log n)",
      space: "O(n)",
      algorithm: "AVL Tree",
      sdgs: [
        "SDG 2 ‚Äì Zero Hunger",
        "SDG 12 ‚Äì Responsible Consumption and Production",
        "SDG 6 ‚Äì Clean Water and Sanitation"
      ],
      problemText:
        "Farms need to schedule irrigation at the right times based on moisture and temperature data. An efficient way is needed to store and quickly retrieve the next available watering slot.",
      solutionText:
        "An AVL Tree stores irrigation time slots in sorted order. Its balanced structure enables fast insertion and retrieval, ensuring timely and efficient irrigation scheduling.",
      
      code:`AVL Tree
     #include <iostream>
using namespace std;

struct Node {
    int time;
    Node* left;
    Node* right;
    int height;
    Node(int t) : time(t), left(NULL), right(NULL), height(1) {}
};

int getHeight(Node* n) {
    return n ? n->height : 0;
}

int getBalance(Node* n) {
    return n ? getHeight(n->left) - getHeight(n->right) : 0;
}

Node* rightRotate(Node* y) {
    Node* x = y->left;
    Node* T2 = x->right;

    x->right = y;
    y->left = T2;

    y->height = max(getHeight(y->left), getHeight(y->right)) + 1;
    x->height = max(getHeight(x->left), getHeight(x->right)) + 1;

    return x;
}

Node* leftRotate(Node* x) {
    Node* y = x->right;
    Node* T2 = y->left;

    y->left = x;
    x->right = T2;

    x->height = max(getHeight(x->left), getHeight(x->right)) + 1;
    y->height = max(getHeight(y->left), getHeight(y->right)) + 1;

    return y;
}

Node* insert(Node* node, int time) {
    if (!node) return new Node(time);

    if (time < node->time)
        node->left = insert(node->left, time);
    else
        node->right = insert(node->right, time);

    node->height = 1 + max(getHeight(node->left), getHeight(node->right));

    int balance = getBalance(node);

    if (balance > 1 && time < node->left->time)
        return rightRotate(node);
    if (balance < -1 && time > node->right->time)
        return leftRotate(node);
    if (balance > 1 && time > node->left->time) {
        node->left = leftRotate(node->left);
        return rightRotate(node);
    }
    if (balance < -1 && time < node->right->time) {
        node->right = rightRotate(node->right);
        return leftRotate(node);
    }

    return node;
}

Node* findNextSlot(Node* root, int target) {
    Node* curr = root;
    Node* candidate = NULL;

    while (curr) {
        if (curr->time >= target) {
            candidate = curr;
            curr = curr->left;
        } else {
            curr = curr->right;
        }
    }
    return candidate;
}

int main() {
    Node* root = NULL;

    root = insert(root, 8);
    root = insert(root, 12);
    root = insert(root, 5);
    root = insert(root, 15);

    int currentTime = 9;
    Node* nextSlot = findNextSlot(root, currentTime);

    if (nextSlot)
        cout << "Next irrigation time: " << nextSlot->time << endl;
    else
        cout << "No upcoming slot.\n";

    return 0;
}
                           

`,
 
    },
    {
      id: "8",
      number: 8,
      title: "CO‚ÇÇ Offset Plantation Optimization",
      categoryTag: "",
      shortTag: "Knapsack + sorting",
      time: "O(n√óW)",
      space: "O(n√óW)",
      algorithm: "Knapsack Algorithm + sorting",
      sdgs: [
        "SDG 13‚Äì Climate Action",
        "SDG 11 ‚Äì Sustainable Cities & Communities Improves safety and disaster management",
        "SDG 15 ‚Äì Life on Land"
      ],
      problemText:
        "Given several zones with different tree capacities and CO‚ÇÇ absorption values, select the best combination that maximizes carbon offset within a limited land area.",
      solutionText:
        "Using the Knapsack algorithm, we choose plantation zones that give the highest CO‚ÇÇ reduction while staying within the land limit, ensuring maximum environmental benefit.",
     
      code:`0/1 Knapsack
   #include <iostream>
#include <vector>
using namespace std;

int main() {
    vector<int> land = {3, 2, 4, 5};      // land required by each zone
    vector<int> co2  = {6, 4, 5, 8};      // CO2 offset of each zone
    int W = 7;                            // total land available
    int n = land.size();

    vector<vector<int>> dp(n+1, vector<int>(W+1, 0));

    for (int i = 1; i <= n; i++) {
        for (int w = 1; w <= W; w++) {
            if (land[i-1] <= w)
                dp[i][w] = max(dp[i-1][w],
                               co2[i-1] + dp[i-1][w - land[i-1]]);
            else
                dp[i][w] = dp[i-1][w];
        }
    }

    cout << "Max CO2 offset = " << dp[n][W] << endl;
    return 0;
}

`,
 
    },
    {
      id: 9,
      number: 9,
      title: "Crime Hotspot Detection",
      categoryTag: "",
      shortTag: "BFS+Priority Queue (Max-Heap)",
      time: "O(V+E)+O(n logn)",
      space: "O(V+E)",
      algorithm: "BFS+Priority Queue (Max-Heap)",
      sdgs: [
        "SDG 9 ‚Äì Industry, Innovation and Infrastructure",
        "SDG 16 ‚Äì Peace, Justice and Strong Institutions",
        "SDG 11 ‚Äì Sustainable Cities and Communities"
      ],
      problemText:
        "The city is divided into zones, and each zone has crime reports. Identify which zones form crime hotspots.",
      solutionText:
        "Use BFS to scan each zone and count crime occurrences; then use a priority queue to rank zones from highest to lowest crime density and pick the top hotspots.", 
      code:`BFS+Priority Queue (Max-Heap)
    #include <iostream>
#include <vector>
#include <queue>
using namespace std;

int main() {
    // adjacency list of zones
    vector<vector<int>> graph = {
        {1,2},     // zone 0
        {0,3},     // zone 1
        {0},       // zone 2
        {1,4},     // zone 3
        {3}        // zone 4
    };

    // crime count in each zone
    vector<int> crime = {4, 10, 2, 7, 3};

    int n = graph.size();
    vector<bool> visited(n, false);

    // max-heap for ranking hotspots
    priority_queue<pair<int,int>> pq;

    // BFS over each component, accumulate crime counts
    for (int i = 0; i < n; i++) {
        if (!visited[i]) {
            int totalCrime = 0;
            queue<int> q;
            q.push(i);
            visited[i] = true;

            while (!q.empty()) {
                int u = q.front(); q.pop();
                totalCrime += crime[u];

                for (int v : graph[u]) {
                    if (!visited[v]) {
                        visited[v] = true;
                        q.push(v);
                    }
                }
            }

            pq.push({totalCrime, i});  // store crime value with zone id
        }
    }

    cout << "Top crime hotspots:\n";
    while (!pq.empty()) {
        cout << "Zone " << pq.top().second
             << " Crime Score: " << pq.top().first << "\n";
        pq.pop();
    }

    return 0;
}


`,
 
    },
    {
      id: 10,
      number: 10,
      title: ": Streetlight Fault Detection",
      categoryTag: "",
      shortTag: "Dijkstra‚Äôs+AVL",
      time: "O(E log V)+O(log n) ",
      space: "O(V+m)",
      algorithm: "Dijkstra‚Äôs+AVL",
      sdgs: [
        "SDG 7 ‚Äì Affordable and Clean Energy",
        "SDG 9 ‚Äì Industry, Innovation and Infrastructure",
        "SDG 11 ‚Äì Sustainable Cities & Communities Encourages community engagement through s"
      ],
      problemText:
        "Detect faulty streetlights using their sensor telemetry and the road network: find lights with unusual sensor values and identify which networked nodes are affected.",
      solutionText:
        "Run Dijkstra to map the streetlight network and gather telemetry per node; store recent readings in an AVL Tree. For each light, compare current reading to its historical average (computed from the AVL data) ‚Äî if deviation exceeds a threshold, flag an anomaly.",
        code:` Dijkstra‚Äôs+AVL
      #include <bits/stdc++.h>
using namespace std;

/* ---------- AVL Tree (stores historical readings for one streetlight) ---------- */
struct AVLNode {
    int timestamp;
    double reading;
    AVLNode *l, *r;
    int h;
    AVLNode(int t, double r): timestamp(t), reading(r), l(NULL), r(NULL), h(1) {}
};

int heightA(AVLNode* n){ return n ? n->h : 0; }
AVLNode* rightRotateA(AVLNode* y){
    AVLNode* x = y->l; AVLNode* T2 = x->r;
    x->r = y; y->l = T2;
    y->h = max(heightA(y->l), heightA(y->r)) + 1;
    x->h = max(heightA(x->l), heightA(x->r)) + 1;
    return x;
}
AVLNode* leftRotateA(AVLNode* x){
    AVLNode* y = x->r; AVLNode* T2 = y->l;
    y->l = x; x->r = T2;
    x->h = max(heightA(x->l), heightA(x->r)) + 1;
    y->h = max(heightA(y->l), heightA(y->r)) + 1;
    return y;
}
int getBalanceA(AVLNode* n){ return n ? heightA(n->l) - heightA(n->r) : 0; }
AVLNode* insertA(AVLNode* node, int t, double val){
    if (!node) return new AVLNode(t,val);
    if (t < node->timestamp) node->l = insertA(node->l, t, val);
    else node->r = insertA(node->r, t, val);
    node->h = 1 + max(heightA(node->l), heightA(node->r));
    int bal = getBalanceA(node);
    if (bal > 1 && t < node->l->timestamp) return rightRotateA(node);
    if (bal < -1 && t > node->r->timestamp) return leftRotateA(node);
    if (bal > 1 && t > node->l->timestamp){ node->l = leftRotateA(node->l); return rightRotateA(node); }
    if (bal < -1 && t < node->r->timestamp){ node->r = rightRotateA(node->r); return leftRotateA(node); }
    return node;
}
// inorder traversal to compute average and count (used for anomaly thresholding)
void inorderSum(AVLNode* root, double &sum, int &cnt){
    if (!root) return;
    inorderSum(root->l, sum, cnt);
    sum += root->reading; cnt++;
    inorderSum(root->r, sum, cnt);
}

/* ---------- Dijkstra for network traversal ---------- */
struct Edge { int to; double w; };
using PDI = pair<double,int>;
vector<double> dijkstra(int n, int src, const vector<vector<Edge>>& g){
    const double INF = 1e18;
    vector<double> dist(n, INF);
    priority_queue<PDI, vector<PDI>, greater<PDI>> pq;
    dist[src] = 0; pq.push({0, src});
    while(!pq.empty()){
        auto [d,u] = pq.top(); pq.pop();
        if (d > dist[u]) continue;
        for (auto &e : g[u]){
            if (dist[e.to] > dist[u] + e.w){
                dist[e.to] = dist[u] + e.w;
                pq.push({dist[e.to], e.to});
            }
        }
    }
    return dist;
}

/* ---------- Example usage ---------- */
int main(){
    // example small network of 5 streetlights (nodes 0..4)
    int V = 5;
    vector<vector<Edge>> graph(V);
    // undirected weighted edges (distance/time)
    graph[0].push_back({1,1}); graph[1].push_back({0,1});
    graph[1].push_back({2,1}); graph[2].push_back({1,1});
    graph[1].push_back({3,2}); graph[3].push_back({1,2});
    graph[3].push_back({4,1}); graph[4].push_back({3,1});

    // Run Dijkstra from central controller (node 0) to map expected hops/latency
    vector<double> dist = dijkstra(V, 0, graph);

    cout << "Dijkstra distances from controller (node 0):\n";
    for (int i=0;i<V;i++) cout << "Node " << i << " dist=" << dist[i] << "\n";

    // For each streetlight, maintain an AVL tree of recent sensor readings
    vector<AVLNode*> history(V, nullptr);

    // Simulate inserting historical readings (timestamp, reading value)
    // reading = e.g., power draw / brightness / voltage; we flag if current deviates > 30%
    vector<vector<pair<int,double>>> sampleData = {
        {{1,10},{2,10.5},{3,9.8}},    // node0
        {{1,12},{2,11.8},{3,12.2}},   // node1
        {{1,9},{2,9.1},{3,9.0}},      // node2
        {{1,15},{2,14.5},{3,14.8}},   // node3
        {{1,10},{2,10},{3,10}}        // node4
    };

    for (int i=0;i<V;i++){
        for (auto &p : sampleData[i])
            history[i] = insertA(history[i], p.first, p.second);
    }

    // Current readings that arrive now (timestamp 4)
    vector<double> current = {9.9, 20.0, 9.2, 8.0, 10.5}; // note node1 and node3 anomalous

    cout << "\nAnomaly check (threshold = 30% deviation from historical average):\n";
    double THRESH = 0.30;
    for (int i=0;i<V;i++){
        double sum=0; int cnt=0;
        inorderSum(history[i], sum, cnt);
        double avg = (cnt>0) ? sum/cnt : 0;
        double cur = current[i];
        bool anomaly = (avg>0) ? (fabs(cur - avg) / avg > THRESH) : false;
        cout << "Node " << i << " avg="<<avg<<" cur="<<cur<<" -> " 
             << (anomaly ? "ANOMALY\n" : "OK\n");
    }

    // Optionally: for anomalous nodes, compute shortest path from controller to node (using dist)
    cout << "\nActionable nodes (anomalous) and their distance from controller:\n";
    for (int i=0;i<V;i++){
        double sum=0; int cnt=0; inorderSum(history[i], sum, cnt);
        double avg = (cnt>0) ? sum/cnt : 0;
        if (avg>0 && (fabs(current[i]-avg)/avg > THRESH)) {
            cout << "Node " << i << " dist="<<dist[i]<<"\n";
        }
    }

    return 0;
}

`,
 
    }
  ];

  // ==== RENDER SIDEBAR ====
  const problemListEl = document.getElementById("problemList");
  function renderSidebar(activeId) {
    problemListEl.innerHTML = "";
    problems.forEach(p => {
      const li = document.createElement("li");
      li.className = "problem-item" + (p.id === activeId ? " active" : "");
      li.dataset.id = p.id;

      const left = document.createElement("div");
      left.className = "problem-name";
      left.textContent = `#${p.number} ¬∑ ${p.title}`;

      const right = document.createElement("div");
      right.className = "problem-tag";
      right.textContent = p.shortTag;

      li.appendChild(left);
      li.appendChild(right);
      li.addEventListener("click", () => {
        setActiveProblem(p.id, true);
      });

      problemListEl.appendChild(li);
    });
  }

  // ==== RENDER MAIN PROBLEM PAGE ====
  const viewEl = document.getElementById("problemView");

  function renderProblem(problem) {
    const sdgHtml = problem.sdgs
      .map(s => `<span class="sdg-chip">${s}</span>`)
      .join("");

    viewEl.innerHTML = `
      <div class="crumbs">
        Algorithms / <span>Problem #${problem.number}</span>
      </div>

      <div class="problem-header-main">
        <div class="problem-title-block">
          <div class="problem-id-pill">
            <span>Problem #${problem.number}</span>
          </div>
          <h1>${problem.title}</h1>
          <div class="problem-meta-row">
            <span class="algo-chip">${problem.algorithm}</span>
            
            <span><strong>Time:</strong> ${problem.time}</span>
            <span><strong>Space:</strong> ${problem.space}</span>
          </div>
          <div class="sdg-chips">
            ${sdgHtml}
          </div>
        </div>

        
      </div>

      <div class="content-grid">
        <div class="card">
          <div class="card-header">
            <span>Problem &amp; Solution</span>
            <span class="label">Explanation</span>
          </div>
          <div class="card-body">
            <strong>Problem:</strong><br />
            <span>${problem.problemText}</span>
            <br /><br />
            <strong>High-level Solution:</strong><br />
            <span>${problem.solutionText}</span>
          </div>
        </div>

        

      <div class="card code-card">
        <div class="card-header">
          <span>Reference Code</span>
          <span class="label">c++</span>
        </div>
        <div class="card-body">
          <pre id="codeBlock"><code>${problem.code}</code></pre>
        </div>
      </div>
      

      
    `;

    // Hook up copy & raw buttons
    const copyBtn = document.getElementById("copyCodeBtn");
    const rawBtn = document.getElementById("openRawBtn");
    const codeBlock = document.getElementById("codeBlock");

    if (copyBtn && codeBlock) {
      copyBtn.addEventListener("click", () => {
        const text = codeBlock.innerText;
        navigator.clipboard?.writeText(text).then(
          () => { copyBtn.textContent = "‚úÖ Copied"; },
          () => { copyBtn.textContent = "‚ö†Ô∏è Failed"; }
        );
        setTimeout(() => (copyBtn.innerHTML = '<span>üìã</span> Copy Code'), 1200);
      });
    }

    if (rawBtn && codeBlock) {
      rawBtn.addEventListener("click", () => {
        const w = window.open("", "_blank");
        if (!w) return;
        w.document.write("<pre>" + codeBlock.innerText.replace(/</g, "&lt;") + "</pre>");
        w.document.close();
      });
    }
  }

  // ==== ROUTING (HASH-BASED) ====
  function setActiveProblem(id, updateHash) {
    const problem = problems.find(p => p.id === id) || problems[0];
    renderSidebar(problem.id);
    renderProblem(problem);
    if (updateHash) {
      window.location.hash = "problem/" + problem.id;
    }
  }

  function getProblemIdFromHash() {
    const hash = window.location.hash || "";
    const match = hash.match(/problem\/([a-z0-9\-]+)/i);
    return match ? match[1] : null;
  }

  window.addEventListener("hashchange", () => {
    const id = getProblemIdFromHash();
    if (id) setActiveProblem(id, false);
  });

  // ==== GLOW TOGGLE ====
  const glowToggle = document.getElementById("glowToggle");
  let glowOn = true;
  glowToggle?.addEventListener("click", () => {
    document.body.style.filter = glowOn ? "saturate(0.9) brightness(0.95)" : "none";
    glowOn = !glowOn;
  });

  // ==== INITIALISE ====
  (function init() {
    const initialId = getProblemIdFromHash() || problems[0].id;
    setActiveProblem(initialId, true);
  })();
</script>
</body>
</html>

