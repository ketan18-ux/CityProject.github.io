<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Algorithms Portfolio | Your Name</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
<style>
/* === Base Reset === */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: 'Poppins', 'Arial', sans-serif;
  background: linear-gradient(135deg, #0f2027, #203a43, #2c5364);
  color: #f0f0f0;
  line-height: 1.6;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
}

/* === Header === */
header {
  background: rgba(0,0,0,0.7);
  padding: 15px 30px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  backdrop-filter: blur(8px);
  border-bottom: 1px solid rgba(255,255,255,0.1);
}

.nav-left {
  display: flex;
  align-items: center;
  gap: 15px;
}

.logo-circle {
  width: 45px;
  height: 45px;
  background: linear-gradient(135deg,#ff9800,#ff5722);
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: bold;
  color: #fff;
  font-size: 18px;
}

.nav-title span:first-child {
  display: block;
  font-weight: 600;
  font-size: 18px;
}

.nav-title span:last-child {
  display: block;
  font-size: 14px;
  color: #ccc;
}

.nav-links .nav-pill {
  background: linear-gradient(90deg,#ff9800,#ff5722);
  border: none;
  padding: 8px 15px;
  border-radius: 25px;
  font-weight: 500;
  color: #fff;
  cursor: pointer;
  transition: 0.3s;
  display: flex;
  align-items: center;
  gap: 5px;
}

.nav-links .nav-pill:hover {
  transform: scale(1.05);
  box-shadow: 0 4px 10px rgba(255,152,0,0.4);
}

/* === Main Layout === */
main {
  display: flex;
  flex: 1;
  padding: 20px;
  gap: 20px;
}

.sidebar {
  width: 250px;
  background: rgba(0,0,0,0.5);
  padding: 20px;
  border-radius: 15px;
  backdrop-filter: blur(8px);
  display: flex;
  flex-direction: column;
  gap: 15px;
}

.sidebar-header {
  font-weight: bold;
  margin-bottom: 10px;
  color: #ffeb3b;
}

.problem-list {
  list-style: none;
  overflow-y: auto;
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.problem-item {
  display: flex;
  justify-content: space-between;
  padding: 8px 12px;
  border-radius: 10px;
  background: rgba(255,255,255,0.05);
  cursor: pointer;
  transition: 0.3s;
}

.problem-item:hover,
.problem-item.active {
  background: rgba(255,152,0,0.3);
}

.problem-name {
  font-size: 14px;
  font-weight: 500;
}

.problem-tag {
  font-size: 12px;
  font-style: italic;
  color: #ccc;
}

.sidebar-footer {
  font-size: 11px;
  color: #aaa;
}

/* === Problem View === */
.problem-view {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 25px;
}

.crumbs {
  font-size: 12px;
  color: #ccc;
}

.problem-header-main {
  background: rgba(0,0,0,0.5);
  padding: 20px;
  border-radius: 15px;
  backdrop-filter: blur(8px);
  display: flex;
  flex-direction: column;
  gap: 15px;
}

.problem-title-block h1 {
  font-size: 22px;
  margin-bottom: 10px;
  color: #fff;
}

.problem-meta-row {
  display: flex;
  gap: 15px;
  flex-wrap: wrap;
  font-size: 13px;
}

.algo-chip {
  background: #ff9800;
  padding: 3px 10px;
  border-radius: 20px;
  font-size: 12px;
  color: #fff;
}

.sdg-chips {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

.sdg-chip {
  background: #4caf50;
  padding: 3px 10px;
  border-radius: 20px;
  font-size: 12px;
  color: #fff;
}

/* === Cards === */
.card {
  background: rgba(0,0,0,0.5);
  border-radius: 15px;
  padding: 15px 20px;
  backdrop-filter: blur(8px);
  box-shadow: 0 6px 15px rgba(0,0,0,0.3);
}

.card-header {
  display: flex;
  justify-content: space-between;
  font-weight: 600;
  margin-bottom: 10px;
  font-size: 14px;
  color: #ffeb3b;
}

.card-body {
  font-size: 14px;
  line-height: 1.5;
  color: #eee;
}

.code-card pre {
  background: rgba(0,0,0,0.3);
  padding: 12px;
  border-radius: 10px;
  overflow-x: auto;
  color: #fff;
}

/* === Footer === */
footer {
  background: rgba(0,0,0,0.7);
  text-align: center;
  padding: 15px;
  font-size: 13px;
  color: #ccc;
  display: flex;
  justify-content: space-between;
  gap: 20px;
  flex-wrap: wrap;
}

.highlight {
  color: #ff9800;
  font-weight: 600;
}

/* === Scrollbar Styling === */
.sidebar::-webkit-scrollbar {
  width: 6px;
}

.sidebar::-webkit-scrollbar-thumb {
  background: #ff9800;
  border-radius: 3px;
}

.sidebar::-webkit-scrollbar-track {
  background: rgba(255,255,255,0.05);
}

/* === Responsive === */
@media (max-width: 900px) {
  main {
    flex-direction: column;
  }
  .sidebar {
    width: 100%;
  }
}
</style>




</head>
<body>
<div class="app">
  <header>
    <div class="nav">
      <div class="nav-left">
        <div class="logo-circle">
          <div class="logo-inner">YN</div>
        </div>
        <div class="nav-title">
          <span>Algorithm Notebook</span>
          <span>Your Name</span>
        </div>
      </div>
      <div class="nav-links">
        <a href="https://ketan18-ux.github.io/CityProject.github.io/">
        <button class="nav-pill" id="glowToggle">
          <span class="icon">üè†</span>
          <span>Home</span>
        </button>
        </a>
      </div>
    </div>
  </header>

  <main>
    <!-- SIDEBAR -->
    <aside class="sidebar">
      <div class="sidebar-header">
        <strong>10 Problems</strong><br />
        Click a problem to open its dedicated page.
      </div>
      <ul class="problem-list" id="problemList">
        <!-- Filled by JS -->
      </ul>
      <div class="sidebar-footer">
        Tip: Each problem page shows<br />
        <strong>Problem ¬∑ Solution ¬∑ SDG ¬∑ Photo ¬∑ Code</strong>.
      </div>
    </aside>

    <!-- MAIN PROBLEM VIEW -->
    <section class="problem-view" id="problemView">
      <!-- Filled by JS -->
    </section>
  </main>

  <footer>
    <span>¬© <span class="highlight">Your Name</span> ¬∑ Algorithms Portfolio</span>
    <span>Hosted on <span class="highlight">GitHub Pages</span>.</span>
  </footer>
</div>

<script>
  // ==== DATA: 10 PROBLEMS ====
  const problems = [
   {
      id: 1,
      number: 1,
      title: "Air Quality Prediction Network",
      categoryTag: "",
      shortTag: "Merge Sort",
      time: "O(n)",
      space: "O(n)",
      algorithm: "Merge Sort",
      sdgs: [
        
        "SDG 11 ‚Äì Sustainable Cities and Communities",
        "SDG 3 ‚Äì Good Health and Well-Being"
      ],
      problemText:
        "AQI readings are recorded at different times and need organizing. A simple method is required to sort past AQI data and predict the next value.",
      solutionText: "Historical data is sorted using Merge Sort. The average change between readings is computed and added to the latest value to estimate the next AQ.",
      code: `Merge Sort + AQI Trend Prediction

    #include <iostream>
#include <vector>
using namespace std;

// Structure to store AQI reading with timestamp
struct Reading {
    int time;
    int aqi;
};

// Merge function for merge sort
void merge(vector<Reading>& arr, int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;

    vector<Reading> L(n1), R(n2);

    for (int i = 0; i < n1; i++)
        L[i] = arr[left + i];
    for (int j = 0; j < n2; j++)
        R[j] = arr[mid + 1 + j];

    int i = 0, j = 0, k = left;

    while (i < n1 && j < n2) {
        if (L[i].time <= R[j].time)
            arr[k++] = L[i++];
        else
            arr[k++] = R[j++];
    }

    while (i < n1) arr[k++] = L[i++];
    while (j < n2) arr[k++] = R[j++];
}

// Merge Sort for AQI readings
void mergeSort(vector<Reading>& arr, int left, int right) {
    if (left < right) {
        int mid = left + (right - left) / 2;
        mergeSort(arr, left, mid);
        mergeSort(arr, mid + 1, right);
        merge(arr, left, mid, right);
    }
}

// Function to predict next AQI value
int predictAQI(const vector<Reading>& sorted) {
    if (sorted.size() < 2) return sorted.back().aqi;

    int totalSlope = 0;
    for (size_t i = 1; i < sorted.size(); i++) {
        totalSlope += (sorted[i].aqi - sorted[i - 1].aqi);
    }

    int avgSlope = totalSlope / (sorted.size() - 1);
    return sorted.back().aqi + avgSlope;
}

int main() {
    vector<Reading> data = {
        {5, 120}, {1, 80}, {4, 110}, {2, 90}, {3, 100}
    };

    // Sort data by timestamp
    mergeSort(data, 0, data.size() - 1);

    cout << "Sorted AQI data (time, AQI):\n";
    for (auto& r : data) {
        cout << r.time << " -> " << r.aqi << endl;
    }

    int predicted = predictAQI(data);
    cout << "\nPredicted next AQI: " << predicted << endl;

    return 0;
}

`,
 
    },
    {
      id: 2,
      number: 2,
      title: "Smart Waste Segregation Automation",
      categoryTag: "",
      shortTag: "Binary Tree",
      time: "O(n log n)",
      space: "O(n)",
      algorithm: "Binary Tree",
      sdgs: [
        "SDG 11 ‚Äì sustainable cities and communities",
        "SDG 11 ‚Äì Responsible Consumption and Production",
        "SDG 13 ‚Äì Good Health¬†and¬†Well-Being"
      ],
      problemText:
        "Bins overflow and waste collection is inefficient, causing unhygienic conditions and wasted resources.",
      solutionText:
        "Use smart bins with sensors to detect fill levels. Data is sent to a server, and collection is optimized using routing algorithms to reduce overflow and save time.",
      
       
        code:`Binary Tree
       #include <iostream>
using namespace std;

// Binary Tree Node
struct Node {
    string question;
    string result;
    Node* left;
    Node* right;

    Node(string q = "", string r = "") {
        question = q;
        result = r;
        left = right = NULL;
    }
};

// Function to classify waste
void classify(Node* root) {
    if (root->left == NULL && root->right == NULL) {
        cout << "Waste Category: " << root->result << endl;
        return;
    }

    char choice;
    cout << root->question << " (y/n): ";
    cin >> choice;

    if (choice == 'y')
        classify(root->left);
    else
        classify(root->right);
}

int main() {
    // Building the decision tree
    Node* root = new Node("Is the waste biodegradable?");

    root->left = new Node("Is it food waste?");
    root->right = new Node("Is it plastic?");

    root->left->left = new Node("", "Organic Waste");
    root->left->right = new Node("", "Garden Waste");

    root->right->left = new Node("", "Recyclable Waste");
    root->right->right = new Node("", "Non-Recyclable Waste (Landfill)");

    cout << "Smart Waste Segregation System\n";
    classify(root);

    return 0;
}

`,
 
    },
    {
      id: "3",
      number: 3,
      title: "Smart Water Pipeline Leak Detection",
      categoryTag: "",
      shortTag: "DFS + Binary Tree ",
      time: "O(log n)",
      space: "O(1)",
      algorithm: "DFS + Binary Tree",
      sdgs: [
        "SDG 6 ‚Äì Clean Water & Sanitation Ensures safe water supply and efficient usage",
        "SDG 9 ‚Äì Industry, Innovation & Infrastructure Builds smart pipeline and distribution systems",
        "SDG 11 ‚Äì Sustainable Cities & Communities Supports sustainable water management"
      ],
      problemText:
        "Undetected water leaks in pipelines result in major water loss and infrastructure damage.",
      solutionText:
        "DFS is used to traverse the pipeline network to detect disconnected or faulty sections. Leak records are stored using a Binary Tree for organized monitoring.",
      
       code:`DFS + Binary Tree
      #include <iostream>
using namespace std;

struct Node {
    int id;
    Node *left, *right;
};

Node* newNode(int id) {
    Node* temp = new Node();
    temp->id = id;
    temp->left = temp->right = NULL;
    return temp;
}

Node* insert(Node* root, int id) {
    if(root == NULL)
        return newNode(id);
    if(id < root->id)
        root->left = insert(root->left, id);
    else
        root->right = insert(root->right, id);
    return root;
}

void inorder(Node* root) {
    if(root != NULL) {
        inorder(root->left);
        cout << root->id << " ";
        inorder(root->right);
    }
}

int main() {
    Node* root = NULL;
    root = insert(root, 20);
    root = insert(root, 10);
    root = insert(root, 30);
    root = insert(root, 25);

    cout << "Leak affected pipeline sections:\n";
    inorder(root);
    return 0;
}

`,
 
    },
    {
      id: "4",
      number: 4,
      title: "Emergency Shelter Connectivity Planning",
      categoryTag: "",
      shortTag: "Floyd‚ÄìWarshall",
      time: "O((V+E) log V) using a heap",
      space: "O(V)",
      algorithm: "Floyd‚ÄìWarshall",
      sdgs: [
        "SDG 11 ‚Äì Sustainable Cities and Communities",
        "SDG 3 ‚Äì Good health and Wealth Being",
        "SDG 13 - Climate Action Reduces dependence on fossil fuels"
      ],
      problemText:
        "Poor connectivity between emergency shelters delays evacuation during natural disasters.",
      solutionText:
        "Floyd‚ÄìWarshall algorithm computes the shortest distance between all pairs of shelters, ensuring faster rescue and evacuation planning.",
     code:`Floyd‚ÄìWarshall
     #include <iostream>
using namespace std;

#define INF 9999
#define V 4

void floydWarshall(int graph[V][V]) {
    int dist[V][V];

    for(int i = 0; i < V; i++)
        for(int j = 0; j < V; j++)
            dist[i][j] = graph[i][j];

    for(int k = 0; k < V; k++) {
        for(int i = 0; i < V; i++) {
            for(int j = 0; j < V; j++) {
                if(dist[i][k] + dist[k][j] < dist[i][j])
                    dist[i][j] = dist[i][k] + dist[k][j];
            }
        }
    }

    cout << "Shortest distances between shelters:\n";
    for(int i = 0; i < V; i++) {
        for(int j = 0; j < V; j++)
            cout << dist[i][j] << " ";
        cout << endl;
    }
}

int main() {
    int graph[V][V] = {
        {0, 5, INF, 10},
        {5, 0, 3, INF},
        {INF, 3, 0, 1},
        {10, INF, 1, 0}
    };

    floydWarshall(graph);
    return 0;
}


`,
 
    },
    {
      id: 5,
      number: 5,
      title: "Traffic Signal Optimization",
      categoryTag: "",
      shortTag: "Dijkstra",
      time: "O(n)",
      space: "O(1)",
      algorithm: "Dijkstra",
      sdgs: [
        "SDG 11 ‚Äì Sustainable Cities and Communities",
        "SDG 9 ‚Äì Industry, Innovation and Infrastructure",
        "SDG 3 ‚Äì Good Health & Well-being Ensures safe and fresh food handling"
      ],
      problemText:
        "Urban traffic congestion increases travel time, fuel consumption, and delays emergency vehicles due to inefficient route usage.",
      solutionText:
        "The road network is modeled as a weighted graph. Dijkstra‚Äôs algorithm is applied to find the shortest path from a source junction to all other junctions, helping optimize traffic signal decisions.",
     code:
       `Dijkstra
       #include <iostream>
#include <vector>
#include <climits>
using namespace std;

#define V 6

int minDistance(int dist[], bool visited[]) {
    int min = INT_MAX, index;
    for(int i = 0; i < V; i++) {
        if(!visited[i] && dist[i] <= min) {
            min = dist[i];
            index = i;
        }
    }
    return index;
}

void dijkstra(int graph[V][V], int src) {
    int dist[V];
    bool visited[V];

    for(int i = 0; i < V; i++) {
        dist[i] = INT_MAX;
        visited[i] = false;
    }

    dist[src] = 0;

    for(int count = 0; count < V - 1; count++) {
        int u = minDistance(dist, visited);
        visited[u] = true;

        for(int v = 0; v < V; v++) {
            if(!visited[v] && graph[u][v] &&
               dist[u] != INT_MAX &&
               dist[u] + graph[u][v] < dist[v])
                dist[v] = dist[u] + graph[u][v];
        }
    }

    cout << "Shortest distances from junction " << src << ":\n";
    for(int i = 0; i < V; i++)
        cout << "To junction " << i << " = " << dist[i] << endl;
}

int main() {
    int graph[V][V] = {
        {0, 4, 0, 0, 0, 0},
        {4, 0, 8, 0, 0, 0},
        {0, 8, 0, 7, 0, 4},
        {0, 0, 7, 0, 9, 14},
        {0, 0, 0, 9, 0, 10},
        {0, 0, 4, 14, 10, 0}
    };

    dijkstra(graph, 0);
    return 0;
}

`,
 
    },
    {
      id: 6,
      number: 6,
      title: "Smart Power Line Network Design",
      categoryTag: "",
      shortTag: "Prim",
      time: "O(V + E)",
      space: "O(V)",
      algorithm: "Prim",
      sdgs: [
        "SDG 7 ‚Äì Affordable and Clean Energy",
        "SDG 9 ‚Äì Industry, Innovation & Infrastructure Creates an innovative and collaborative work environment",
        "SDG 11 ‚Äì Sustainable Cities & Communities Efficient use of shared space and resources"
      ],
      problemText:
        "Inefficient power line layouts increase installation and maintenance costs.",
      solutionText:
        "Prim‚Äôs algorithm is used to create a minimum spanning tree that connects all substations with minimum wiring cost.",
     code:
       `Prim
      #include <iostream>
#include <climits>
using namespace std;

#define V 5

int minKey(int key[], bool mstSet[]) {
    int min = INT_MAX, index;
    for(int v = 0; v < V; v++)
        if(!mstSet[v] && key[v] < min)
            min = key[v], index = v;
    return index;
}

void primMST(int graph[V][V]) {
    int parent[V], key[V];
    bool mstSet[V];

    for(int i = 0; i < V; i++)
        key[i] = INT_MAX, mstSet[i] = false;

    key[0] = 0;
    parent[0] = -1;

    for(int count = 0; count < V-1; count++) {
        int u = minKey(key, mstSet);
        mstSet[u] = true;

        for(int v = 0; v < V; v++)
            if(graph[u][v] && !mstSet[v] && graph[u][v] < key[v])
                parent[v] = u, key[v] = graph[u][v];
    }

    cout << "Power line connections:\n";
    for(int i = 1; i < V; i++)
        cout << parent[i] << " - " << i << endl;
}

int main() {
    int graph[V][V] = {
        {0, 2, 0, 6, 0},
        {2, 0, 3, 8, 5},
        {0, 3, 0, 0, 7},
        {6, 8, 0, 0, 9},
        {0, 5, 7, 9, 0}
    };

    primMST(graph);
    return 0;
}

`,
 
    },
    {
      id: 7,
      number: 7,
      title: "Smart Water Distribution & Usage Recording",
      categoryTag: "",
      shortTag: "Prim + AVL Tree",
      time: "O(V + E)",
      space: "O(V)",
      algorithm: "Prim + AVL Tree",
      sdgs: [
        "SDG 9 ‚Äì Industry, Innovation & Infrastructure Builds robust and efficient infrastructure",
        "SDG 11 ‚Äì Sustainable Cities & Communities Supports planned, low-cost development",
        "SDG 6 ‚Äì Clean Water and Sanitation"
      ],
      problemText:
        "Water must be supplied using minimum-cost pipelines while accurately recording household consumption.",
      solutionText:
        "Prim‚Äôs algorithm designs the cheapest pipeline network. An AVL Tree enables fast storage and retrieval of water usage records.",
      
      code:`Prim + AVL Tree
      #include <iostream>
using namespace std;

struct Node {
    int key, height;
    Node *left, *right;
};

int height(Node* n) {
    return n ? n->height : 0;
}

Node* newNode(int key) {
    Node* node = new Node();
    node->key = key;
    node->left = node->right = NULL;
    node->height = 1;
    return node;
}

Node* rightRotate(Node* y) {
    Node* x = y->left;
    Node* T2 = x->right;

    x->right = y;
    y->left = T2;

    y->height = max(height(y->left), height(y->right)) + 1;
    x->height = max(height(x->left), height(x->right)) + 1;

    return x;
}

Node* insert(Node* node, int key) {
    if(!node) return newNode(key);
    if(key < node->key)
        node->left = insert(node->left, key);
    else
        node->right = insert(node->right, key);
    return node;
}

void inorder(Node* root) {
    if(root) {
        inorder(root->left);
        cout << root->key << " ";
        inorder(root->right);
    }
}

int main() {
    Node* root = NULL;
    root = insert(root, 120);
    root = insert(root, 90);
    root = insert(root, 150);

    cout << "Household water usage records:\n";
    inorder(root);
    return 0;
}

`,
 
    },
    {
      id: "8",
      number: 8,
      title: "City Park Connectivity Design",
      categoryTag: "",
      shortTag: "Kruskal‚Äôs",
      time: "O(n log n)",
      space: "O(n)",
      algorithm: "Kruskal‚Äôs",
      sdgs: [
        "SDG 9 ‚Äì Industry, Innovation and Infrastructure",
        "SDG 11 ‚Äì Sustainable Cities & Communities Improves safety and disaster management",
        "SDG 15 ‚Äì Life on Land"
      ],
      problemText:
        "Multiple city parks need walking paths for public access. Constructing unnecessary paths increases project cost.",
      solutionText:
        "Kruskal‚Äôs algorithm selects minimum cost paths without forming cycles, ensuring all parks are connected efficiently.",
     
      code:`Kruskal‚Äôs
      #include <iostream>
#include <algorithm>
using namespace std;

struct Edge {
    int u,v,w;
} e[5];

int parent[5];

int find(int x){
    if(parent[x]==x) return x;
    return parent[x]=find(parent[x]);
}

int main(){
    e[0]={0,1,4};
    e[1]={1,2,3};
    e[2]={0,2,2};
    e[3]={2,3,5};
    e[4]={1,3,1};

    for(int i=0;i<4;i++) parent[i]=i;

    sort(e,e+5,[](Edge a, Edge b){return a.w<b.w;});

    for(int i=0;i<5;i++){
        int x=find(e[i].u);
        int y=find(e[i].v);
        if(x!=y){
            cout<<e[i].u<<" - "<<e[i].v<<endl;
            parent[x]=y;
        }
    }
}

`,
 
    },
    {
      id: 9,
      number: 9,
      title: "Pollution Spread Reachability Analysis",
      categoryTag: "",
      shortTag: "Warshall Algorithm",
      time: "O(n¬∑W)",
      space: "O(W)",
      algorithm: "Warshall Algorithm",
      sdgs: [
        "SDG 13 ‚Äì Climate Action",
        "SDG 3 ‚Äì Good Health and Well-Being",
        "SDG 11 ‚Äì Sustainable Cities and Communities"
      ],
      problemText:
        "Pollution from one industrial area can spread to other connected regions. Identifying reachable pollution zones is necessary.",
      solutionText:
        "Warshall‚Äôs algorithm checks reachability between all regions, helping authorities analyze pollution spread.", 
      code:`Warshall 
     #include <iostream>
using namespace std;
#define V 4

int main(){
    int g[V][V]={
        {0,1,0,0},
        {0,0,1,0},
        {0,0,0,1},
        {0,0,0,0}
    };

    for(int k=0;k<V;k++)
        for(int i=0;i<V;i++)
            for(int j=0;j<V;j++)
                g[i][j]=g[i][j] || (g[i][k] && g[k][j]);

    for(int i=0;i<V;i++){
        for(int j=0;j<V;j++)
            cout<<g[i][j]<<" ";
        cout<<endl;
    }
}

`,
 
    },
    {
      id: 10,
      number: 10,
      title: ": Efficient Waste Sorting in Smart Bins",
      categoryTag: "",
      shortTag: "AVL Tree",
      time: "‚âàO(Œ±(n)) per op",
      space: "O(n)",
      algorithm: "AVL Tree",
      sdgs: [
        "SDG 13 ‚Äì Climate Action",
        "SDG 12 ‚Äì Responsible Consumption and Production",
        "SDG 11 ‚Äì Sustainable Cities & Communities Encourages community engagement through s"
      ],
      problemText:
        "A city wants to manage waste efficiently using smart bins. Each bin contains types of waste (organic, recyclable, hazardous). Design a system to quickly insert, delete, and search waste items to track recycling patterns.",
      solutionText:
        ".",
        code:` AVL Tree
       #include <iostream>
using namespace std;

struct Node {
    int key, height;
    Node *left, *right;
    Node(int k) : key(k), height(1), left(nullptr), right(nullptr) {}
};

int height(Node* n) { return n ? n->height : 0; }
int getBalance(Node* n) { return n ? height(n->left)-height(n->right) : 0; }

Node* rightRotate(Node* y) {
    Node* x = y->left;
    Node* T2 = x->right;
    x->right = y;
    y->left = T2;
    y->height = max(height(y->left), height(y->right))+1;
    x->height = max(height(x->left), height(x->right))+1;
    return x;
}

Node* leftRotate(Node* x) {
    Node* y = x->right;
    Node* T2 = y->left;
    y->left = x;
    x->right = T2;
    x->height = max(height(x->left), height(x->right))+1;
    y->height = max(height(y->left), height(y->right))+1;
    return y;
}

Node* insert(Node* node, int key) {
    if(!node) return new Node(key);
    if(key < node->key) node->left = insert(node->left, key);
    else if(key > node->key) node->right = insert(node->right, key);
    else return node;

    node->height = 1 + max(height(node->left), height(node->right));
    int balance = getBalance(node);

    if(balance>1 && key<node->left->key) return rightRotate(node);
    if(balance<-1 && key>node->right->key) return leftRotate(node);
    if(balance>1 && key>node->left->key) { node->left=leftRotate(node->left); return rightRotate(node); }
    if(balance<-1 && key<node->right->key) { node->right=rightRotate(node->right); return leftRotate(node); }
    return node;
}

void preOrder(Node* root) {
    if(root){ cout<<root->key<<" "; preOrder(root->left); preOrder(root->right);}
}

int main() {
    Node* root = nullptr;
    root = insert(root, 30);
    root = insert(root, 20);
    root = insert(root, 40);
    root = insert(root, 10);
    preOrder(root);
    return 0;
}

`,
 
    }
  ];

  // ==== RENDER SIDEBAR ====
  const problemListEl = document.getElementById("problemList");
  function renderSidebar(activeId) {
    problemListEl.innerHTML = "";
    problems.forEach(p => {
      const li = document.createElement("li");
      li.className = "problem-item" + (p.id === activeId ? " active" : "");
      li.dataset.id = p.id;

      const left = document.createElement("div");
      left.className = "problem-name";
      left.textContent = `#${p.number} ¬∑ ${p.title}`;

      const right = document.createElement("div");
      right.className = "problem-tag";
      right.textContent = p.shortTag;

      li.appendChild(left);
      li.appendChild(right);
      li.addEventListener("click", () => {
        setActiveProblem(p.id, true);
      });

      problemListEl.appendChild(li);
    });
  }

  // ==== RENDER MAIN PROBLEM PAGE ====
  const viewEl = document.getElementById("problemView");

  function renderProblem(problem) {
    const sdgHtml = problem.sdgs
      .map(s => `<span class="sdg-chip">${s}</span>`)
      .join("");

    viewEl.innerHTML = `
      <div class="crumbs">
        Algorithms / <span>Problem #${problem.number}</span>
      </div>

      <div class="problem-header-main">
        <div class="problem-title-block">
          <div class="problem-id-pill">
            <span>Problem #${problem.number}</span>
          </div>
          <h1>${problem.title}</h1>
          <div class="problem-meta-row">
            <span class="algo-chip">${problem.algorithm}</span>
            
            <span><strong>Time:</strong> ${problem.time}</span>
            <span><strong>Space:</strong> ${problem.space}</span>
          </div>
          <div class="sdg-chips">
            ${sdgHtml}
          </div>
        </div>

        
      </div>

      <div class="content-grid">
        <div class="card">
          <div class="card-header">
            <span>Problem &amp; Solution</span>
            <span class="label">Explanation</span>
          </div>
          <div class="card-body">
            <strong>Problem:</strong><br />
            <span>${problem.problemText}</span>
            <br /><br />
            <strong>High-level Solution:</strong><br />
            <span>${problem.solutionText}</span>
          </div>
        </div>

        

      <div class="card code-card">
        <div class="card-header">
          <span>Reference Code</span>
          <span class="label">JavaScript</span>
        </div>
        <div class="card-body">
          <pre id="codeBlock"><code>${problem.code}</code></pre>
        </div>
      </div>
      

      
    `;

    // Hook up copy & raw buttons
    const copyBtn = document.getElementById("copyCodeBtn");
    const rawBtn = document.getElementById("openRawBtn");
    const codeBlock = document.getElementById("codeBlock");

    if (copyBtn && codeBlock) {
      copyBtn.addEventListener("click", () => {
        const text = codeBlock.innerText;
        navigator.clipboard?.writeText(text).then(
          () => { copyBtn.textContent = "‚úÖ Copied"; },
          () => { copyBtn.textContent = "‚ö†Ô∏è Failed"; }
        );
        setTimeout(() => (copyBtn.innerHTML = '<span>üìã</span> Copy Code'), 1200);
      });
    }

    if (rawBtn && codeBlock) {
      rawBtn.addEventListener("click", () => {
        const w = window.open("", "_blank");
        if (!w) return;
        w.document.write("<pre>" + codeBlock.innerText.replace(/</g, "&lt;") + "</pre>");
        w.document.close();
      });
    }
  }

  // ==== ROUTING (HASH-BASED) ====
  function setActiveProblem(id, updateHash) {
    const problem = problems.find(p => p.id === id) || problems[0];
    renderSidebar(problem.id);
    renderProblem(problem);
    if (updateHash) {
      window.location.hash = "problem/" + problem.id;
    }
  }

  function getProblemIdFromHash() {
    const hash = window.location.hash || "";
    const match = hash.match(/problem\/([a-z0-9\-]+)/i);
    return match ? match[1] : null;
  }

  window.addEventListener("hashchange", () => {
    const id = getProblemIdFromHash();
    if (id) setActiveProblem(id, false);
  });

  // ==== GLOW TOGGLE ====
  const glowToggle = document.getElementById("glowToggle");
  let glowOn = true;
  glowToggle?.addEventListener("click", () => {
    document.body.style.filter = glowOn ? "saturate(0.9) brightness(0.95)" : "none";
    glowOn = !glowOn;
  });

  // ==== INITIALISE ====
  (function init() {
    const initialId = getProblemIdFromHash() || problems[0].id;
    setActiveProblem(initialId, true);
  })();
</script>
</body>
</html>

