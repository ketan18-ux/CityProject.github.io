<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Algorithms Portfolio | Your Name</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
 <style>
  /* === Base Styles === */
  body {
    font-family: 'Arial', sans-serif;
    background-color: #f5f5f5;
    padding: 20px;
    margin: 0;
  }

  h2 {
    text-align: center;
    margin-bottom: 20px;
  }

  /* === Container for all rows === */
  .container {
    display: flex;
    gap: 20px;
    justify-content: center;
    align-items: flex-start;
  }

  /* === Columns for Problems and Solutions === */
  .column {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 15px;
  }

  /* === Individual Problem & Solution Blocks === */
  .problem, .solution {
    padding: 15px;
    border-radius: 10px;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    min-width: 250px;
  }

  .problem {
    background-color: #ffecb3; /* light orange */
  }

  .solution {
    background-color: #c8e6c9; /* light green */
  }

  /* === Titles inside blocks === */
  .problem h3, .solution h3 {
    margin-top: 0;
    margin-bottom: 10px;
  }

  /* === Responsive Design === */
  @media (max-width: 1000px) {
    .container {
      flex-direction: column;
    }
    .column {
      flex-direction: row;
      flex-wrap: wrap;
    }
    .problem, .solution {
      flex: 1 1 45%;
    }
  }
</style>



</head>
<body>
<div class="app">
  <header>
    <div class="nav">
      <div class="nav-left">
        <div class="logo-circle">
          <div class="logo-inner">YN</div>
        </div>
        <div class="nav-title">
          <span>Algorithm Notebook</span>
          <span>Your Name</span>
        </div>
      </div>
      <div class="nav-links">
        <a href="https://ketan18-ux.github.io/CityProject.github.io/">
        <button class="nav-pill" id="glowToggle">
          <span class="icon">üè†</span>
          <span>Home</span>
        </button>
        </a>
      </div>
    </div>
  </header>

  <main>
    <!-- SIDEBAR -->
    <aside class="sidebar">
      <div class="sidebar-header">
        <strong>10 Problems</strong><br />
        Click a problem to open its dedicated page.
      </div>
      <ul class="problem-list" id="problemList">
        <!-- Filled by JS -->
      </ul>
      <div class="sidebar-footer">
        Tip: Each problem page shows<br />
        <strong>Problem ¬∑ Solution ¬∑ SDG ¬∑ Photo ¬∑ Code</strong>.
      </div>
    </aside>

    <!-- MAIN PROBLEM VIEW -->
    <section class="problem-view" id="problemView">
      <!-- Filled by JS -->
    </section>
  </main>

  <footer>
    <span>¬© <span class="highlight">Your Name</span> ¬∑ Algorithms Portfolio</span>
    <span>Hosted on <span class="highlight">GitHub Pages</span>.</span>
  </footer>
</div>

<script>
  // ==== DATA: 10 PROBLEMS ====
  const problems = [
   {
      id: 1,
      number: 1,
      title: "Air Quality Prediction Network",
      categoryTag: "",
      shortTag: "Regression + DP Smoothing",
      time: "O(n)",
      space: "O(n)",
      algorithm: "Regression + DP Smoothing",
      sdgs: [
        
        "SDG 3 ‚Äì Good Health and Well-being",
        "SDG 13 ‚Äì Sustainable Cities and Communities"
      ],
      problemText:
        "Air pollution varies over time and is measured using multiple sensors such as PM2.5, NO‚ÇÇ, and CO. Raw sensor data is often noisy, making AQI prediction inaccurate. Therefore, a reliable method is required to predict AQI values accurately and reduce sudden fluctuations.",
      solutionText: "Linear Regression is used to predict AQI from historical multi-sensor data. To handle noise and sudden changes in predictions, Dynamic Programming‚Äìbased smoothing is applied. This produces stable and realistic AQI value.",
      code: `Regression + DP Smoothing

     #include <iostream>
#include <vector>
using namespace std;

/* --------------------------
   Linear Regression Model
--------------------------------*/
class LinearRegression {
    vector<double> weights;
    double bias;
    double lr;
    int epochs;

public:
    LinearRegression(int features, double lr=0.01, int epochs=1000) {
        weights.resize(features, 0.0);
        bias = 0.0;
        this->lr = lr;
        this->epochs = epochs;
    }

    void train(const vector<vector<double>>& X, const vector<double>& y) {
        int n = X.size();
        int m = weights.size();
  for (int e = 0; e < epochs; e++) {
            vector<double> dw(m, 0.0);
            double db = 0.0;

            for (int i = 0; i < n; i++) {
                double y_pred = bias;
                for (int j = 0; j < m; j++)
                    y_pred += weights[j] * X[i][j];

                double error = y_pred - y[i];

                for (int j = 0; j < m; j++)
                    dw[j] += error * X[i][j];
                db += error;
            }

            for (int j = 0; j < m; j++)
                weights[j] -= lr * dw[j] / n;
            bias -= lr * db / n;
        }
    }

    double predict(const vector<double>& x) {
        double result = bias;
        for (int i = 0; i < x.size(); i++)
            result += weights[i] * x[i];
        return result;
    }
};

/* --------------------------
   DP-based Smoothing
--------------------------------*/
vector<double> DPSmoothing(const vector<double>& preds, double alpha) {
    int n = preds.size();
    vector<double> smooth(n);

    smooth[0] = preds[0];
    for (int i = 1; i < n; i++)
        smooth[i] = (preds[i] + alpha * smooth[i - 1]) / (1 + alpha);

    return smooth;
}

/* --------------------------
   Main Function
--------------------------------*/
int main() {
vector<vector<double>> sensors = {
        {40, 20, 0.5},
        {45, 22, 0.6},
        {50, 24, 0.7},
        {55, 26, 0.8},
        {60, 28, 0.9}
    };

    vector<double> AQI = {90, 95, 100, 110, 120};

    LinearRegression model(3);
    model.train(sensors, AQI);

    vector<double> predictions;
    for (int i = 0; i < sensors.size(); i++)
        predictions.push_back(model.predict(sensors[i]));

    double alpha = 5.0;
    vector<double> smoothAQI = DPSmoothing(predictions, alpha);

    cout << "Predicted AQI (Raw):\n";
    for (double v : predictions)
        cout << v << " ";

    cout << "\n\nSmoothed AQI:\n";
    for (double v : smoothAQI)
        cout << v << " ";
    return 0;
}
`,
 
    },
    {
      id: 2,
      number: 2,
      title: "Smart Waste Segregation Automation",
      categoryTag: "",
      shortTag: "Binary Tree",
      time: "O(n log n)",
      space: "O(n)",
      algorithm: "Binary Tree",
      sdgs: [
        "SDG 11 ‚Äì sustainable cities and communities",
        "SDG 11 ‚Äì Responsible Consumption and Production",
        "SDG 13 ‚Äì Good Health¬†and¬†Well-Being"
      ],
      problemText:
        "Bins overflow and waste collection is inefficient, causing unhygienic conditions and wasted resources.",
      solutionText:
        "Use smart bins with sensors to detect fill levels. Data is sent to a server, and collection is optimized using routing algorithms to reduce overflow and save time.",
      
       
        code:`Binary Tree
       #include <iostream>
using namespace std;

// Binary Tree Node
struct Node {
    string question;
    string result;
    Node* left;
    Node* right;

    Node(string q = "", string r = "") {
        question = q;
        result = r;
        left = right = NULL;
    }
};

// Function to classify waste
void classify(Node* root) {
    if (root->left == NULL && root->right == NULL) {
        cout << "Waste Category: " << root->result << endl;
        return;
    }

    char choice;
    cout << root->question << " (y/n): ";
    cin >> choice;

    if (choice == 'y')
        classify(root->left);
    else
        classify(root->right);
}

int main() {
    // Building the decision tree
    Node* root = new Node("Is the waste biodegradable?");

    root->left = new Node("Is it food waste?");
    root->right = new Node("Is it plastic?");

    root->left->left = new Node("", "Organic Waste");
    root->left->right = new Node("", "Garden Waste");

    root->right->left = new Node("", "Recyclable Waste");
    root->right->right = new Node("", "Non-Recyclable Waste (Landfill)");

    cout << "Smart Waste Segregation System\n";
    classify(root);

    return 0;
}

`,
 
    },
    {
      id: "3",
      number: 3,
      title: "Smart Water Pipeline Leak Detection",
      categoryTag: "",
      shortTag: "DFS + Binary Tree ",
      time: "O(log n)",
      space: "O(1)",
      algorithm: "DFS + Binary Tree",
      sdgs: [
        "SDG 6 ‚Äì Clean Water & Sanitation Ensures safe water supply and efficient usage",
        "SDG 9 ‚Äì Industry, Innovation & Infrastructure Builds smart pipeline and distribution systems",
        "SDG 11 ‚Äì Sustainable Cities & Communities Supports sustainable water management"
      ],
      problemText:
        "Undetected water leaks in pipelines result in major water loss and infrastructure damage.",
      solutionText:
        "DFS is used to traverse the pipeline network to detect disconnected or faulty sections. Leak records are stored using a Binary Tree for organized monitoring.",
      
       code:`DFS + Binary Tree
      #include <iostream>
using namespace std;

struct Node {
    int id;
    Node *left, *right;
};

Node* newNode(int id) {
    Node* temp = new Node();
    temp->id = id;
    temp->left = temp->right = NULL;
    return temp;
}

Node* insert(Node* root, int id) {
    if(root == NULL)
        return newNode(id);
    if(id < root->id)
        root->left = insert(root->left, id);
    else
        root->right = insert(root->right, id);
    return root;
}

void inorder(Node* root) {
    if(root != NULL) {
        inorder(root->left);
        cout << root->id << " ";
        inorder(root->right);
    }
}

int main() {
    Node* root = NULL;
    root = insert(root, 20);
    root = insert(root, 10);
    root = insert(root, 30);
    root = insert(root, 25);

    cout << "Leak affected pipeline sections:\n";
    inorder(root);
    return 0;
}

`,
 
    },
    {
      id: "4",
      number: 4,
      title: "Emergency Shelter Connectivity Planning",
      categoryTag: "",
      shortTag: "Floyd‚ÄìWarshall",
      time: "O((V+E) log V) using a heap",
      space: "O(V)",
      algorithm: "Floyd‚ÄìWarshall",
      sdgs: [
        "SDG 11 ‚Äì Sustainable Cities and Communities",
        "SDG 3 ‚Äì Good health and Wealth Being",
        "SDG 13 - Climate Action Reduces dependence on fossil fuels"
      ],
      problemText:
        "Poor connectivity between emergency shelters delays evacuation during natural disasters.",
      solutionText:
        "Floyd‚ÄìWarshall algorithm computes the shortest distance between all pairs of shelters, ensuring faster rescue and evacuation planning.",
     code:`Floyd‚ÄìWarshall
     #include <iostream>
using namespace std;

#define INF 9999
#define V 4

void floydWarshall(int graph[V][V]) {
    int dist[V][V];

    for(int i = 0; i < V; i++)
        for(int j = 0; j < V; j++)
            dist[i][j] = graph[i][j];

    for(int k = 0; k < V; k++) {
        for(int i = 0; i < V; i++) {
            for(int j = 0; j < V; j++) {
                if(dist[i][k] + dist[k][j] < dist[i][j])
                    dist[i][j] = dist[i][k] + dist[k][j];
            }
        }
    }

    cout << "Shortest distances between shelters:\n";
    for(int i = 0; i < V; i++) {
        for(int j = 0; j < V; j++)
            cout << dist[i][j] << " ";
        cout << endl;
    }
}

int main() {
    int graph[V][V] = {
        {0, 5, INF, 10},
        {5, 0, 3, INF},
        {INF, 3, 0, 1},
        {10, INF, 1, 0}
    };

    floydWarshall(graph);
    return 0;
}


`,
 
    },
    {
      id: 5,
      number: 5,
      title: "Traffic Signal Optimization",
      categoryTag: "",
      shortTag: "Dijkstra",
      time: "O(n)",
      space: "O(1)",
      algorithm: "Dijkstra",
      sdgs: [
        "SDG 11 ‚Äì Sustainable Cities and Communities",
        "SDG 9 ‚Äì Industry, Innovation and Infrastructure",
        "SDG 3 ‚Äì Good Health & Well-being Ensures safe and fresh food handling"
      ],
      problemText:
        "Urban traffic congestion increases travel time, fuel consumption, and delays emergency vehicles due to inefficient route usage.",
      solutionText:
        "The road network is modeled as a weighted graph. Dijkstra‚Äôs algorithm is applied to find the shortest path from a source junction to all other junctions, helping optimize traffic signal decisions.",
     code:
       `Dijkstra
       #include <iostream>
#include <vector>
#include <climits>
using namespace std;

#define V 6

int minDistance(int dist[], bool visited[]) {
    int min = INT_MAX, index;
    for(int i = 0; i < V; i++) {
        if(!visited[i] && dist[i] <= min) {
            min = dist[i];
            index = i;
        }
    }
    return index;
}

void dijkstra(int graph[V][V], int src) {
    int dist[V];
    bool visited[V];

    for(int i = 0; i < V; i++) {
        dist[i] = INT_MAX;
        visited[i] = false;
    }

    dist[src] = 0;

    for(int count = 0; count < V - 1; count++) {
        int u = minDistance(dist, visited);
        visited[u] = true;

        for(int v = 0; v < V; v++) {
            if(!visited[v] && graph[u][v] &&
               dist[u] != INT_MAX &&
               dist[u] + graph[u][v] < dist[v])
                dist[v] = dist[u] + graph[u][v];
        }
    }

    cout << "Shortest distances from junction " << src << ":\n";
    for(int i = 0; i < V; i++)
        cout << "To junction " << i << " = " << dist[i] << endl;
}

int main() {
    int graph[V][V] = {
        {0, 4, 0, 0, 0, 0},
        {4, 0, 8, 0, 0, 0},
        {0, 8, 0, 7, 0, 4},
        {0, 0, 7, 0, 9, 14},
        {0, 0, 0, 9, 0, 10},
        {0, 0, 4, 14, 10, 0}
    };

    dijkstra(graph, 0);
    return 0;
}

`,
 
    },
    {
      id: 6,
      number: 6,
      title: "Smart Power Line Network Design",
      categoryTag: "",
      shortTag: "Prim",
      time: "O(V + E)",
      space: "O(V)",
      algorithm: "Prim",
      sdgs: [
        "SDG 7 ‚Äì Affordable and Clean Energy",
        "SDG 9 ‚Äì Industry, Innovation & Infrastructure Creates an innovative and collaborative work environment",
        "SDG 11 ‚Äì Sustainable Cities & Communities Efficient use of shared space and resources"
      ],
      problemText:
        "Inefficient power line layouts increase installation and maintenance costs.",
      solutionText:
        "Prim‚Äôs algorithm is used to create a minimum spanning tree that connects all substations with minimum wiring cost.",
     code:
       `Prim
      #include <iostream>
#include <climits>
using namespace std;

#define V 5

int minKey(int key[], bool mstSet[]) {
    int min = INT_MAX, index;
    for(int v = 0; v < V; v++)
        if(!mstSet[v] && key[v] < min)
            min = key[v], index = v;
    return index;
}

void primMST(int graph[V][V]) {
    int parent[V], key[V];
    bool mstSet[V];

    for(int i = 0; i < V; i++)
        key[i] = INT_MAX, mstSet[i] = false;

    key[0] = 0;
    parent[0] = -1;

    for(int count = 0; count < V-1; count++) {
        int u = minKey(key, mstSet);
        mstSet[u] = true;

        for(int v = 0; v < V; v++)
            if(graph[u][v] && !mstSet[v] && graph[u][v] < key[v])
                parent[v] = u, key[v] = graph[u][v];
    }

    cout << "Power line connections:\n";
    for(int i = 1; i < V; i++)
        cout << parent[i] << " - " << i << endl;
}

int main() {
    int graph[V][V] = {
        {0, 2, 0, 6, 0},
        {2, 0, 3, 8, 5},
        {0, 3, 0, 0, 7},
        {6, 8, 0, 0, 9},
        {0, 5, 7, 9, 0}
    };

    primMST(graph);
    return 0;
}

`,
 
    },
    {
      id: 7,
      number: 7,
      title: "Smart Water Distribution & Usage Recording",
      categoryTag: "",
      shortTag: "Prim + AVL Tree",
      time: "O(V + E)",
      space: "O(V)",
      algorithm: "Prim + AVL Tree",
      sdgs: [
        "SDG 9 ‚Äì Industry, Innovation & Infrastructure Builds robust and efficient infrastructure",
        "SDG 11 ‚Äì Sustainable Cities & Communities Supports planned, low-cost development",
        "SDG 6 ‚Äì Clean Water and Sanitation"
      ],
      problemText:
        "Water must be supplied using minimum-cost pipelines while accurately recording household consumption.",
      solutionText:
        "Prim‚Äôs algorithm designs the cheapest pipeline network. An AVL Tree enables fast storage and retrieval of water usage records.",
      
      code:`Prim + AVL Tree
      #include <iostream>
using namespace std;

struct Node {
    int key, height;
    Node *left, *right;
};

int height(Node* n) {
    return n ? n->height : 0;
}

Node* newNode(int key) {
    Node* node = new Node();
    node->key = key;
    node->left = node->right = NULL;
    node->height = 1;
    return node;
}

Node* rightRotate(Node* y) {
    Node* x = y->left;
    Node* T2 = x->right;

    x->right = y;
    y->left = T2;

    y->height = max(height(y->left), height(y->right)) + 1;
    x->height = max(height(x->left), height(x->right)) + 1;

    return x;
}

Node* insert(Node* node, int key) {
    if(!node) return newNode(key);
    if(key < node->key)
        node->left = insert(node->left, key);
    else
        node->right = insert(node->right, key);
    return node;
}

void inorder(Node* root) {
    if(root) {
        inorder(root->left);
        cout << root->key << " ";
        inorder(root->right);
    }
}

int main() {
    Node* root = NULL;
    root = insert(root, 120);
    root = insert(root, 90);
    root = insert(root, 150);

    cout << "Household water usage records:\n";
    inorder(root);
    return 0;
}

`,
 
    },
    {
      id: "8",
      number: 8,
      title: "City Park Connectivity Design",
      categoryTag: "",
      shortTag: "Kruskal‚Äôs",
      time: "O(n log n)",
      space: "O(n)",
      algorithm: "Kruskal‚Äôs",
      sdgs: [
        "SDG 9 ‚Äì Industry, Innovation and Infrastructure",
        "SDG 11 ‚Äì Sustainable Cities & Communities Improves safety and disaster management",
        "SDG 15 ‚Äì Life on Land"
      ],
      problemText:
        "Multiple city parks need walking paths for public access. Constructing unnecessary paths increases project cost.",
      solutionText:
        "Kruskal‚Äôs algorithm selects minimum cost paths without forming cycles, ensuring all parks are connected efficiently.",
     
      code:`Kruskal‚Äôs
      #include <iostream>
#include <algorithm>
using namespace std;

struct Edge {
    int u,v,w;
} e[5];

int parent[5];

int find(int x){
    if(parent[x]==x) return x;
    return parent[x]=find(parent[x]);
}

int main(){
    e[0]={0,1,4};
    e[1]={1,2,3};
    e[2]={0,2,2};
    e[3]={2,3,5};
    e[4]={1,3,1};

    for(int i=0;i<4;i++) parent[i]=i;

    sort(e,e+5,[](Edge a, Edge b){return a.w<b.w;});

    for(int i=0;i<5;i++){
        int x=find(e[i].u);
        int y=find(e[i].v);
        if(x!=y){
            cout<<e[i].u<<" - "<<e[i].v<<endl;
            parent[x]=y;
        }
    }
}

`,
 
    },
    {
      id: 9,
      number: 9,
      title: "Pollution Spread Reachability Analysis",
      categoryTag: "",
      shortTag: "Warshall Algorithm",
      time: "O(n¬∑W)",
      space: "O(W)",
      algorithm: "Warshall Algorithm",
      sdgs: [
        "SDG 13 ‚Äì Climate Action",
        "SDG 3 ‚Äì Good Health and Well-Being",
        "SDG 11 ‚Äì Sustainable Cities and Communities"
      ],
      problemText:
        "Pollution from one industrial area can spread to other connected regions. Identifying reachable pollution zones is necessary.",
      solutionText:
        "Warshall‚Äôs algorithm checks reachability between all regions, helping authorities analyze pollution spread.", 
      code:`Warshall 
     #include <iostream>
using namespace std;
#define V 4

int main(){
    int g[V][V]={
        {0,1,0,0},
        {0,0,1,0},
        {0,0,0,1},
        {0,0,0,0}
    };

    for(int k=0;k<V;k++)
        for(int i=0;i<V;i++)
            for(int j=0;j<V;j++)
                g[i][j]=g[i][j] || (g[i][k] && g[k][j]);

    for(int i=0;i<V;i++){
        for(int j=0;j<V;j++)
            cout<<g[i][j]<<" ";
        cout<<endl;
    }
}

`,
 
    },
    {
      id: 10,
      number: 10,
      title: "Sports & Recreation Center",
      categoryTag: "",
      shortTag: "Merge Sort+Binary Tree",
      time: "‚âàO(Œ±(n)) per op",
      space: "O(n)",
      algorithm: "Merge Sort+Binary Tree",
      sdgs: [
        "SDG 3 ‚Äì Good Health & Well-being Promotes physical activity and healthy lifestyles",
        "SDG 4 ‚Äì Quality Education Provides training, coaching, and skill development",
        "SDG 11 ‚Äì Sustainable Cities & Communities Encourages community engagement through sports"
      ],
      problemText:
        "Sports centers maintain player details, match scores, coaching information, and event schedules. Players must be ranked and sorted properly.",
      solutionText:
        "Players‚Äô scores can be sorted to generate rankings. Member and event records can be stored in a tree for fast retrieval and updates.",
        code:` MergeSort
        void mergeSort(vector<int>& a, int l, int r) {
    if (l >= r) return;

    int m = (l + r) / 2;
    mergeSort(a, l, m);
    mergeSort(a, m + 1, r);

    vector<int> t;
    int i = l, j = m + 1;

    while (i <= m && j <= r)
        t.push_back(a[i] < a[j] ? a[i++] : a[j++]);

    while (i <= m) t.push_back(a[i++]);
    while (j <= r) t.push_back(a[j++]);

    for (int k = 0; k < t.size(); k++)
        a[l + k] = t[k];
}
Binary Tre
struct Node {
    int data;
    Node* left;
    Node* right;
    Node(int x) : data(x), left(NULL), right(NULL) {}
};

Node* insert(Node* root, int x) {
    if (!root) return new Node(x);
    if (x < root->data) root->left = insert(root->left, x);
    else root->right = insert(root->right, x);
    return root;
}

bool search(Node* root, int x) {
    if (!root) return false;
    if (root->data == x) return true;
    return x < root->data ? search(root->left, x) : search(root->right, x);
}
`,
 
    }
  ];

  // ==== RENDER SIDEBAR ====
  const problemListEl = document.getElementById("problemList");
  function renderSidebar(activeId) {
    problemListEl.innerHTML = "";
    problems.forEach(p => {
      const li = document.createElement("li");
      li.className = "problem-item" + (p.id === activeId ? " active" : "");
      li.dataset.id = p.id;

      const left = document.createElement("div");
      left.className = "problem-name";
      left.textContent = `#${p.number} ¬∑ ${p.title}`;

      const right = document.createElement("div");
      right.className = "problem-tag";
      right.textContent = p.shortTag;

      li.appendChild(left);
      li.appendChild(right);
      li.addEventListener("click", () => {
        setActiveProblem(p.id, true);
      });

      problemListEl.appendChild(li);
    });
  }

  // ==== RENDER MAIN PROBLEM PAGE ====
  const viewEl = document.getElementById("problemView");

  function renderProblem(problem) {
    const sdgHtml = problem.sdgs
      .map(s => `<span class="sdg-chip">${s}</span>`)
      .join("");

    viewEl.innerHTML = `
      <div class="crumbs">
        Algorithms / <span>Problem #${problem.number}</span>
      </div>

      <div class="problem-header-main">
        <div class="problem-title-block">
          <div class="problem-id-pill">
            <span>Problem #${problem.number}</span>
          </div>
          <h1>${problem.title}</h1>
          <div class="problem-meta-row">
            <span class="algo-chip">${problem.algorithm}</span>
            
            <span><strong>Time:</strong> ${problem.time}</span>
            <span><strong>Space:</strong> ${problem.space}</span>
          </div>
          <div class="sdg-chips">
            ${sdgHtml}
          </div>
        </div>

        
      </div>

      <div class="content-grid">
        <div class="card">
          <div class="card-header">
            <span>Problem &amp; Solution</span>
            <span class="label">Explanation</span>
          </div>
          <div class="card-body">
            <strong>Problem:</strong><br />
            <span>${problem.problemText}</span>
            <br /><br />
            <strong>High-level Solution:</strong><br />
            <span>${problem.solutionText}</span>
          </div>
        </div>

        

      <div class="card code-card">
        <div class="card-header">
          <span>Reference Code</span>
          <span class="label">JavaScript</span>
        </div>
        <div class="card-body">
          <pre id="codeBlock"><code>${problem.code}</code></pre>
        </div>
      </div>
      

      
    `;

    // Hook up copy & raw buttons
    const copyBtn = document.getElementById("copyCodeBtn");
    const rawBtn = document.getElementById("openRawBtn");
    const codeBlock = document.getElementById("codeBlock");

    if (copyBtn && codeBlock) {
      copyBtn.addEventListener("click", () => {
        const text = codeBlock.innerText;
        navigator.clipboard?.writeText(text).then(
          () => { copyBtn.textContent = "‚úÖ Copied"; },
          () => { copyBtn.textContent = "‚ö†Ô∏è Failed"; }
        );
        setTimeout(() => (copyBtn.innerHTML = '<span>üìã</span> Copy Code'), 1200);
      });
    }

    if (rawBtn && codeBlock) {
      rawBtn.addEventListener("click", () => {
        const w = window.open("", "_blank");
        if (!w) return;
        w.document.write("<pre>" + codeBlock.innerText.replace(/</g, "&lt;") + "</pre>");
        w.document.close();
      });
    }
  }

  // ==== ROUTING (HASH-BASED) ====
  function setActiveProblem(id, updateHash) {
    const problem = problems.find(p => p.id === id) || problems[0];
    renderSidebar(problem.id);
    renderProblem(problem);
    if (updateHash) {
      window.location.hash = "problem/" + problem.id;
    }
  }

  function getProblemIdFromHash() {
    const hash = window.location.hash || "";
    const match = hash.match(/problem\/([a-z0-9\-]+)/i);
    return match ? match[1] : null;
  }

  window.addEventListener("hashchange", () => {
    const id = getProblemIdFromHash();
    if (id) setActiveProblem(id, false);
  });

  // ==== GLOW TOGGLE ====
  const glowToggle = document.getElementById("glowToggle");
  let glowOn = true;
  glowToggle?.addEventListener("click", () => {
    document.body.style.filter = glowOn ? "saturate(0.9) brightness(0.95)" : "none";
    glowOn = !glowOn;
  });

  // ==== INITIALISE ====
  (function init() {
    const initialId = getProblemIdFromHash() || problems[0].id;
    setActiveProblem(initialId, true);
  })();
</script>
</body>
</html>
