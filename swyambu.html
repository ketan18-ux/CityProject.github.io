<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Algorithms Portfolio | Your Name</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
<style>
/* === Base Reset === */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: 'Orbitron', sans-serif;
  background: #0d0d0d;
  color: #e0e0ff;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  text-shadow: 0 0 5px #00ffff, 0 0 10px #ff00ff;
}

/* === Header === */
header {
  background: linear-gradient(90deg, #0ff, #f0f);
  padding: 12px 25px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-bottom: 2px solid #0ff;
  box-shadow: 0 0 15px #ff00ff;
}

.nav-left {
  display: flex;
  align-items: center;
  gap: 12px;
}

.logo-circle {
  width: 50px;
  height: 50px;
  background: linear-gradient(45deg,#ff00ff,#00ffff);
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: bold;
  color: #0d0d0d;
  font-size: 20px;
  text-shadow: 0 0 5px #fff;
}

.nav-title span:first-child {
  display: block;
  font-weight: 700;
  font-size: 18px;
  color: #fff;
}

.nav-title span:last-child {
  display: block;
  font-size: 13px;
  color: #aaa;
}

.nav-links .nav-pill {
  background: #ff00ff;
  border: 1px solid #0ff;
  padding: 7px 16px;
  border-radius: 30px;
  font-weight: 600;
  color: #0d0d0d;
  cursor: pointer;
  text-transform: uppercase;
  transition: 0.3s;
  display: flex;
  align-items: center;
  gap: 6px;
}

.nav-links .nav-pill:hover {
  background: #0ff;
  color: #000;
  transform: scale(1.08);
  box-shadow: 0 0 20px #ff00ff, 0 0 40px #0ff;
}

/* === Main Layout === */
main {
  display: flex;
  flex: 1;
  padding: 20px;
  gap: 20px;
}

.sidebar {
  width: 260px;
  background: rgba(15, 15, 30, 0.8);
  padding: 20px;
  border-radius: 20px;
  backdrop-filter: blur(12px);
  display: flex;
  flex-direction: column;
  gap: 15px;
  border: 1px solid #0ff;
  box-shadow: 0 0 20px #ff00ff inset;
}

.sidebar-header {
  font-weight: bold;
  margin-bottom: 10px;
  color: #0ff;
}

.problem-list {
  list-style: none;
  overflow-y: auto;
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.problem-item {
  display: flex;
  justify-content: space-between;
  padding: 10px 14px;
  border-radius: 12px;
  background: rgba(255,255,255,0.03);
  cursor: pointer;
  transition: 0.3s;
  border: 1px solid #ff00ff;
}

.problem-item:hover,
.problem-item.active {
  background: #0ff;
  color: #000;
  text-shadow: none;
  box-shadow: 0 0 10px #ff00ff;
}

.problem-name {
  font-size: 14px;
  font-weight: 500;
}

.problem-tag {
  font-size: 12px;
  font-style: italic;
  color: #ff00ff;
}

.sidebar-footer {
  font-size: 11px;
  color: #888;
}

/* === Problem View === */
.problem-view {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 25px;
}

.crumbs {
  font-size: 12px;
  color: #0ff;
}

.problem-header-main {
  background: rgba(20, 20, 50, 0.8);
  padding: 22px;
  border-radius: 18px;
  backdrop-filter: blur(12px);
  display: flex;
  flex-direction: column;
  gap: 18px;
  border: 1px solid #ff00ff;
}

.problem-title-block h1 {
  font-size: 24px;
  margin-bottom: 12px;
  color: #ff00ff;
}

.problem-meta-row {
  display: flex;
  gap: 18px;
  flex-wrap: wrap;
  font-size: 13px;
}

.algo-chip {
  background: #00ffff;
  padding: 4px 12px;
  border-radius: 25px;
  font-size: 12px;
  font-weight: 600;
  color: #0d0d0d;
  text-shadow: none;
}

.sdg-chips {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
}

.sdg-chip {
  background: #ff00ff;
  padding: 4px 12px;
  border-radius: 25px;
  font-size: 12px;
  color: #0d0d0d;
  font-weight: 600;
}

/* === Cards === */
.card {
  background: rgba(25, 25, 50, 0.85);
  border-radius: 20px;
  padding: 18px 22px;
  backdrop-filter: blur(10px);
  box-shadow: 0 8px 20px rgba(0,255,255,0.3);
  border: 1px solid #0ff;
}

.card-header {
  display: flex;
  justify-content: space-between;
  font-weight: 700;
  margin-bottom: 12px;
  font-size: 14px;
  color: #00ffff;
}

.card-body {
  font-size: 14px;
  line-height: 1.5;
  color: #e0e0ff;
}

.code-card pre {
  background: rgba(0,0,0,0.2);
  padding: 14px;
  border-radius: 14px;
  overflow-x: auto;
  color: #0ff;
  font-family: 'Courier New', monospace;
  text-shadow: 0 0 3px #ff00ff;
}

/* === Footer === */
footer {
  background: linear-gradient(90deg,#ff00ff,#0ff);
  text-align: center;
  padding: 15px;
  font-size: 13px;
  color: #0d0d0d;
  display: flex;
  justify-content: space-between;
  gap: 20px;
  flex-wrap: wrap;
  font-weight: 700;
}

/* === Scrollbar Styling === */
.sidebar::-webkit-scrollbar {
  width: 6px;
}

.sidebar::-webkit-scrollbar-thumb {
  background: #ff00ff;
  border-radius: 3px;
}

.sidebar::-webkit-scrollbar-track {
  background: rgba(255,255,255,0.02);
}

/* === Responsive === */
@media (max-width: 900px) {
  main {
    flex-direction: column;
  }
  .sidebar {
    width: 100%;
  }
}
</style>






</head>
<body>
<div class="app">
  <header>
    <div class="nav">
      <div class="nav-left">
        <div class="logo-circle">
          <div class="logo-inner">YN</div>
        </div>
        <div class="nav-title">
          <span>Algorithm Notebook</span>
          <span>Your Name</span>
        </div>
      </div>
      <div class="nav-links">
        <a href="https://ketan18-ux.github.io/CityProject.github.io/">
        <button class="nav-pill" id="glowToggle">
          <span class="icon">üè†</span>
          <span>Home</span>
        </button>
        </a>
      </div>
    </div>
  </header>

  <main>
    <!-- SIDEBAR -->
    <aside class="sidebar">
      <div class="sidebar-header">
        <strong>10 Problems</strong><br />
        Click a problem to open its dedicated page.
      </div>
      <ul class="problem-list" id="problemList">
        <!-- Filled by JS -->
      </ul>
      <div class="sidebar-footer">
        Tip: Each problem page shows<br />
        <strong>Problem ¬∑ Solution ¬∑ SDG ¬∑ Photo ¬∑ Code</strong>.
      </div>
    </aside>

    <!-- MAIN PROBLEM VIEW -->
    <section class="problem-view" id="problemView">
      <!-- Filled by JS -->
    </section>
  </main>

  <footer>
    <span>¬© <span class="highlight">Your Name</span> ¬∑ Algorithms Portfolio</span>
    <span>Hosted on <span class="highlight">GitHub Pages</span>.</span>
  </footer>
</div>

<script>
  // ==== DATA: 10 PROBLEMS ====
  const problems = [
   {
      id: 1,
      number: 1,
      title: "Historical Data Sorting for Resource Allocation",
      categoryTag: "",
      shortTag: "Merge Sort",
      time: "O(n)",
      space: "O(n)",
      algorithm: "Merge Sort",
      sdgs: [
        
        "SDG 11 ‚Äì Sustainable Cities and Communities",
        "SDG 16 ‚Äì Peace, Justice, and Strong Institutions"
      ],
      problemText:
        "The city generates massive amounts of historical data  that needs to be efficiently sorted by time, severity, or location code to analyze trends and prioritize the allocation of limited resources.",
      solutionText: "Apply Merge Sort to the data. This algorithm is ideal for large datasets due to its reliable O(n \log n) time complexity. By sorting the records, city planners can quickly identify high-frequency or high-severity clusters.",
      code: `Merge sort

    #include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

// --- 1. The Merge Function (Combines two sorted subarrays) ---
void merge(vector<int>& arr, int l, int m, int r) {
    // Calculate sizes of the two subarrays to be merged
    int n1 = m - l + 1;
    int n2 = r - m;

    // Create temporary arrays to hold the data
    vector<int> L(n1); 
    vector<int> R(n2);

    // Copy data to temp arrays L[] and R[]
    for (int i = 0; i < n1; i++) {
        L[i] = arr[l + i];
    }
    for (int j = 0; j < n2; j++) {
        R[j] = arr[m + 1 + j];
    }

    // Initialize indices for L[], R[], and the merged array arr[]
    int i = 0; // Initial index of first subarray
    int j = 0; // Initial index of second subarray
    int k = l; // Initial index of merged subarray

    // Merge the temporary arrays back into arr[l..r]
    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) {
            arr[k] = L[i];
            i++;
        } else {
            arr[k] = R[j];
            j++;
        }
        k++;
    }

    // Copy the remaining elements of L[], if there are any
    while (i < n1) {
        arr[k] = L[i];
        i++;
        k++;
    }

    // Copy the remaining elements of R[], if there are any
    while (j < n2) {
        arr[k] = R[j];
        j++;
        k++;
    }
}
//  and [2, 6]) being merged into a single sorted list [1, 2, 5, 6]]

// --- 2. The mergeSort Function (The recursive dividing function) ---
void mergeSort(vector<int>& arr, int l, int r) {
    if (l >= r) {
        return; // Base case: the subarray has 0 or 1 element, already sorted
    }
    
    // Find the middle point to divide the array into two halves
    int m = l + (r - l) / 2;

    // Recursively call mergeSort for the first half
    mergeSort(arr, l, m);

    // Recursively call mergeSort for the second half
    mergeSort(arr, m + 1, r);

    // Merge the two sorted halves
    merge(arr, l, m, r);
}

// --- 3. Example Driver Code ---
int main() {
    // Example: Pothole report severity (10 = highest severity, 1 = lowest)
    // The city wants to sort these reports to prioritize repairs.
    vector<int> report_severities = {9, 2, 10, 5, 1, 7, 3, 8};
    
    cout << "Original Report Severities (Unsorted): ";
    for (int severity : report_severities) {
        cout << severity << " ";
    }
    cout << endl;

    // Call the Merge Sort function
    int n = report_severities.size();
    mergeSort(report_severities, 0, n - 1);

    cout << "Sorted Report Severities (Highest Priority Last): ";
    for (int severity : report_severities) {
        cout << severity << " ";
    }
    cout << endl; // Output: 1 2 3 5 7 8 9 10
    
    return 0;
}
`,
 
    },
    {
      id: 2,
      number: 2,
      title: "Smart Waste Segregation Automation",
      categoryTag: "",
      shortTag: "Binary Tree",
      time: "O(n log n)",
      space: "O(n)",
      algorithm: "Binary Tree",
      sdgs: [
        "SDG 11 ‚Äì sustainable cities and communities",
        "SDG 11 ‚Äì Responsible Consumption and Production",
        "SDG 13 ‚Äì Good Health¬†and¬†Well-Being"
      ],
      problemText:
        "Bins overflow and waste collection is inefficient, causing unhygienic conditions and wasted resources.",
      solutionText:
        "Use smart bins with sensors to detect fill levels. Data is sent to a server, and collection is optimized using routing algorithms to reduce overflow and save time.",
      
       
        code:`Binary Tree
       #include <iostream>
using namespace std;

// Binary Tree Node
struct Node {
    string question;
    string result;
    Node* left;
    Node* right;

    Node(string q = "", string r = "") {
        question = q;
        result = r;
        left = right = NULL;
    }
};

// Function to classify waste
void classify(Node* root) {
    if (root->left == NULL && root->right == NULL) {
        cout << "Waste Category: " << root->result << endl;
        return;
    }

    char choice;
    cout << root->question << " (y/n): ";
    cin >> choice;

    if (choice == 'y')
        classify(root->left);
    else
        classify(root->right);
}

int main() {
    // Building the decision tree
    Node* root = new Node("Is the waste biodegradable?");

    root->left = new Node("Is it food waste?");
    root->right = new Node("Is it plastic?");

    root->left->left = new Node("", "Organic Waste");
    root->left->right = new Node("", "Garden Waste");

    root->right->left = new Node("", "Recyclable Waste");
    root->right->right = new Node("", "Non-Recyclable Waste (Landfill)");

    cout << "Smart Waste Segregation System\n";
    classify(root);

    return 0;
}

`,
 
    },
    {
      id: "3",
      number: 3,
      title: "Smart Water Pipeline Leak Detection",
      categoryTag: "",
      shortTag: "DFS + Binary Tree ",
      time: "O(log n)",
      space: "O(1)",
      algorithm: "DFS + Binary Tree",
      sdgs: [
        "SDG 6 ‚Äì Clean Water & Sanitation Ensures safe water supply and efficient usage",
        "SDG 9 ‚Äì Industry, Innovation & Infrastructure Builds smart pipeline and distribution systems",
        "SDG 11 ‚Äì Sustainable Cities & Communities Supports sustainable water management"
      ],
      problemText:
        "Undetected water leaks in pipelines result in major water loss and infrastructure damage.",
      solutionText:
        "DFS is used to traverse the pipeline network to detect disconnected or faulty sections. Leak records are stored using a Binary Tree for organized monitoring.",
      
       code:`DFS + Binary Tree
      #include <iostream>
using namespace std;

struct Node {
    int id;
    Node *left, *right;
};

Node* newNode(int id) {
    Node* temp = new Node();
    temp->id = id;
    temp->left = temp->right = NULL;
    return temp;
}

Node* insert(Node* root, int id) {
    if(root == NULL)
        return newNode(id);
    if(id < root->id)
        root->left = insert(root->left, id);
    else
        root->right = insert(root->right, id);
    return root;
}

void inorder(Node* root) {
    if(root != NULL) {
        inorder(root->left);
        cout << root->id << " ";
        inorder(root->right);
    }
}

int main() {
    Node* root = NULL;
    root = insert(root, 20);
    root = insert(root, 10);
    root = insert(root, 30);
    root = insert(root, 25);

    cout << "Leak affected pipeline sections:\n";
    inorder(root);
    return 0;
}

`,
 
    },
    {
      id: "4",
      number: 4,
      title: "Emergency Shelter Connectivity Planning",
      categoryTag: "",
      shortTag: "Floyd‚ÄìWarshall",
      time: "O((V+E) log V) using a heap",
      space: "O(V)",
      algorithm: "Floyd‚ÄìWarshall",
      sdgs: [
        "SDG 11 ‚Äì Sustainable Cities and Communities",
        "SDG 3 ‚Äì Good health and Wealth Being",
        "SDG 13 - Climate Action Reduces dependence on fossil fuels"
      ],
      problemText:
        "Poor connectivity between emergency shelters delays evacuation during natural disasters.",
      solutionText:
        "Floyd‚ÄìWarshall algorithm computes the shortest distance between all pairs of shelters, ensuring faster rescue and evacuation planning.",
     code:`Floyd‚ÄìWarshall
     #include <iostream>
using namespace std;

#define INF 9999
#define V 4

void floydWarshall(int graph[V][V]) {
    int dist[V][V];

    for(int i = 0; i < V; i++)
        for(int j = 0; j < V; j++)
            dist[i][j] = graph[i][j];

    for(int k = 0; k < V; k++) {
        for(int i = 0; i < V; i++) {
            for(int j = 0; j < V; j++) {
                if(dist[i][k] + dist[k][j] < dist[i][j])
                    dist[i][j] = dist[i][k] + dist[k][j];
            }
        }
    }

    cout << "Shortest distances between shelters:\n";
    for(int i = 0; i < V; i++) {
        for(int j = 0; j < V; j++)
            cout << dist[i][j] << " ";
        cout << endl;
    }
}

int main() {
    int graph[V][V] = {
        {0, 5, INF, 10},
        {5, 0, 3, INF},
        {INF, 3, 0, 1},
        {10, INF, 1, 0}
    };

    floydWarshall(graph);
    return 0;
}


`,
 
    },
    {
      id: 5,
      number: 5,
      title: "Traffic Signal Optimization",
      categoryTag: "",
      shortTag: "Dijkstra",
      time: "O(n)",
      space: "O(1)",
      algorithm: "Dijkstra",
      sdgs: [
        "SDG 11 ‚Äì Sustainable Cities and Communities",
        "SDG 9 ‚Äì Industry, Innovation and Infrastructure",
        "SDG 3 ‚Äì Good Health & Well-being Ensures safe and fresh food handling"
      ],
      problemText:
        "Urban traffic congestion increases travel time, fuel consumption, and delays emergency vehicles due to inefficient route usage.",
      solutionText:
        "The road network is modeled as a weighted graph. Dijkstra‚Äôs algorithm is applied to find the shortest path from a source junction to all other junctions, helping optimize traffic signal decisions.",
     code:
       `Dijkstra
       #include <iostream>
#include <vector>
#include <climits>
using namespace std;

#define V 6

int minDistance(int dist[], bool visited[]) {
    int min = INT_MAX, index;
    for(int i = 0; i < V; i++) {
        if(!visited[i] && dist[i] <= min) {
            min = dist[i];
            index = i;
        }
    }
    return index;
}

void dijkstra(int graph[V][V], int src) {
    int dist[V];
    bool visited[V];

    for(int i = 0; i < V; i++) {
        dist[i] = INT_MAX;
        visited[i] = false;
    }

    dist[src] = 0;

    for(int count = 0; count < V - 1; count++) {
        int u = minDistance(dist, visited);
        visited[u] = true;

        for(int v = 0; v < V; v++) {
            if(!visited[v] && graph[u][v] &&
               dist[u] != INT_MAX &&
               dist[u] + graph[u][v] < dist[v])
                dist[v] = dist[u] + graph[u][v];
        }
    }

    cout << "Shortest distances from junction " << src << ":\n";
    for(int i = 0; i < V; i++)
        cout << "To junction " << i << " = " << dist[i] << endl;
}

int main() {
    int graph[V][V] = {
        {0, 4, 0, 0, 0, 0},
        {4, 0, 8, 0, 0, 0},
        {0, 8, 0, 7, 0, 4},
        {0, 0, 7, 0, 9, 14},
        {0, 0, 0, 9, 0, 10},
        {0, 0, 4, 14, 10, 0}
    };

    dijkstra(graph, 0);
    return 0;
}

`,
 
    },
    {
      id: 6,
      number: 6,
      title: "Smart Power Line Network Design",
      categoryTag: "",
      shortTag: "Prim",
      time: "O(V + E)",
      space: "O(V)",
      algorithm: "Prim",
      sdgs: [
        "SDG 7 ‚Äì Affordable and Clean Energy",
        "SDG 9 ‚Äì Industry, Innovation & Infrastructure Creates an innovative and collaborative work environment",
        "SDG 11 ‚Äì Sustainable Cities & Communities Efficient use of shared space and resources"
      ],
      problemText:
        "Inefficient power line layouts increase installation and maintenance costs.",
      solutionText:
        "Prim‚Äôs algorithm is used to create a minimum spanning tree that connects all substations with minimum wiring cost.",
     code:
       `Prim
      #include <iostream>
#include <climits>
using namespace std;

#define V 5

int minKey(int key[], bool mstSet[]) {
    int min = INT_MAX, index;
    for(int v = 0; v < V; v++)
        if(!mstSet[v] && key[v] < min)
            min = key[v], index = v;
    return index;
}

void primMST(int graph[V][V]) {
    int parent[V], key[V];
    bool mstSet[V];

    for(int i = 0; i < V; i++)
        key[i] = INT_MAX, mstSet[i] = false;

    key[0] = 0;
    parent[0] = -1;

    for(int count = 0; count < V-1; count++) {
        int u = minKey(key, mstSet);
        mstSet[u] = true;

        for(int v = 0; v < V; v++)
            if(graph[u][v] && !mstSet[v] && graph[u][v] < key[v])
                parent[v] = u, key[v] = graph[u][v];
    }

    cout << "Power line connections:\n";
    for(int i = 1; i < V; i++)
        cout << parent[i] << " - " << i << endl;
}

int main() {
    int graph[V][V] = {
        {0, 2, 0, 6, 0},
        {2, 0, 3, 8, 5},
        {0, 3, 0, 0, 7},
        {6, 8, 0, 0, 9},
        {0, 5, 7, 9, 0}
    };

    primMST(graph);
    return 0;
}

`,
 
    },
    {
      id: 7,
      number: 7,
      title: "Smart Water Distribution & Usage Recording",
      categoryTag: "",
      shortTag: "Prim + AVL Tree",
      time: "O(V + E)",
      space: "O(V)",
      algorithm: "Prim + AVL Tree",
      sdgs: [
        "SDG 9 ‚Äì Industry, Innovation & Infrastructure Builds robust and efficient infrastructure",
        "SDG 11 ‚Äì Sustainable Cities & Communities Supports planned, low-cost development",
        "SDG 6 ‚Äì Clean Water and Sanitation"
      ],
      problemText:
        "Water must be supplied using minimum-cost pipelines while accurately recording household consumption.",
      solutionText:
        "Prim‚Äôs algorithm designs the cheapest pipeline network. An AVL Tree enables fast storage and retrieval of water usage records.",
      
      code:`Prim + AVL Tree
      #include <iostream>
using namespace std;

struct Node {
    int key, height;
    Node *left, *right;
};

int height(Node* n) {
    return n ? n->height : 0;
}

Node* newNode(int key) {
    Node* node = new Node();
    node->key = key;
    node->left = node->right = NULL;
    node->height = 1;
    return node;
}

Node* rightRotate(Node* y) {
    Node* x = y->left;
    Node* T2 = x->right;

    x->right = y;
    y->left = T2;

    y->height = max(height(y->left), height(y->right)) + 1;
    x->height = max(height(x->left), height(x->right)) + 1;

    return x;
}

Node* insert(Node* node, int key) {
    if(!node) return newNode(key);
    if(key < node->key)
        node->left = insert(node->left, key);
    else
        node->right = insert(node->right, key);
    return node;
}

void inorder(Node* root) {
    if(root) {
        inorder(root->left);
        cout << root->key << " ";
        inorder(root->right);
    }
}

int main() {
    Node* root = NULL;
    root = insert(root, 120);
    root = insert(root, 90);
    root = insert(root, 150);

    cout << "Household water usage records:\n";
    inorder(root);
    return 0;
}

`,
 
    },
    {
      id: "8",
      number: 8,
      title: "City Park Connectivity Design",
      categoryTag: "",
      shortTag: "Kruskal‚Äôs",
      time: "O(n log n)",
      space: "O(n)",
      algorithm: "Kruskal‚Äôs",
      sdgs: [
        "SDG 9 ‚Äì Industry, Innovation and Infrastructure",
        "SDG 11 ‚Äì Sustainable Cities & Communities Improves safety and disaster management",
        "SDG 15 ‚Äì Life on Land"
      ],
      problemText:
        "Multiple city parks need walking paths for public access. Constructing unnecessary paths increases project cost.",
      solutionText:
        "Kruskal‚Äôs algorithm selects minimum cost paths without forming cycles, ensuring all parks are connected efficiently.",
     
      code:`Kruskal‚Äôs
      #include <iostream>
#include <algorithm>
using namespace std;

struct Edge {
    int u,v,w;
} e[5];

int parent[5];

int find(int x){
    if(parent[x]==x) return x;
    return parent[x]=find(parent[x]);
}

int main(){
    e[0]={0,1,4};
    e[1]={1,2,3};
    e[2]={0,2,2};
    e[3]={2,3,5};
    e[4]={1,3,1};

    for(int i=0;i<4;i++) parent[i]=i;

    sort(e,e+5,[](Edge a, Edge b){return a.w<b.w;});

    for(int i=0;i<5;i++){
        int x=find(e[i].u);
        int y=find(e[i].v);
        if(x!=y){
            cout<<e[i].u<<" - "<<e[i].v<<endl;
            parent[x]=y;
        }
    }
}

`,
 
    },
    {
      id: 9,
      number: 9,
      title: "Pollution Spread Reachability Analysis",
      categoryTag: "",
      shortTag: "Warshall Algorithm",
      time: "O(n¬∑W)",
      space: "O(W)",
      algorithm: "Warshall Algorithm",
      sdgs: [
        "SDG 13 ‚Äì Climate Action",
        "SDG 3 ‚Äì Good Health and Well-Being",
        "SDG 11 ‚Äì Sustainable Cities and Communities"
      ],
      problemText:
        "Pollution from one industrial area can spread to other connected regions. Identifying reachable pollution zones is necessary.",
      solutionText:
        "Warshall‚Äôs algorithm checks reachability between all regions, helping authorities analyze pollution spread.", 
      code:`Warshall 
     #include <iostream>
using namespace std;
#define V 4

int main(){
    int g[V][V]={
        {0,1,0,0},
        {0,0,1,0},
        {0,0,0,1},
        {0,0,0,0}
    };

    for(int k=0;k<V;k++)
        for(int i=0;i<V;i++)
            for(int j=0;j<V;j++)
                g[i][j]=g[i][j] || (g[i][k] && g[k][j]);

    for(int i=0;i<V;i++){
        for(int j=0;j<V;j++)
            cout<<g[i][j]<<" ";
        cout<<endl;
    }
}

`,
 
    },
    {
      id: 10,
      number: 10,
      title: ": Efficient Waste Sorting in Smart Bins",
      categoryTag: "",
      shortTag: "AVL Tree",
      time: "‚âàO(Œ±(n)) per op",
      space: "O(n)",
      algorithm: "AVL Tree",
      sdgs: [
        "SDG 13 ‚Äì Climate Action",
        "SDG 12 ‚Äì Responsible Consumption and Production",
        "SDG 11 ‚Äì Sustainable Cities & Communities Encourages community engagement through s"
      ],
      problemText:
        "A city wants to manage waste efficiently using smart bins. Each bin contains types of waste (organic, recyclable, hazardous). Design a system to quickly insert, delete, and search waste items to track recycling patterns.",
      solutionText:
        ".",
        code:` AVL Tree
       #include <iostream>
using namespace std;

struct Node {
    int key, height;
    Node *left, *right;
    Node(int k) : key(k), height(1), left(nullptr), right(nullptr) {}
};

int height(Node* n) { return n ? n->height : 0; }
int getBalance(Node* n) { return n ? height(n->left)-height(n->right) : 0; }

Node* rightRotate(Node* y) {
    Node* x = y->left;
    Node* T2 = x->right;
    x->right = y;
    y->left = T2;
    y->height = max(height(y->left), height(y->right))+1;
    x->height = max(height(x->left), height(x->right))+1;
    return x;
}

Node* leftRotate(Node* x) {
    Node* y = x->right;
    Node* T2 = y->left;
    y->left = x;
    x->right = T2;
    x->height = max(height(x->left), height(x->right))+1;
    y->height = max(height(y->left), height(y->right))+1;
    return y;
}

Node* insert(Node* node, int key) {
    if(!node) return new Node(key);
    if(key < node->key) node->left = insert(node->left, key);
    else if(key > node->key) node->right = insert(node->right, key);
    else return node;

    node->height = 1 + max(height(node->left), height(node->right));
    int balance = getBalance(node);

    if(balance>1 && key<node->left->key) return rightRotate(node);
    if(balance<-1 && key>node->right->key) return leftRotate(node);
    if(balance>1 && key>node->left->key) { node->left=leftRotate(node->left); return rightRotate(node); }
    if(balance<-1 && key<node->right->key) { node->right=rightRotate(node->right); return leftRotate(node); }
    return node;
}

void preOrder(Node* root) {
    if(root){ cout<<root->key<<" "; preOrder(root->left); preOrder(root->right);}
}

int main() {
    Node* root = nullptr;
    root = insert(root, 30);
    root = insert(root, 20);
    root = insert(root, 40);
    root = insert(root, 10);
    preOrder(root);
    return 0;
}

`,
 
    }
  ];

  // ==== RENDER SIDEBAR ====
  const problemListEl = document.getElementById("problemList");
  function renderSidebar(activeId) {
    problemListEl.innerHTML = "";
    problems.forEach(p => {
      const li = document.createElement("li");
      li.className = "problem-item" + (p.id === activeId ? " active" : "");
      li.dataset.id = p.id;

      const left = document.createElement("div");
      left.className = "problem-name";
      left.textContent = `#${p.number} ¬∑ ${p.title}`;

      const right = document.createElement("div");
      right.className = "problem-tag";
      right.textContent = p.shortTag;

      li.appendChild(left);
      li.appendChild(right);
      li.addEventListener("click", () => {
        setActiveProblem(p.id, true);
      });

      problemListEl.appendChild(li);
    });
  }

  // ==== RENDER MAIN PROBLEM PAGE ====
  const viewEl = document.getElementById("problemView");

  function renderProblem(problem) {
    const sdgHtml = problem.sdgs
      .map(s => `<span class="sdg-chip">${s}</span>`)
      .join("");

    viewEl.innerHTML = `
      <div class="crumbs">
        Algorithms / <span>Problem #${problem.number}</span>
      </div>

      <div class="problem-header-main">
        <div class="problem-title-block">
          <div class="problem-id-pill">
            <span>Problem #${problem.number}</span>
          </div>
          <h1>${problem.title}</h1>
          <div class="problem-meta-row">
            <span class="algo-chip">${problem.algorithm}</span>
            
            <span><strong>Time:</strong> ${problem.time}</span>
            <span><strong>Space:</strong> ${problem.space}</span>
          </div>
          <div class="sdg-chips">
            ${sdgHtml}
          </div>
        </div>

        
      </div>

      <div class="content-grid">
        <div class="card">
          <div class="card-header">
            <span>Problem &amp; Solution</span>
            <span class="label">Explanation</span>
          </div>
          <div class="card-body">
            <strong>Problem:</strong><br />
            <span>${problem.problemText}</span>
            <br /><br />
            <strong>High-level Solution:</strong><br />
            <span>${problem.solutionText}</span>
          </div>
        </div>

        

      <div class="card code-card">
        <div class="card-header">
          <span>Reference Code</span>
          <span class="label">JavaScript</span>
        </div>
        <div class="card-body">
          <pre id="codeBlock"><code>${problem.code}</code></pre>
        </div>
      </div>
      

      
    `;

    // Hook up copy & raw buttons
    const copyBtn = document.getElementById("copyCodeBtn");
    const rawBtn = document.getElementById("openRawBtn");
    const codeBlock = document.getElementById("codeBlock");

    if (copyBtn && codeBlock) {
      copyBtn.addEventListener("click", () => {
        const text = codeBlock.innerText;
        navigator.clipboard?.writeText(text).then(
          () => { copyBtn.textContent = "‚úÖ Copied"; },
          () => { copyBtn.textContent = "‚ö†Ô∏è Failed"; }
        );
        setTimeout(() => (copyBtn.innerHTML = '<span>üìã</span> Copy Code'), 1200);
      });
    }

    if (rawBtn && codeBlock) {
      rawBtn.addEventListener("click", () => {
        const w = window.open("", "_blank");
        if (!w) return;
        w.document.write("<pre>" + codeBlock.innerText.replace(/</g, "&lt;") + "</pre>");
        w.document.close();
      });
    }
  }

  // ==== ROUTING (HASH-BASED) ====
  function setActiveProblem(id, updateHash) {
    const problem = problems.find(p => p.id === id) || problems[0];
    renderSidebar(problem.id);
    renderProblem(problem);
    if (updateHash) {
      window.location.hash = "problem/" + problem.id;
    }
  }

  function getProblemIdFromHash() {
    const hash = window.location.hash || "";
    const match = hash.match(/problem\/([a-z0-9\-]+)/i);
    return match ? match[1] : null;
  }

  window.addEventListener("hashchange", () => {
    const id = getProblemIdFromHash();
    if (id) setActiveProblem(id, false);
  });

  // ==== GLOW TOGGLE ====
  const glowToggle = document.getElementById("glowToggle");
  let glowOn = true;
  glowToggle?.addEventListener("click", () => {
    document.body.style.filter = glowOn ? "saturate(0.9) brightness(0.95)" : "none";
    glowOn = !glowOn;
  });

  // ==== INITIALISE ====
  (function init() {
    const initialId = getProblemIdFromHash() || problems[0].id;
    setActiveProblem(initialId, true);
  })();
</script>
</body>
</html>
