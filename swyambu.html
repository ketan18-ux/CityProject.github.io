<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Algorithms Portfolio | Your Name</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root {
      --bg: #020617;
      --bg-alt: #020617;
      --surface: #020617;
      --border-subtle: #1f2937;
      --border-strong: #374151;
      --accent: #f97316;
      --accent-soft: rgba(249, 115, 22, 0.16);
      --text: #f9fafb;
      --muted: #9ca3af;
      --radius-lg: 18px;
      --radius-xl: 22px;
      --shadow-soft: 0 20px 40px rgba(0, 0, 0, 0.45);
      --font-sans: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      --font-mono: "Fira Code", Consolas, Menlo, monospace;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: var(--font-sans);
      background: radial-gradient(circle at top, #020617 0, #000000 55%, #020617 100%);
      color: var(--text);
      -webkit-font-smoothing: antialiased;
    }

    a {
      color: var(--accent);
      text-decoration: none;
    }
    a:hover {
      text-decoration: underline;
    }

    .app {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      position: sticky;
      top: 0;
      z-index: 20;
      backdrop-filter: blur(18px);
      background: linear-gradient(to right, rgba(15,23,42,0.96), rgba(15,23,42,0.92));
      border-bottom: 1px solid rgba(75, 85, 99, 0.8);
    }

    .nav {
      max-width: 1180px;
      margin: 0 auto;
      padding: 10px 16px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }

    .nav-left {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .logo-circle {
      width: 34px;
      height: 34px;
      border-radius: 999px;
      background: conic-gradient(from 180deg, #f97316, #38bdf8, #8b5cf6, #f97316);
      padding: 2px;
      box-shadow: 0 10px 25px rgba(15, 23, 42, 0.8);
    }

    .logo-inner {
      width: 100%;
      height: 100%;
      border-radius: inherit;
      background: #020617;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      font-size: 14px;
      color: var(--accent);
    }

    .nav-title {
      display: flex;
      flex-direction: column;
      font-size: 13px;
    }

    .nav-title span:first-child {
      letter-spacing: 0.16em;
      text-transform: uppercase;
      color: var(--muted);
      font-size: 11px;
    }

    .nav-title span:last-child {
      font-weight: 600;
    }

    .nav-links {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 12px;
      color: var(--muted);
    }

    .nav-links a {
      padding: 4px 8px;
      border-radius: 999px;
      color: var(--muted);
    }

    .nav-links a:hover {
      background: rgba(30, 64, 175, 0.25);
      color: var(--text);
      text-decoration: none;
    }

    .nav-pill {
      border-radius: 999px;
      border: 1px solid rgba(249, 115, 22, 0.4);
      padding: 5px 11px;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      background: radial-gradient(circle at 0 0, rgba(249, 115, 22, 0.22), transparent 55%);
      font-size: 11px;
      color: var(--accent);
      cursor: pointer;
    }

    .nav-pill span.icon {
      font-size: 14px;
    }

    main {
      flex: 1;
      max-width: 1180px;
      margin: 0 auto;
      padding: 18px 16px 40px;
      display: grid;
      grid-template-columns: 270px minmax(0, 1fr);
      gap: 18px;
      align-items: flex-start;
    }

    /* Sidebar */
    .sidebar {
      border-radius: var(--radius-xl);
      background: radial-gradient(circle at top, rgba(15,23,42,0.95), #020617);
      border: 1px solid var(--border-strong);
      box-shadow: var(--shadow-soft);
      padding: 14px 12px 12px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .sidebar-header {
      font-size: 12px;
      color: var(--muted);
    }

    .sidebar-header strong {
      color: #e5e7eb;
      font-size: 13px;
    }

    .problem-list {
      list-style: none;
      padding: 0;
      margin: 4px 0 0;
      display: flex;
      flex-direction: column;
      gap: 5px;
      max-height: 480px;
      overflow: auto;
      scrollbar-width: thin;
      scrollbar-color: #4b5563 transparent;
    }

    .problem-list::-webkit-scrollbar {
      width: 5px;
    }
    .problem-list::-webkit-scrollbar-thumb {
      background: #4b5563;
      border-radius: 999px;
    }

    .problem-item {
      border-radius: 12px;
      border: 1px solid var(--border-subtle);
      background: rgba(15,23,42,0.92);
      padding: 7px 8px;
      font-size: 12px;
      color: var(--muted);
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      gap: 6px;
      align-items: center;
      transition: border 0.12s, background 0.12s, transform 0.08s;
    }

    .problem-item:hover {
      border-color: rgba(96, 165, 250, 0.9);
      background: rgba(15, 23, 42, 1);
      transform: translateY(-1px);
    }

    .problem-item.active {
      border-color: var(--accent);
      background: rgba(15, 23, 42, 1);
      color: #e5e7eb;
    }

    .problem-name {
      flex: 1;
    }

    .problem-tag {
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.7);
      color: var(--muted);
      white-space: nowrap;
    }

    .sidebar-footer {
      margin-top: 4px;
      font-size: 11px;
      color: var(--muted);
      border-top: 1px solid var(--border-subtle);
      padding-top: 6px;
    }

    /* Main problem view */
    .problem-view {
      border-radius: var(--radius-xl);
      background: radial-gradient(circle at top left, rgba(15,23,42,0.95), #020617);
      border: 1px solid var(--border-strong);
      box-shadow: var(--shadow-soft);
      padding: 14px 14px 16px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .crumbs {
      font-size: 11px;
      color: var(--muted);
    }

    .crumbs span {
      color: #e5e7eb;
    }

    .problem-header-main {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 8px;
    }

    .problem-title-block {
      display: flex;
      flex-direction: column;
      gap: 3px;
    }

    .problem-id-pill {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 2px 7px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.7);
      font-size: 11px;
      color: var(--muted);
    }

    .problem-title-block h1 {
      font-size: 20px;
      margin: 0;
    }

    .problem-meta-row {
      display: flex;
      flex-wrap: wrap;
      gap: 7px;
      font-size: 11px;
      color: var(--muted);
    }

    .problem-meta-row strong {
      color: #e5e7eb;
      font-weight: 500;
    }

    .algo-chip {
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid rgba(96, 165, 250, 0.9);
      font-size: 11px;
      color: #bfdbfe;
      background: rgba(15, 23, 42, 0.96);
    }

    .sdg-chips {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 3px;
    }

    .sdg-chip {
      font-size: 10px;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid rgba(45, 212, 191, 0.8);
      background: rgba(15, 23, 42, 0.98);
      color: #a7f3d0;
    }

    .problem-actions-main {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .btn-sm {
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.8);
      padding: 5px 10px;
      font-size: 11px;
      color: var(--muted);
      background: rgba(15, 23, 42, 0.9);
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 5px;
    }

    .btn-sm:hover {
      background: rgba(15, 23, 42, 1);
      color: #e5e7eb;
    }

    .content-grid {
      display: grid;
      grid-template-columns: minmax(0, 1fr);
      gap: 12px;
      align-items: stretch;
    }

    .card {
      border-radius: var(--radius-lg);
      border: 1px solid var(--border-subtle);
      background: rgba(15, 23, 42, 0.98);
      padding: 10px 10px 9px;
      font-size: 13px;
      color: var(--muted);
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .card-header {
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.14em;
      color: var(--muted);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .card-header span.label {
      font-weight: 500;
      color: #e5e7eb;
      text-transform: none;
      letter-spacing: 0;
      font-size: 12px;
    }

    .card-body {
      font-size: 12px;
      line-height: 1.55;
    }

    .code-card {
      font-family: var(--font-mono);
    }

    pre {
      margin: 4px 0 0;
      font-family: var(--font-mono);
      font-size: 11px;
      white-space: pre-wrap;
      word-wrap: break-word;
      max-height: 260px;
      overflow: auto;
      scrollbar-width: thin;
      scrollbar-color: #4b5563 transparent;
    }

    pre::-webkit-scrollbar {
      width: 5px;
    }
    pre::-webkit-scrollbar-thumb {
      background: #4b5563;
      border-radius: 999px;
    }

    .photo-wrapper {
      position: relative;
      border-radius: 14px;
      overflow: hidden;
      border: 1px solid rgba(75, 85, 99, 0.9);
      min-height: 150px;
      background: radial-gradient(circle at top, rgba(15,23,42,0.95), #020617);
    }

    .photo-wrapper img {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      opacity: 0.9;
    }

    .photo-overlay {
      position: relative;
      padding: 8px 8px 6px;
      background: linear-gradient(to top, rgba(2,6,23,0.96), transparent 70%);
      font-size: 11px;
      color: #e5e7eb;
      display: flex;
      justify-content: space-between;
      align-items: flex-end;
      gap: 6px;
      margin-top: auto;
    }

    .photo-caption-sub {
      color: var(--muted);
      font-size: 10px;
    }

    .photo-tag {
      font-size: 10px;
      padding: 3px 7px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.9);
      background: rgba(15,23,42,0.96);
      color: var(--muted);
      white-space: nowrap;
    }

    .hidden {
      display: none;
    }

    footer {
      max-width: 1180px;
      margin: 0 auto;
      padding: 6px 16px 18px;
      border-top: 1px solid var(--border-subtle);
      font-size: 11px;
      color: var(--muted);
      display: flex;
      justify-content: space-between;
      gap: 8px;
    }

    footer span.highlight {
      color: #e5e7eb;
    }

    @media (max-width: 900px) {
      main {
        grid-template-columns: minmax(0,1fr);
      }
      .sidebar {
        order: -1;
      }
    }

    @media (max-width: 640px) {
      .content-grid {
        grid-template-columns: minmax(0, 1fr);
      }
      .nav-links {
        display: none;
      }
    }
  </style>
</head>
<body>
<div class="app">
  <header>
    <div class="nav">
      <div class="nav-left">
        <div class="logo-circle">
          <div class="logo-inner">YN</div>
        </div>
        <div class="nav-title">
          <span>Algorithm Notebook</span>
          <span>Your Name</span>
        </div>
      </div>
      <div class="nav-links">
        <a href="https://ketan18-ux.github.io/CityProject.github.io/">
        <button class="nav-pill" id="glowToggle">
          <span class="icon">üè†</span>
          <span>Home</span>
        </button>
        </a>
      </div>
    </div>
  </header>

  <main>
    <!-- SIDEBAR -->
    <aside class="sidebar">
      <div class="sidebar-header">
        <strong>10 Problems</strong><br />
        Click a problem to open its dedicated page.
      </div>
      <ul class="problem-list" id="problemList">
        <!-- Filled by JS -->
      </ul>
      <div class="sidebar-footer">
        Tip: Each problem page shows<br />
        <strong>Problem ¬∑ Solution ¬∑ SDG ¬∑ Photo ¬∑ Code</strong>.
      </div>
    </aside>

    <!-- MAIN PROBLEM VIEW -->
    <section class="problem-view" id="problemView">
      <!-- Filled by JS -->
    </section>
  </main>

  <footer>
    <span>¬© <span class="highlight">Your Name</span> ¬∑ Algorithms Portfolio</span>
    <span>Hosted on <span class="highlight">GitHub Pages</span>.</span>
  </footer>
</div>

<script>
  // ==== DATA: 10 PROBLEMS ====
  const problems = [
   {
      id: 1,
      number: 1,
      title: "Air Quality Prediction Network",
      categoryTag: "",
      shortTag: "Regression + DP Smoothing",
      time: "O(n)",
      space: "O(n)",
      algorithm: "Regression + DP Smoothing",
      sdgs: [
        
        "SDG 3 ‚Äì Good Health and Well-being",
        "SDG 13 ‚Äì Sustainable Cities and Communities"
      ],
      problemText:
        "Air pollution varies over time and is measured using multiple sensors such as PM2.5, NO‚ÇÇ, and CO. Raw sensor data is often noisy, making AQI prediction inaccurate. Therefore, a reliable method is required to predict AQI values accurately and reduce sudden fluctuations.",
      solutionText: "Linear Regression is used to predict AQI from historical multi-sensor data. To handle noise and sudden changes in predictions, Dynamic Programming‚Äìbased smoothing is applied. This produces stable and realistic AQI value.",
      code: `Regression + DP Smoothing

     #include <iostream>
#include <vector>
using namespace std;

/* --------------------------
   Linear Regression Model
--------------------------------*/
class LinearRegression {
    vector<double> weights;
    double bias;
    double lr;
    int epochs;

public:
    LinearRegression(int features, double lr=0.01, int epochs=1000) {
        weights.resize(features, 0.0);
        bias = 0.0;
        this->lr = lr;
        this->epochs = epochs;
    }

    void train(const vector<vector<double>>& X, const vector<double>& y) {
        int n = X.size();
        int m = weights.size();
  for (int e = 0; e < epochs; e++) {
            vector<double> dw(m, 0.0);
            double db = 0.0;

            for (int i = 0; i < n; i++) {
                double y_pred = bias;
                for (int j = 0; j < m; j++)
                    y_pred += weights[j] * X[i][j];

                double error = y_pred - y[i];

                for (int j = 0; j < m; j++)
                    dw[j] += error * X[i][j];
                db += error;
            }

            for (int j = 0; j < m; j++)
                weights[j] -= lr * dw[j] / n;
            bias -= lr * db / n;
        }
    }

    double predict(const vector<double>& x) {
        double result = bias;
        for (int i = 0; i < x.size(); i++)
            result += weights[i] * x[i];
        return result;
    }
};

/* --------------------------
   DP-based Smoothing
--------------------------------*/
vector<double> DPSmoothing(const vector<double>& preds, double alpha) {
    int n = preds.size();
    vector<double> smooth(n);

    smooth[0] = preds[0];
    for (int i = 1; i < n; i++)
        smooth[i] = (preds[i] + alpha * smooth[i - 1]) / (1 + alpha);

    return smooth;
}

/* --------------------------
   Main Function
--------------------------------*/
int main() {
vector<vector<double>> sensors = {
        {40, 20, 0.5},
        {45, 22, 0.6},
        {50, 24, 0.7},
        {55, 26, 0.8},
        {60, 28, 0.9}
    };

    vector<double> AQI = {90, 95, 100, 110, 120};

    LinearRegression model(3);
    model.train(sensors, AQI);

    vector<double> predictions;
    for (int i = 0; i < sensors.size(); i++)
        predictions.push_back(model.predict(sensors[i]));

    double alpha = 5.0;
    vector<double> smoothAQI = DPSmoothing(predictions, alpha);

    cout << "Predicted AQI (Raw):\n";
    for (double v : predictions)
        cout << v << " ";

    cout << "\n\nSmoothed AQI:\n";
    for (double v : smoothAQI)
        cout << v << " ";
    return 0;
}
`,
 
    },
    {
      id: 2,
      number: 2,
      title: "Smart Waste Segregation Automation",
      categoryTag: "",
      shortTag: "Binary Tree",
      time: "O(n log n)",
      space: "O(n)",
      algorithm: "Binary Tree",
      sdgs: [
        "SDG 11 ‚Äì sustainable cities and communities",
        "SDG 11 ‚Äì Responsible Consumption and Production",
        "SDG 13 ‚Äì Good Health¬†and¬†Well-Being"
      ],
      problemText:
        "Bins overflow and waste collection is inefficient, causing unhygienic conditions and wasted resources.",
      solutionText:
        "Use smart bins with sensors to detect fill levels. Data is sent to a server, and collection is optimized using routing algorithms to reduce overflow and save time.",
      
       
        code:`Binary Tree
       #include <iostream>
using namespace std;

// Binary Tree Node
struct Node {
    string question;
    string result;
    Node* left;
    Node* right;

    Node(string q = "", string r = "") {
        question = q;
        result = r;
        left = right = NULL;
    }
};

// Function to classify waste
void classify(Node* root) {
    if (root->left == NULL && root->right == NULL) {
        cout << "Waste Category: " << root->result << endl;
        return;
    }

    char choice;
    cout << root->question << " (y/n): ";
    cin >> choice;

    if (choice == 'y')
        classify(root->left);
    else
        classify(root->right);
}

int main() {
    // Building the decision tree
    Node* root = new Node("Is the waste biodegradable?");

    root->left = new Node("Is it food waste?");
    root->right = new Node("Is it plastic?");

    root->left->left = new Node("", "Organic Waste");
    root->left->right = new Node("", "Garden Waste");

    root->right->left = new Node("", "Recyclable Waste");
    root->right->right = new Node("", "Non-Recyclable Waste (Landfill)");

    cout << "Smart Waste Segregation System\n";
    classify(root);

    return 0;
}

`,
 
    },
    {
      id: "3",
      number: 3,
      title: "Smart Water Pipeline Leak Detection",
      categoryTag: "",
      shortTag: "DFS + Binary Tree ",
      time: "O(log n)",
      space: "O(1)",
      algorithm: "DFS + Binary Tree",
      sdgs: [
        "SDG 6 ‚Äì Clean Water & Sanitation Ensures safe water supply and efficient usage",
        "SDG 9 ‚Äì Industry, Innovation & Infrastructure Builds smart pipeline and distribution systems",
        "SDG 11 ‚Äì Sustainable Cities & Communities Supports sustainable water management"
      ],
      problemText:
        "Undetected water leaks in pipelines result in major water loss and infrastructure damage.",
      solutionText:
        "DFS is used to traverse the pipeline network to detect disconnected or faulty sections. Leak records are stored using a Binary Tree for organized monitoring.",
      
       code:`DFS + Binary Tree
      #include <iostream>
using namespace std;

struct Node {
    int id;
    Node *left, *right;
};

Node* newNode(int id) {
    Node* temp = new Node();
    temp->id = id;
    temp->left = temp->right = NULL;
    return temp;
}

Node* insert(Node* root, int id) {
    if(root == NULL)
        return newNode(id);
    if(id < root->id)
        root->left = insert(root->left, id);
    else
        root->right = insert(root->right, id);
    return root;
}

void inorder(Node* root) {
    if(root != NULL) {
        inorder(root->left);
        cout << root->id << " ";
        inorder(root->right);
    }
}

int main() {
    Node* root = NULL;
    root = insert(root, 20);
    root = insert(root, 10);
    root = insert(root, 30);
    root = insert(root, 25);

    cout << "Leak affected pipeline sections:\n";
    inorder(root);
    return 0;
}

`,
 
    },
    {
      id: "4",
      number: 4,
      title: "Emergency Shelter Connectivity Planning",
      categoryTag: "",
      shortTag: "Floyd‚ÄìWarshall",
      time: "O((V+E) log V) using a heap",
      space: "O(V)",
      algorithm: "Floyd‚ÄìWarshall",
      sdgs: [
        "SDG 11 ‚Äì Sustainable Cities and Communities",
        "SDG 3 ‚Äì Good health and Wealth Being",
        "SDG 13 - Climate Action Reduces dependence on fossil fuels"
      ],
      problemText:
        "Poor connectivity between emergency shelters delays evacuation during natural disasters.",
      solutionText:
        "Floyd‚ÄìWarshall algorithm computes the shortest distance between all pairs of shelters, ensuring faster rescue and evacuation planning.",
     code:`Floyd‚ÄìWarshall
     #include <iostream>
using namespace std;

#define INF 9999
#define V 4

void floydWarshall(int graph[V][V]) {
    int dist[V][V];

    for(int i = 0; i < V; i++)
        for(int j = 0; j < V; j++)
            dist[i][j] = graph[i][j];

    for(int k = 0; k < V; k++) {
        for(int i = 0; i < V; i++) {
            for(int j = 0; j < V; j++) {
                if(dist[i][k] + dist[k][j] < dist[i][j])
                    dist[i][j] = dist[i][k] + dist[k][j];
            }
        }
    }

    cout << "Shortest distances between shelters:\n";
    for(int i = 0; i < V; i++) {
        for(int j = 0; j < V; j++)
            cout << dist[i][j] << " ";
        cout << endl;
    }
}

int main() {
    int graph[V][V] = {
        {0, 5, INF, 10},
        {5, 0, 3, INF},
        {INF, 3, 0, 1},
        {10, INF, 1, 0}
    };

    floydWarshall(graph);
    return 0;
}


`,
 
    },
    {
      id: 5,
      number: 5,
      title: "Food Processing & Packaging Unit",
      categoryTag: "",
      shortTag: "Insertion+AVL Tree",
      time: "O(n)",
      space: "O(1)",
      algorithm: "Insertion+AVL Tree",
      sdgs: [
        "SDG 2 ‚Äì Zero Hunger Reduces food wastage and improves food availability",
        "SDG 12 ‚Äì Responsible Consumption & Production Ensures efficient food management and processing",
        "SDG 3 ‚Äì Good Health & Well-being Ensures safe and fresh food handling"
      ],
      problemText:
        "Food items like milk, grains, and fruits have expiry dates. The factory must ensure that items with earlier expiry dates are processed and sold first. Also, the inventory needs to be managed efficiently.",
      solutionText:
        "Food items are sorted by freshness so that older items are not wasted. Inventory must also be tracked using a structure that supports quick searching for any product.",
     code:
       `Insertion
       void insertionSort(vector<int>& a) {
    for (int i = 1; i < a.size(); i++) {
        int key = a[i], j = i - 1;
        while (j >= 0 && a[j] > key)
            a[j-- + 1] = a[j];
        a[j + 1] = key;
    }
}
AVL Tree
struct Node {
    int v, h;
    Node *l, *r;
    Node(int x) : v(x), h(1), l(NULL), r(NULL) {}
};

int h(Node* n) { return n ? n->h : 0; }

Node* rotR(Node* y) {
    Node* x = y->l;
    y->l = x->r;
    x->r = y;
    y->h = max(h(y->l), h(y->r)) + 1;
    x->h = max(h(x->l), h(x->r)) + 1;
    return x;
}

Node* rotL(Node* x) {
    Node* y = x->r;
    x->r = y->l;
    y->l = x;
    x->h = max(h(x->l), h(x->r)) + 1;
    y->h = max(h(y->l), h(y->r)) + 1;
    return y;
}

Node* insertAVL(Node* n, int v) {
    if (!n) return new Node(v);

    if (v < n->v) n->l = insertAVL(n->l, v);
    else n->r = insertAVL(n->r, v);

    n->h = max(h(n->l), h(n->r)) + 1;

    int bal = h(n->l) - h(n->r);

    if (bal > 1 && v < n->l->v) return rotR(n);
    if (bal < -1 && v > n->r->v) return rotL(n);
    if (bal > 1 && v > n->l->v) {
        n->l = rotL(n->l);
        return rotR(n);
    }
    if (bal < -1 && v < n->r->v) {
        n->r = rotR(n->r);
        return rotL(n);
    }

    return n;
}
`,
 
    },
    {
      id: 6,
      number: 6,
      title: "Co-working Space / Startup Hub",
      categoryTag: "",
      shortTag: "AVL Tree+Merge Sort",
      time: "O(V + E)",
      space: "O(V)",
      algorithm: "AVL Tree+Merge Sort",
      sdgs: [
        "SDG 8 ‚Äì Decent Work & Economic Growth Encourages entrepreneurship and job creation",
        "SDG 9 ‚Äì Industry, Innovation & Infrastructure Creates an innovative and collaborative work environment",
        "SDG 11 ‚Äì Sustainable Cities & Communities Efficient use of shared space and resources"
      ],
      problemText:
        "A co-working space has many seats, rooms, and time slots available for booking. Managing these bookings manually leads to confusion and double-booking.",
      solutionText:
        "A balanced tree can store all bookings in sorted order so that conflicts can be detected. Sorting time slots is also useful when generating daily usage reports.",
     code:
       `AVLTree
       struct Node {
    int v, h;
    Node *l, *r;
    Node(int x) : v(x), h(1), l(NULL), r(NULL) {}
};

int h(Node* n) { return n ? n->h : 0; }

Node* rotR(Node* y) {
    Node* x = y->l;
    y->l = x->r;
    x->r = y;
    y->h = max(h(y->l), h(y->r)) + 1;
    x->h = max(h(x->l), h(x->r)) + 1;
    return x;
}

Node* rotL(Node* x) {
    Node* y = x->r;
    x->r = y->l;
    y->l = x;
    x->h = max(h(x->l), h(x->r)) + 1;
    y->h = max(h(y->l), h(y->r)) + 1;
    return y;
}

Node* insertAVL(Node* n, int v) {
    if (!n) return new Node(v);

    if (v < n->v) n->l = insertAVL(n->l, v);
    else n->r = insertAVL(n->r, v);

    n->h = max(h(n->l), h(n->r)) + 1;

    int bal = h(n->l) - h(n->r);

    if (bal > 1 && v < n->l->v) return rotR(n);
    if (bal < -1 && v > n->r->v) return rotL(n);
    if (bal > 1 && v > n->l->v) {
        n->l = rotL(n->l);
        return rotR(n);
    }
    if (bal < -1 && v < n->r->v) {
        n->r = rotR(n->r);
        return rotL(n);
    }

    return n;
}
Merge Sort
void mergeSort(vector<int>& a, int l, int r) {
    if (l >= r) return;

    int m = (l + r) / 2;
    mergeSort(a, l, m);
    mergeSort(a, m + 1, r);

    vector<int> t;
    int i = l, j = m + 1;

    while (i <= m && j <= r)
        t.push_back(a[i] < a[j] ? a[i++] : a[j++]);

    while (i <= m) t.push_back(a[i++]);
    while (j <= r) t.push_back(a[j++]);

    for (int k = 0; k < t.size(); k++)
        a[l + k] = t[k];
}
`,
 
    },
    {
      id: 7,
      number: 7,
      title: "Construction & Infrastructure Services",
      categoryTag: "",
      shortTag: "Prim‚Äôs+Dijkstra‚Äôs",
      time: "O(V + E)",
      space: "O(V)",
      algorithm: "Prim‚Äôs+Dijkstra‚Äôs",
      sdgs: [
        "SDG 9 ‚Äì Industry, Innovation & Infrastructure Builds robust and efficient infrastructure",
        "SDG 11 ‚Äì Sustainable Cities & Communities Supports planned, low-cost development",
        "SDG 13 ‚Äì Climate Action Reduces emissions through optimized routes and networks"
      ],
      problemText:
        "Construction companies need to design roads, drainage networks, and pipelines at minimum cost. They also need to transport materials from one project site to another efficiently.",
      solutionText:
        "We can build the city‚Äôs infrastructure cost-effectively using an MST approach. For movement of vehicles and materials, shortest routes must be calculated.",
      
      code:`Prim‚Äôs
      vector<int> prim(vector<vector<int>>& g) {
    int n = g.size();
    vector<int> key(n, INT_MAX), used(n, 0), parent(n, -1);
    key[0] = 0;

    for (int i = 0; i < n - 1; i++) {
        int u = -1;
        for (int v = 0; v < n; v++)
            if (!used[v] && (u == -1 || key[v] < key[u]))
                u = v;

        used[u] = 1;

        for (int v = 0; v < n; v++)
            if (g[u][v] && !used[v] && g[u][v] < key[v]) {
                key[v] = g[u][v];
                parent[v] = u;
            }
    }
    return parent;  
}
Dijkstra‚Äôs
vector<int> dijkstra(vector<vector<int>>& g, int src) {
    int n = g.size();
    vector<int> dist(n, INT_MAX), vis(n, 0);
    dist[src] = 0;

    for (int i = 0; i < n; i++) {
        int u = -1;
        for (int j = 0; j < n; j++)
            if (!vis[j] && (u == -1 || dist[j] < dist[u]))
                u = j;

        vis[u] = 1;

        for (int v = 0; v < n; v++)
            if (g[u][v] && dist[u] + g[u][v] < dist[v])
                dist[v] = dist[u] + g[u][v];
    }

    return dist;  
}
`,
 
    },
    {
      id: "8",
      number: 8,
      title: "Emergency & Security Services Company",
      categoryTag: "",
      shortTag: "Dijkstra‚Äôs+Warshall‚Äôs",
      time: "O(n log n)",
      space: "O(n)",
      algorithm: "Dijkstra‚Äôs+Warshall‚Äôs",
      sdgs: [
        "SDG 3 ‚Äì Good Health & Well-being Provides fast emergency response and saves lives",
        "SDG 11 ‚Äì Sustainable Cities & Communities Improves safety and disaster management",
        "SDG 16 ‚Äì Peace, Justice & Strong Institutions Enhances law enforcement and public security"
      ],
      problemText:
        "Ambulances, fire trucks, and police vehicles must reach the destination immediately. The city also has different security zones that need to be monitored to know which areas are connected or isolated.",
      solutionText:
        "Shortest routes save lives during emergencies. Connectivity analysis helps identify vulnerable or unmonitored areas.",
     
      code:`Dijkstra‚Äôs
      vector<int> dijkstra(vector<vector<int>>& g, int src) {
    int n = g.size();
    vector<int> dist(n, INT_MAX), vis(n, 0);
    dist[src] = 0;

    for (int i = 0; i < n; i++) {
        int u = -1;
        for (int j = 0; j < n; j++)
            if (!vis[j] && (u == -1 || dist[j] < dist[u]))
                u = j;

        vis[u] = 1;

        for (int v = 0; v < n; v++)
            if (g[u][v] && dist[u] + g[u][v] < dist[v])
                dist[v] = dist[u] + g[u][v];
    }

    return dist;  
}
Warshall‚Äôs
void warshall(vector<vector<int>>& r) {
    int n = r.size();
    for (int k = 0; k < n; k++)
        for (int i = 0; i < n; i++)
            for (int j = 0; j < n; j++)
                r[i][j] = r[i][j] || (r[i][k] && r[k][j]);
}
`,
 
    },
    {
      id: 9,
      number: 9,
      title: "Online Delivery & Logistics Hub",
      categoryTag: "",
      shortTag: "Dijkstra‚Äôs+Merge",
      time: "O(n¬∑W)",
      space: "O(W)",
      algorithm: "Dijkstra‚Äôs+Merge",
      sdgs: [
        "SDG 8 ‚Äì Decent Work & Economic Growth Supports delivery businesses and job opportunities",
        "SDG 9 ‚Äì Industry, Innovation & Infrastructure Uses technology for efficient logistics",
        "SDG 12 ‚Äì Responsible Consumption & Production Optimizes delivery, reduces fuel waste"
      ],
      problemText:
        "Packages must be delivered quickly and in proper order of priority. Delivery riders must follow the shortest routes to avoid delays and fuel waste.",
      solutionText:
        "Packages are sorted based on delivery time, and optimal routes are calculated to speed up delivery.", 
      code:` Dijkstra‚Äôs
      vector<int> dijkstra(vector<vector<int>>& g, int src) {
    int n = g.size();
    vector<int> dist(n, INT_MAX), vis(n, 0);
    dist[src] = 0;

    for (int i = 0; i < n; i++) {
        int u = -1;
        for (int j = 0; j < n; j++)
            if (!vis[j] && (u == -1 || dist[j] < dist[u]))
                u = j;

        vis[u] = 1;

        for (int v = 0; v < n; v++)
            if (g[u][v] && dist[u] + g[u][v] < dist[v])
                dist[v] = dist[u] + g[u][v];
    }

    return dist;  
}
Merge
void mergeSort(vector<int>& a, int l, int r) {
    if (l >= r) return;

    int m = (l + r) / 2;
    mergeSort(a, l, m);
    mergeSort(a, m + 1, r);

    vector<int> t;
    int i = l, j = m + 1;

    while (i <= m && j <= r)
        t.push_back(a[i] < a[j] ? a[i++] : a[j++]);

    while (i <= m) t.push_back(a[i++]);
    while (j <= r) t.push_back(a[j++]);

    for (int k = 0; k < t.size(); k++)
        a[l + k] = t[k];
}
`,
 
    },
    {
      id: 10,
      number: 10,
      title: "Sports & Recreation Center",
      categoryTag: "",
      shortTag: "Merge Sort+Binary Tree",
      time: "‚âàO(Œ±(n)) per op",
      space: "O(n)",
      algorithm: "Merge Sort+Binary Tree",
      sdgs: [
        "SDG 3 ‚Äì Good Health & Well-being Promotes physical activity and healthy lifestyles",
        "SDG 4 ‚Äì Quality Education Provides training, coaching, and skill development",
        "SDG 11 ‚Äì Sustainable Cities & Communities Encourages community engagement through sports"
      ],
      problemText:
        "Sports centers maintain player details, match scores, coaching information, and event schedules. Players must be ranked and sorted properly.",
      solutionText:
        "Players‚Äô scores can be sorted to generate rankings. Member and event records can be stored in a tree for fast retrieval and updates.",
        code:` MergeSort
        void mergeSort(vector<int>& a, int l, int r) {
    if (l >= r) return;

    int m = (l + r) / 2;
    mergeSort(a, l, m);
    mergeSort(a, m + 1, r);

    vector<int> t;
    int i = l, j = m + 1;

    while (i <= m && j <= r)
        t.push_back(a[i] < a[j] ? a[i++] : a[j++]);

    while (i <= m) t.push_back(a[i++]);
    while (j <= r) t.push_back(a[j++]);

    for (int k = 0; k < t.size(); k++)
        a[l + k] = t[k];
}
Binary Tre
struct Node {
    int data;
    Node* left;
    Node* right;
    Node(int x) : data(x), left(NULL), right(NULL) {}
};

Node* insert(Node* root, int x) {
    if (!root) return new Node(x);
    if (x < root->data) root->left = insert(root->left, x);
    else root->right = insert(root->right, x);
    return root;
}

bool search(Node* root, int x) {
    if (!root) return false;
    if (root->data == x) return true;
    return x < root->data ? search(root->left, x) : search(root->right, x);
}
`,
 
    }
  ];

  // ==== RENDER SIDEBAR ====
  const problemListEl = document.getElementById("problemList");
  function renderSidebar(activeId) {
    problemListEl.innerHTML = "";
    problems.forEach(p => {
      const li = document.createElement("li");
      li.className = "problem-item" + (p.id === activeId ? " active" : "");
      li.dataset.id = p.id;

      const left = document.createElement("div");
      left.className = "problem-name";
      left.textContent = `#${p.number} ¬∑ ${p.title}`;

      const right = document.createElement("div");
      right.className = "problem-tag";
      right.textContent = p.shortTag;

      li.appendChild(left);
      li.appendChild(right);
      li.addEventListener("click", () => {
        setActiveProblem(p.id, true);
      });

      problemListEl.appendChild(li);
    });
  }

  // ==== RENDER MAIN PROBLEM PAGE ====
  const viewEl = document.getElementById("problemView");

  function renderProblem(problem) {
    const sdgHtml = problem.sdgs
      .map(s => `<span class="sdg-chip">${s}</span>`)
      .join("");

    viewEl.innerHTML = `
      <div class="crumbs">
        Algorithms / <span>Problem #${problem.number}</span>
      </div>

      <div class="problem-header-main">
        <div class="problem-title-block">
          <div class="problem-id-pill">
            <span>Problem #${problem.number}</span>
          </div>
          <h1>${problem.title}</h1>
          <div class="problem-meta-row">
            <span class="algo-chip">${problem.algorithm}</span>
            
            <span><strong>Time:</strong> ${problem.time}</span>
            <span><strong>Space:</strong> ${problem.space}</span>
          </div>
          <div class="sdg-chips">
            ${sdgHtml}
          </div>
        </div>

        
      </div>

      <div class="content-grid">
        <div class="card">
          <div class="card-header">
            <span>Problem &amp; Solution</span>
            <span class="label">Explanation</span>
          </div>
          <div class="card-body">
            <strong>Problem:</strong><br />
            <span>${problem.problemText}</span>
            <br /><br />
            <strong>High-level Solution:</strong><br />
            <span>${problem.solutionText}</span>
          </div>
        </div>

        

      <div class="card code-card">
        <div class="card-header">
          <span>Reference Code</span>
          <span class="label">JavaScript</span>
        </div>
        <div class="card-body">
          <pre id="codeBlock"><code>${problem.code}</code></pre>
        </div>
      </div>
      

      
    `;

    // Hook up copy & raw buttons
    const copyBtn = document.getElementById("copyCodeBtn");
    const rawBtn = document.getElementById("openRawBtn");
    const codeBlock = document.getElementById("codeBlock");

    if (copyBtn && codeBlock) {
      copyBtn.addEventListener("click", () => {
        const text = codeBlock.innerText;
        navigator.clipboard?.writeText(text).then(
          () => { copyBtn.textContent = "‚úÖ Copied"; },
          () => { copyBtn.textContent = "‚ö†Ô∏è Failed"; }
        );
        setTimeout(() => (copyBtn.innerHTML = '<span>üìã</span> Copy Code'), 1200);
      });
    }

    if (rawBtn && codeBlock) {
      rawBtn.addEventListener("click", () => {
        const w = window.open("", "_blank");
        if (!w) return;
        w.document.write("<pre>" + codeBlock.innerText.replace(/</g, "&lt;") + "</pre>");
        w.document.close();
      });
    }
  }

  // ==== ROUTING (HASH-BASED) ====
  function setActiveProblem(id, updateHash) {
    const problem = problems.find(p => p.id === id) || problems[0];
    renderSidebar(problem.id);
    renderProblem(problem);
    if (updateHash) {
      window.location.hash = "problem/" + problem.id;
    }
  }

  function getProblemIdFromHash() {
    const hash = window.location.hash || "";
    const match = hash.match(/problem\/([a-z0-9\-]+)/i);
    return match ? match[1] : null;
  }

  window.addEventListener("hashchange", () => {
    const id = getProblemIdFromHash();
    if (id) setActiveProblem(id, false);
  });

  // ==== GLOW TOGGLE ====
  const glowToggle = document.getElementById("glowToggle");
  let glowOn = true;
  glowToggle?.addEventListener("click", () => {
    document.body.style.filter = glowOn ? "saturate(0.9) brightness(0.95)" : "none";
    glowOn = !glowOn;
  });

  // ==== INITIALISE ====
  (function init() {
    const initialId = getProblemIdFromHash() || problems[0].id;
    setActiveProblem(initialId, true);
  })();
</script>
</body>
</html>
