<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Ketan Shinde | Smart City Map ‚Äì DAA Portfolio</title>

  <!-- Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@500;600;700&family=Poppins:wght@300;400;500;600&display=swap" rel="stylesheet">

  <style>
    :root {
      --bg-main: #020617;
      --panel-bg: #020617;
      --panel-border: rgba(148, 163, 184, 0.45);
      --accent: #22c1c3;
      --accent-blue: #38bdf8;
      --text-main: #e5e7eb;
      --text-muted: #9ca3af;
      --radius-lg: 18px;
      --radius-md: 14px;
      --shadow-strong: 0 20px 50px rgba(0, 0, 0, 0.9);
      --shadow-soft: 0 10px 30px rgba(15, 23, 42, 0.85);
      --transition-fast: 0.25s ease;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      min-height: 100vh;
      background: radial-gradient(circle at top, #0f172a 0, #020617 50%, #000 100%);
      color: var(--text-main);
      font-family: "Poppins", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      overflow-x: hidden;
    }

    /* TOP BAR */
    .topbar {
      position: sticky;
      top: 0;
      z-index: 20;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 18px;
      background: rgba(2, 6, 23, 0.9);
      border-bottom: 1px solid rgba(148, 163, 184, 0.3);
      backdrop-filter: blur(14px);
    }

    .topbar-title {
      font-family: "Montserrat", sans-serif;
      font-size: 17px;
      font-weight: 600;
      letter-spacing: 0.05em;
    }

    .topbar-sub {
      font-size: 11px;
      color: var(--text-muted);
    }

    .topbar-left {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .topbar-actions {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 11px;
    }

    .chip {
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.6);
      color: var(--text-muted);
    }

    .btn-pill {
      border-radius: 999px;
      padding: 7px 14px;
      border: none;
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      text-decoration: none;
      background: linear-gradient(135deg, #22c1c3, #38bdf8);
      color: #020617;
      box-shadow: 0 8px 22px rgba(56, 189, 248, 0.45);
      transition: var(--transition-fast);
    }

    .btn-pill:hover {
      transform: translateY(-1px) scale(1.02);
      box-shadow: 0 12px 30px rgba(56, 189, 248, 0.7);
    }

    /* LAYOUT */
    .layout {
      max-width: 1350px;
      margin: 18px auto 30px;
      padding: 0 18px 26px;
      position: relative;
    }

    .hero-strip {
      margin-bottom: 14px;
      font-size: 12px;
      color: var(--text-muted);
    }

    .hero-strip span {
      color: #a5b4fc;
    }

    .city-shell {
      position: relative;
      border-radius: 24px;
      background: radial-gradient(circle at 0% 0%, rgba(56, 189, 248, 0.2) 0, transparent 50%),
                  radial-gradient(circle at 100% 0%, rgba(34, 197, 94, 0.2) 0, transparent 55%),
                  #020617;
      box-shadow: var(--shadow-strong);
      overflow: hidden;
      min-height: 560px;
      border: 1px solid rgba(148, 163, 184, 0.45);
    }

    .city-map {
      position: relative;
      padding: 22px 24px 26px;
      overflow: hidden;
      min-height: 560px;
    }

    .city-map::before,
    .city-map::after {
      content: "";
      position: absolute;
      inset: -80%;
      opacity: 0.18;
      pointer-events: none;
    }

    .city-map::before {
      background-image:
        linear-gradient(90deg, rgba(148, 163, 184, 0.28) 1px, transparent 1px),
        linear-gradient(0deg, rgba(148, 163, 184, 0.28) 1px, transparent 1px);
      background-size: 80px 80px;
      animation: panGrid 24s linear infinite;
    }

    .city-map::after {
      background:
        radial-gradient(circle at 15% 25%, rgba(56, 189, 248, 0.4) 0, transparent 45%),
        radial-gradient(circle at 75% 35%, rgba(34, 197, 94, 0.5) 0, transparent 40%),
        radial-gradient(circle at 45% 80%, rgba(96, 165, 250, 0.45) 0, transparent 40%);
      animation: driftGlow 22s linear infinite alternate;
    }

    @keyframes panGrid {
      from { transform: translate3d(0, 0, 0); }
      to   { transform: translate3d(80px, 80px, 0); }
    }

    @keyframes driftGlow {
      from { transform: translate3d(-4%, -4%, 0) scale(1.02); }
      to   { transform: translate3d(4%, 4%, 0) scale(1.04); }
    }

    .city-header {
      position: relative;
      z-index: 1;
      margin-bottom: 12px;
      display: flex;
      justify-content: space-between;
      align-items: flex-end;
      gap: 10px;
    }

    .city-title {
      font-family: "Montserrat", sans-serif;
      font-size: 18px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }

    .city-sub {
      font-size: 11px;
      color: var(--text-muted);
    }

    .legend {
      font-size: 11px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .legend span {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .legend-dot {
      width: 10px;
      height: 10px;
      border-radius: 999px;
      background: radial-gradient(circle at 30% 0, #22c1c3 0, #0f172a 60%);
      box-shadow: 0 0 8px rgba(56, 189, 248, 0.8);
    }

    .city-grid {
      position: relative;
      z-index: 1;
      margin-top: 8px;
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr)); /* ‚òÖ CHANGED: 2 boxes per row */
      grid-auto-rows: minmax(110px, 1fr);
      gap: 18px;
      padding: 6px 2px 8px;
    }

    .map-node {
      border-radius: var(--radius-md);
      border: 1px solid rgba(148, 163, 184, 0.55);
      background: radial-gradient(circle at 30% 0, rgba(15, 23, 42, 0.9) 0, #020617 55%);
      color: var(--text-main);
      padding: 12px 14px;
      box-shadow: var(--shadow-soft);
      text-align: left;
      cursor: pointer;
      position: relative;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      overflow: hidden;
      transition: transform var(--transition-fast), box-shadow var(--transition-fast), border-color var(--transition-fast), background var(--transition-fast);
    }

    .map-node::after {
      content: "";
      position: absolute;
      inset: -20%;
      opacity: 0;
      background: radial-gradient(circle at 10% 0, rgba(56, 189, 248, 0.6) 0, transparent 40%);
      pointer-events: none;
      transition: opacity 0.25s ease;
    }

    .map-node:hover {
      transform: translateY(-3px) scale(1.02);
      border-color: rgba(56, 189, 248, 0.9);
      box-shadow: 0 16px 35px rgba(15, 23, 42, 0.95);
      background: radial-gradient(circle at 0% 0%, rgba(34, 193, 195, 0.22) 0, #020617 60%);
    }

    .map-node:hover::after {
      opacity: 0.7;
    }

    .map-node-icon {
      font-size: 24px;
      margin-bottom: 6px;
    }

    .map-node-title {
      font-family: "Montserrat", sans-serif;
      font-size: 13px;
      line-height: 1.3;
    }

    .map-node-meta {
      margin-top: 6px;
      font-size: 10px;
      color: var(--text-muted);
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
    }

    .node-badge {
      padding: 2px 6px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.7);
      background: rgba(15, 23, 42, 0.8);
    }

    .node-id {
      font-size: 11px;
      color: #a5b4fc;
      font-weight: 500;
    }

    .map-node.docs-node {
      border-style: dashed;
      border-color: rgba(249, 115, 22, 0.8);
      background: radial-gradient(circle at 0 0, rgba(249, 115, 22, 0.22) 0, #020617 60%);
    }

    .map-node.docs-node:hover {
      border-color: rgba(251, 191, 36, 0.95);
    }

    /* FULLSCREEN OVERLAY */
    .overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.96);
      display: none;
      z-index: 40;
      justify-content: center;
      align-items: stretch;
      padding: 46px 14px 18px;
      box-sizing: border-box;
    }

    .overlay.open {
      display: flex;
    }

    .panel-shell {
      display: none;
      width: 100%;
      max-width: 950px;
      margin: 0 auto;
      background:
        radial-gradient(circle at 0 0, rgba(56, 189, 248, 0.25) 0, transparent 55%),
        radial-gradient(circle at 100% 100%, rgba(34, 197, 94, 0.25) 0, transparent 55%),
        var(--panel-bg);
      border-radius: 20px;
      border: 1px solid var(--panel-border);
      box-shadow: var(--shadow-strong);
      padding: 14px 14px 14px;
      flex-direction: column;
    }

    .panel-shell.open {
      display: flex;
    }

    .panel-header {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 10px;
      padding-bottom: 8px;
      border-bottom: 1px solid rgba(31, 41, 55, 0.9);
    }

    .panel-title-group {
      display: flex;
      flex-direction: column;
      gap: 3px;
    }

    .panel-title {
      font-family: "Montserrat", sans-serif;
      font-size: 15px;
    }

    .panel-chip-row {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      font-size: 10px;
    }

    .panel-chip {
      padding: 3px 7px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.8);
      background: rgba(15, 23, 42, 0.9);
      color: var(--text-muted);
    }

    .panel-chip.algo {
      border-color: rgba(56, 189, 248, 0.9);
      color: #bae6fd;
    }

    .panel-controls {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }

    .back-btn {
      border-radius: 999px;
      border: 1px solid transparent;
      padding: 4px 10px;
      cursor: pointer;
      font-size: 12px;
      display: inline-flex;
      align-items: center;
      gap: 4px;
      transition: var(--transition-fast);
      background: linear-gradient(135deg, #22c1c3, #38bdf8);
      color: #020617;
      box-shadow: 0 6px 18px rgba(56, 189, 248, 0.6);
    }

    .back-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 9px 26px rgba(56, 189, 248, 0.8);
    }

    .panel-scroll {
      margin-top: 10px;
      padding-right: 4px;
      overflow-y: auto;
      flex: 1;
      font-size: 13px;
      max-height: calc(100vh - 120px);
    }

    .panel-block {
      margin-bottom: 10px;
      padding: 8px 9px;
      border-radius: 12px;
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid rgba(55, 65, 81, 0.95);
    }

    .panel-block h3 {
      font-family: "Montserrat", sans-serif;
      font-size: 12px;
      margin-bottom: 4px;
    }

    .panel-block p {
      font-size: 13px;
      line-height: 1.5;
      color: #e5e7eb;
    }

    .panel-block ul {
      margin-left: 16px;
      margin-top: 4px;
      font-size: 13px;
      color: #e5e7eb;
    }

    .panel-block li {
      margin-bottom: 3px;
    }

    .io-label {
      font-size: 11px;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.08em;
      margin-bottom: 2px;
    }

    .algo-row {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 4px;
    }

    .algo-pill {
      font-size: 11px;
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid rgba(56, 189, 248, 0.9);
      background: rgba(15, 23, 42, 0.95);
      color: #bfdbfe;
    }

    .complexity {
      font-size: 12px;
      color: #cbd5f5;
    }

    .impact {
      font-size: 12px;
      color: #a5b4fc;
    }

    .figure-placeholder {
      margin-top: 4px;
      border-radius: 12px;
      border: 1px dashed rgba(148, 163, 184, 0.8);
      padding: 8px 10px;
      font-size: 11px;
      color: var(--text-muted);
      background:
        radial-gradient(circle at 20% 0, rgba(56, 189, 248, 0.4) 0, transparent 45%),
        #020617;
    }

    .doc-inline-title {
      font-weight: 600;
      margin-top: 4px;
    }

    /* CODE SECTION */
    .code-section {
      margin-top: 6px;
    }

    .code-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 4px;
    }

    .code-lang {
      font-size: 11px;
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid rgba(248, 250, 252, 0.2);
      background: rgba(15, 23, 42, 0.9);
      color: #facc15;
      font-family: "Montserrat", sans-serif;
    }

    .code-actions {
      display: flex;
      gap: 6px;
    }

    .code-toggle-btn,
    .code-copy-btn {
      font-size: 11px;
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.7);
      background: rgba(15, 23, 42, 0.9);
      color: var(--text-main);
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 4px;
      transition: var(--transition-fast);
    }

    .code-toggle-btn:hover,
    .code-copy-btn:hover {
      background: rgba(15, 23, 42, 1);
      transform: translateY(-1px);
    }

    .code-box {
      margin-top: 6px;
      border-radius: 10px;
      border: 1px solid rgba(55, 65, 81, 0.9);
      background: #0b1120;
      padding: 8px 10px;
      max-height: 260px;
      overflow: auto;
      font-size: 12px;
      display: none; /* hidden by default */
    }

    .code-box pre {
      margin: 0;
      font-family: "Fira Code", "JetBrains Mono", "Consolas", monospace;
      white-space: pre;
      color: #e5e7eb;
    }

    /* Monokai-like colors via simple span classes (optional) */
    .kw { color: #a855f7; }    /* keyword */
    .fn { color: #22c55e; }    /* function */
    .cm { color: #6b7280; }    /* comment */
    .ty { color: #38bdf8; }    /* type */
    .num { color: #f97316; }   /* number */

    /* RESPONSIVE */
    @media (max-width: 960px) {
      .panel-shell {
        max-width: 780px;
      }
    }

    @media (max-width: 820px) {
      .overlay {
        padding-top: 60px;
      }
      .panel-shell {
        max-width: 100%;
      }
    }

    @media (max-width: 540px) {
      .topbar {
        flex-direction: column;
        align-items: flex-start;
        gap: 6px;
      }
      .topbar-actions {
        align-self: flex-end;
      }
      .city-shell {
        border-radius: 18px;
      }
      .city-grid {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
      .panel-header {
        flex-direction: column;
      }
      .panel-controls {
        align-self: flex-end;
      }
    }
  </style>
</head>
<body>

  <!-- TOPBAR -->
  <header class="topbar">
    <div class="topbar-left">
      <div class="topbar-title">SMART CITY ‚Ä¢ INFRASTRUCTURE & ROUTING</div>
      <div class="topbar-sub">DAA Portfolio ‚Äì Infrastructure & Network Optimization Bucket ¬∑ Student: Ketan Shinde</div>
    </div>
    <div class="topbar-actions">
      <span class="chip">2024 ¬∑ Design & Analysis of Algorithms</span>
      <a href="index.html" class="btn-pill">‚¨Ö Back to Home</a>
    </div>
  </header>

  <main class="layout">
    <div class="hero-strip">
      View your city as an <span>algorithmic map</span>: click any glowing zone to open its case study.
    </div>

    <!-- CITY MAP SHELL -->
    <section class="city-shell">
      <div class="city-map">
        <div class="city-header">
          <div>
            <div class="city-title">CITY NETWORK OVERVIEW</div>
            <div class="city-sub">Each glowing zone represents one DAA case study from the Infrastructure &amp; Network Optimization bucket.</div>
          </div>
          <div class="legend">
            <span><span class="legend-dot"></span> Active algorithm zone</span>
            <span>Click to open details</span>
          </div>
        </div>

        <div class="city-grid">
          <!-- 1 -->
          <button class="map-node" data-target="p1">
            <div class="map-node-icon">üõ£Ô∏è</div>
            <div class="map-node-title">1. Road Network Construction</div>
            <div class="map-node-meta">
              <span class="node-id">MST</span>
              <span class="node-badge">Transport</span>
            </div>
          </button>

          <!-- 2 -->
          <button class="map-node" data-target="p2">
            <div class="map-node-icon">üß≠</div>
            <div class="map-node-title">2. Shortest Travel-Time Routing</div>
            <div class="map-node-meta">
              <span class="node-id">Dijkstra</span>
              <span class="node-badge">Commute</span>
            </div>
          </button>

          <!-- 3 -->
          <button class="map-node" data-target="p3">
            <div class="map-node-icon">üö¶</div>
            <div class="map-node-title">3. Signal Timing Optimization</div>
            <div class="map-node-meta">
              <span class="node-id">Scheduling</span>
              <span class="node-badge">Junctions</span>
            </div>
          </button>

          <!-- 4 -->
          <button class="map-node" data-target="p4">
            <div class="map-node-icon">üöë</div>
            <div class="map-node-title">4. Emergency Route Planner</div>
            <div class="map-node-meta">
              <span class="node-id">A*</span>
              <span class="node-badge">Emergency</span>
            </div>
          </button>

          <!-- 5 -->
          <button class="map-node" data-target="p5">
            <div class="map-node-icon">üö∞</div>
            <div class="map-node-title">5. Water Pressure Optimization</div>
            <div class="map-node-meta">
              <span class="node-id">Max Flow</span>
              <span class="node-badge">Water</span>
            </div>
          </button>

          <!-- 6 -->
          <button class="map-node" data-target="p6">
            <div class="map-node-icon">‚ö°</div>
            <div class="map-node-title">6. Power Grid Load Minimization</div>
            <div class="map-node-meta">
              <span class="node-id">MST</span>
              <span class="node-badge">Electricity</span>
            </div>
          </button>

          <!-- 7 -->
          <button class="map-node" data-target="p7">
            <div class="map-node-icon">üöÆ</div>
            <div class="map-node-title">7. Garbage Truck Routing</div>
            <div class="map-node-meta">
              <span class="node-id">TSP</span>
              <span class="node-badge">Waste</span>
            </div>
          </button>

          <!-- 8 -->
          <button class="map-node" data-target="p8">
            <div class="map-node-icon">üöå</div>
            <div class="map-node-title">8. Bus Timetable Generator</div>
            <div class="map-node-meta">
              <span class="node-id">Interval</span>
              <span class="node-badge">Public Transport</span>
            </div>
          </button>

          <!-- 9 -->
          <button class="map-node" data-target="p9">
            <div class="map-node-icon">üåâ</div>
            <div class="map-node-title">9. Bridge Priority Model</div>
            <div class="map-node-meta">
              <span class="node-id">Min-Cut</span>
              <span class="node-badge">Bridges</span>
            </div>
          </button>

          <!-- 10 -->
          <button class="map-node" data-target="p10">
            <div class="map-node-icon">üåßÔ∏è</div>
            <div class="map-node-title">10. Flood Evacuation Simulation</div>
            <div class="map-node-meta">
              <span class="node-id">BFS</span>
              <span class="node-badge">Disaster</span>
            </div>
          </button>

          <!-- DOCS -->
          <button class="map-node docs-node" data-target="doc">
            <div class="map-node-icon">üìë</div>
            <div class="map-node-title">Technical Docs &amp; SDG Mapping</div>
            <div class="map-node-meta">
              <span class="node-id">Metrics ¬∑ DS ¬∑ SDG</span>
              <span class="node-badge">Documentation</span>
            </div>
          </button>
        </div>
      </div>
    </section>
  </main>

  <!-- FULLSCREEN OVERLAY PANELS -->
  <div class="overlay" id="overlay">

    <!-- 1: ROAD NETWORK -->
    <section class="panel-shell" id="p1-panel">
      <div class="panel-header">
        <div class="panel-title-group">
          <div class="panel-title">1. Optimal Road Network Construction</div>
          <div class="panel-chip-row">
            <span class="panel-chip">Transport Infrastructure</span>
            <span class="panel-chip algo">Minimum Spanning Tree ¬∑ Kruskal / Prim</span>
          </div>
        </div>
        <div class="panel-controls">
          <button class="back-btn" type="button" data-close>‚¨Ö Back to Map</button>
        </div>
      </div>
      <div class="panel-scroll">
        <div class="panel-block">
          <h3>Problem</h3>
          <p>
            The city wants to connect all major junctions using new roads. Budget is limited, so we must
            connect all locations while keeping total construction cost minimal and avoiding redundant roads.
          </p>
        </div>
        <div class="panel-block">
          <h3>Practical Solution</h3>
          <p>
            Treat each junction as a vertex and each candidate road as a weighted edge storing construction cost.
            We run an MST algorithm that chooses a subset of edges connecting all vertices with minimum total cost
            and no cycles. This MST becomes the recommended road layout.
          </p>
        </div>
        <div class="panel-block">
          <div class="io-label">Input format (example)</div>
          <p>
            Fixed small example: 5‚Äì6 junctions and edge list with construction costs (hard-coded for demo and diagrams).
          </p>
          <div class="io-label" style="margin-top:4px;">Output</div>
          <p>
            Edges selected in the MST and the total minimum construction cost.
          </p>
        </div>
        <div class="panel-block">
          <h3>Algorithms &amp; Complexity</h3>
          <div class="algo-row">
            <span class="algo-pill">Kruskal's MST</span>
            <span class="algo-pill">Union‚ÄìFind (Disjoint Set)</span>
          </div>
          <p class="complexity" style="margin-top:6px;">
            Kruskal with sorting and Union‚ÄìFind runs in <strong>O(m log n)</strong>.
            Space complexity: <strong>O(n + m)</strong>.
          </p>
        </div>

        <!-- CODE SECTION: P1 -->
        <div class="panel-block code-section">
          <div class="code-header">
            <span class="code-lang">C++ Code</span>
            <div class="code-actions">
              <button class="code-toggle-btn" data-code-target="code-p1">‚ñ∂ View C++ Code</button>
              <button class="code-copy-btn" data-code-copy="code-p1">‚ßâ Copy</button>
            </div>
          </div>
          <div class="code-box" id="code-p1">
            <pre><code>
// Minimum Spanning Tree using Kruskal (Road Network)
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;

struct Edge {
    int u, v, w;
};

struct DSU {
    vector&lt;int&gt; parent, rnk;
    DSU(int n) {
        parent.resize(n);
        rnk.assign(n, 0);
        for (int i = 0; i &lt; n; ++i) parent[i] = i;
    }
    int find(int x) {
        if (parent[x] == x) return x;
        return parent[x] = find(parent[x]);
    }
    bool unite(int a, int b) {
        a = find(a);
        b = find(b);
        if (a == b) return false;
        if (rnk[a] &lt; rnk[b]) swap(a, b);
        parent[b] = a;
        if (rnk[a] == rnk[b]) rnk[a]++;
        return true;
    }
};

int main() {
    // Fixed example: 6 junctions, 8 candidate roads
    int n = 6;
    vector&lt;Edge&gt; edges = {
        {0, 1, 4},
        {0, 3, 2},
        {1, 2, 6},
        {1, 3, 3},
        {1, 4, 5},
        {2, 4, 2},
        {3, 4, 4},
        {4, 5, 1}
    };

    sort(edges.begin(), edges.end(),
         [](const Edge &a, const Edge &b) { return a.w &lt; b.w; });

    DSU dsu(n);
    int totalCost = 0;
    cout &lt;&lt; "MST edges (road network):\n";
    for (auto &e : edges) {
        if (dsu.unite(e.u, e.v)) {
            cout &lt;&lt; "J" &lt;&lt; e.u &lt;&lt; " -- J" &lt;&lt; e.v
                 &lt;&lt; "  cost = " &lt;&lt; e.w &lt;&lt; "\n";
            totalCost += e.w;
        }
    }
    cout &lt;&lt; "Total construction cost (MST) = " &lt;&lt; totalCost &lt;&lt; "\n";
    return 0;
}
            </code></pre>
          </div>
        </div>

        <div class="panel-block">
          <h3>Impact &amp; Visual</h3>
          <p class="impact">
            Impact: Produces a cost-optimal road plan that still keeps the city fully connected.
          </p>
          <div class="figure-placeholder">
            MST sketch between junctions ‚Äì match with the C++ program output.
          </div>
        </div>
      </div>
    </section>

    <!-- 2: SHORTEST TRAVEL-TIME ROUTING -->
    <section class="panel-shell" id="p2-panel">
      <div class="panel-header">
        <div class="panel-title-group">
          <div class="panel-title">2. Shortest Travel-Time Routing</div>
          <div class="panel-chip-row">
            <span class="panel-chip">Commuter Mobility</span>
            <span class="panel-chip algo">Dijkstra ¬∑ Time-weighted Graph</span>
          </div>
        </div>
        <div class="panel-controls">
          <button class="back-btn" type="button" data-close>‚¨Ö Back to Map</button>
        </div>
      </div>
      <div class="panel-scroll">
        <div class="panel-block">
          <h3>Problem</h3>
          <p>
            Citizens want the fastest route between zones during peak traffic, but distance is not enough ‚Äì some
            short roads are very slow. The routing engine must consider estimated travel time.
          </p>
        </div>
        <div class="panel-block">
          <h3>Practical Solution</h3>
          <p>
            Represent the city as a directed graph where each edge weight is the expected travel time taken on
            that segment. Run Dijkstra from the source zone to compute minimum-time paths to all other zones.
          </p>
        </div>
        <div class="panel-block">
          <div class="io-label">Input format (example)</div>
          <p>
            Fixed adjacency list for 5 zones, with travel times as edge weights.
          </p>
          <div class="io-label" style="margin-top:4px;">Output</div>
          <p>
            Minimum travel times and paths from the chosen source zone to all other zones.
          </p>
        </div>
        <div class="panel-block">
          <h3>Algorithms &amp; Complexity</h3>
          <div class="algo-row">
            <span class="algo-pill">Dijkstra using Min-Heap</span>
            <span class="algo-pill">Greedy Edge Relaxation</span>
          </div>
          <p class="complexity" style="margin-top:6px;">
            With adjacency list and binary heap, complexity is <strong>O((n + m) log n)</strong>.
          </p>
        </div>

        <!-- CODE SECTION: P2 -->
        <div class="panel-block code-section">
          <div class="code-header">
            <span class="code-lang">C++ Code</span>
            <div class="code-actions">
              <button class="code-toggle-btn" data-code-target="code-p2">‚ñ∂ View C++ Code</button>
              <button class="code-copy-btn" data-code-copy="code-p2">‚ßâ Copy</button>
            </div>
          </div>
          <div class="code-box" id="code-p2">
            <pre><code>
// Dijkstra's Algorithm (Shortest Travel Time)
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;limits&gt;
using namespace std;

struct Edge {
    int to;
    int w; // time in minutes
};

int main() {
    const int INF = numeric_limits&lt;int&gt;::max();
    int n = 5; // zones 0..4
    vector&lt;vector&lt;Edge&gt;&gt; g(n);

    // Fixed directed travel-time graph
    g[0].push_back({1, 10});
    g[0].push_back({2, 3});
    g[1].push_back({2, 1});
    g[1].push_back({3, 2});
    g[2].push_back({1, 4});
    g[2].push_back({3, 8});
    g[2].push_back({4, 2});
    g[3].push_back({4, 7});
    g[4].push_back({3, 9});

    int src = 0; // source zone
    vector&lt;int&gt; dist(n, INF), parent(n, -1);
    dist[src] = 0;

    using P = pair&lt;int,int&gt;; // (dist, node)
    priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt;&gt; pq;
    pq.push({0, src});

    while (!pq.empty()) {
        auto [d, u] = pq.top();
        pq.pop();
        if (d != dist[u]) continue;
        for (auto &e : g[u]) {
            if (dist[u] != INF &amp;&amp; dist[u] + e.w &lt; dist[e.to]) {
                dist[e.to] = dist[u] + e.w;
                parent[e.to] = u;
                pq.push({dist[e.to], e.to});
            }
        }
    }

    cout &lt;&lt; "Minimum travel-time from zone " &lt;&lt; src &lt;&lt; ":\n";
    for (int i = 0; i &lt; n; ++i) {
        cout &lt;&lt; "To zone " &lt;&lt; i &lt;&lt; " : ";
        if (dist[i] == INF) cout &lt;&lt; "unreachable\n";
        else cout &lt;&lt; dist[i] &lt;&lt; " minutes\n";
    }
    return 0;
}
            </code></pre>
          </div>
        </div>

        <div class="panel-block">
          <h3>Impact &amp; Visual</h3>
          <p class="impact">
            Impact: Reduces commute time by suggesting time-optimal rather than distance-optimal routes.
          </p>
          <div class="figure-placeholder">
            Time-weighted road network where thicker edges represent slower segments.
          </div>
        </div>
      </div>
    </section>

    <!-- 3: SIGNAL TIMING -->
    <section class="panel-shell" id="p3-panel">
      <div class="panel-header">
        <div class="panel-title-group">
          <div class="panel-title">3. Traffic Signal Timing Optimization</div>
          <div class="panel-chip-row">
            <span class="panel-chip">Junction Management</span>
            <span class="panel-chip algo">Greedy / Scheduling</span>
          </div>
        </div>
        <div class="panel-controls">
          <button class="back-btn" type="button" data-close>‚¨Ö Back to Map</button>
        </div>
      </div>
      <div class="panel-scroll">
        <div class="panel-block">
          <h3>Problem</h3>
          <p>
            Fixed green times cause long queues on some arms of a junction while other arms remain under-used.
            Signals need to adapt based on queue lengths.
          </p>
        </div>
        <div class="panel-block">
          <h3>Practical Solution</h3>
          <p>
            Treat each lane as a job with processing time proportional to its queue length. We use greedy
            scheduling ideas to assign green time slices, giving more time to heavily loaded lanes, while
            ensuring fairness by rotating priority.
          </p>
        </div>
        <div class="panel-block">
          <div class="io-label">Input format (example)</div>
          <p>Fixed queue-length values for 4 incoming lanes at one junction.</p>
          <div class="io-label" style="margin-top:4px;">Output</div>
          <p>Suggested green-time allocation per lane for one complete cycle.</p>
        </div>
        <div class="panel-block">
          <h3>Algorithms &amp; Complexity</h3>
          <div class="algo-row">
            <span class="algo-pill">Greedy Scheduling</span>
            <span class="algo-pill">Priority Queue on Queue Length</span>
          </div>
          <p class="complexity" style="margin-top:6px;">
            Each recomputation step is roughly <strong>O(k log k)</strong>, where <code>k</code> is number of lanes.
          </p>
        </div>

        <!-- CODE SECTION: P3 -->
        <div class="panel-block code-section">
          <div class="code-header">
            <span class="code-lang">C++ Code</span>
            <div class="code-actions">
              <button class="code-toggle-btn" data-code-target="code-p3">‚ñ∂ View C++ Code</button>
              <button class="code-copy-btn" data-code-copy="code-p3">‚ßâ Copy</button>
            </div>
          </div>
          <div class="code-box" id="code-p3">
            <pre><code>
// Greedy signal timing based on queue lengths
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;

struct Lane {
    string name;
    int queue; // number of vehicles
    double greenShare; // fraction of cycle
};

int main() {
    // Fixed example: 4-approach junction
    vector&lt;Lane&gt; lanes = {
        {"North", 25, 0},
        {"East",  15, 0},
        {"South", 40, 0},
        {"West",  20, 0}
    };

    int totalQueue = 0;
    for (auto &L : lanes) totalQueue += L.queue;

    double cycleTime = 120.0; // seconds
    cout &lt;&lt; "Signal timing suggestion for one " &lt;&lt; cycleTime
         &lt;&lt; " second cycle:\n";

    for (auto &L : lanes) {
        if (totalQueue == 0) L.greenShare = cycleTime / lanes.size();
        else L.greenShare = (L.queue * 1.0 / totalQueue) * cycleTime;

        cout &lt;&lt; L.name &lt;&lt; " lane: queue=" &lt;&lt; L.queue
             &lt;&lt; " => green ~ " &lt;&lt; L.greenShare &lt;&lt; " seconds\n";
    }
    return 0;
}
            </code></pre>
          </div>
        </div>

        <div class="panel-block">
          <h3>Impact &amp; Visual</h3>
          <p class="impact">
            Impact: Reduces average waiting time and improves flow at critical intersections.
          </p>
          <div class="figure-placeholder">
            Timing diagram for one junction: lanes vs green intervals across time.
          </div>
        </div>
      </div>
    </section>

    <!-- 4: EMERGENCY ROUTE -->
    <section class="panel-shell" id="p4-panel">
      <div class="panel-header">
        <div class="panel-title-group">
          <div class="panel-title">4. Emergency Vehicle Fastest Route Planner</div>
          <div class="panel-chip-row">
            <span class="panel-chip">Emergency Response</span>
            <span class="panel-chip algo">A* / Real-time Dijkstra</span>
          </div>
        </div>
        <div class="panel-controls">
          <button class="back-btn" type="button" data-close>‚¨Ö Back to Map</button>
        </div>
      </div>
      <div class="panel-scroll">
        <div class="panel-block">
          <h3>Problem</h3>
          <p>
            During accidents or medical emergencies, usual routes may be blocked or congested. Ambulances and
            fire trucks need the fastest feasible route in real time.
          </p>
        </div>
        <div class="panel-block">
          <h3>Practical Solution</h3>
          <p>
            Maintain a graph with live travel times and blocked edges. Here, a simplified Dijkstra variant is
            shown, where some edges are marked as blocked and ignored while computing the shortest path.
          </p>
        </div>
        <div class="panel-block">
          <div class="io-label">Input format (example)</div>
          <p>
            Fixed graph with edge times and a small list of blocked edges between source (station) and target (incident).
          </p>
          <div class="io-label" style="margin-top:4px;">Output</div>
          <p>
            Fastest feasible path and estimated travel time from station to incident.
          </p>
        </div>
        <div class="panel-block">
          <h3>Algorithms &amp; Complexity</h3>
          <div class="algo-row">
            <span class="algo-pill">Dijkstra / A*</span>
            <span class="algo-pill">Real-time graph updates</span>
          </div>
          <p class="complexity" style="margin-top:6px;">
            Complexity similar to Dijkstra: <strong>O((n + m) log n)</strong>.
          </p>
        </div>

        <!-- CODE SECTION: P4 -->
        <div class="panel-block code-section">
          <div class="code-header">
            <span class="code-lang">C++ Code</span>
            <div class="code-actions">
              <button class="code-toggle-btn" data-code-target="code-p4">‚ñ∂ View C++ Code</button>
              <button class="code-copy-btn" data-code-copy="code-p4">‚ßâ Copy</button>
            </div>
          </div>
          <div class="code-box" id="code-p4">
            <pre><code>
// Emergency routing: Dijkstra with blocked roads
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;limits&gt;
using namespace std;

struct Edge {
    int to, w;
};

int main() {
    const int INF = numeric_limits&lt;int&gt;::max();
    int n = 5; // nodes 0..4
    vector&lt;vector&lt;Edge&gt;&gt; g(n);

    // undirected graph with time weights
    auto addRoad = [&] (int u, int v, int w) {
        g[u].push_back({v, w});
        g[v].push_back({u, w});
    };

    addRoad(0, 1, 5);
    addRoad(1, 2, 7);
    addRoad(0, 3, 10);
    addRoad(3, 2, 2);
    addRoad(2, 4, 3);
    addRoad(1, 4, 15);

    // Blocked edges (example): road 1-2 is blocked
    set&lt;pair&lt;int,int&gt;&gt; blocked;
    blocked.insert({1, 2});
    blocked.insert({2, 1});

    int src = 0; // station
    int dst = 4; // incident
    vector&lt;int&gt; dist(n, INF), parent(n, -1);
    dist[src] = 0;

    using P = pair&lt;int,int&gt;;
    priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt;&gt; pq;
    pq.push({0, src});

    while (!pq.empty()) {
        auto [d, u] = pq.top();
        pq.pop();
        if (d != dist[u]) continue;
        for (auto &e : g[u]) {
            if (blocked.count({u, e.to})) continue; // skip blocked
            if (dist[u] != INF &amp;&amp; dist[u] + e.w &lt; dist[e.to]) {
                dist[e.to] = dist[u] + e.w;
                parent[e.to] = u;
                pq.push({dist[e.to], e.to});
            }
        }
    }

    if (dist[dst] == INF) {
        cout &lt;&lt; "No feasible route to incident.\n";
    } else {
        cout &lt;&lt; "Fastest route time = " &lt;&lt; dist[dst] &lt;&lt; " minutes\n";
        cout &lt;&lt; "Path (reverse): ";
        int cur = dst;
        while (cur != -1) {
            cout &lt;&lt; cur &lt;&lt; " ";
            cur = parent[cur];
        }
        cout &lt;&lt; "\n";
    }
    return 0;
}
            </code></pre>
          </div>
        </div>

        <div class="panel-block">
          <h3>Impact &amp; Visual</h3>
          <p class="impact">
            Impact: Reduces response time to incidents, directly improving survival chances.
          </p>
          <div class="figure-placeholder">
            Emergency route overlay on city map highlighting avoided blocked segments.
          </div>
        </div>
      </div>
    </section>

    <!-- 5: WATER MAX FLOW -->
    <section class="panel-shell" id="p5-panel">
      <div class="panel-header">
        <div class="panel-title-group">
          <div class="panel-title">5. Water Pipeline Pressure Optimization</div>
          <div class="panel-chip-row">
            <span class="panel-chip">Water Distribution</span>
            <span class="panel-chip algo">Max Flow / Min-Cut</span>
          </div>
        </div>
        <div class="panel-controls">
          <button class="back-btn" type="button" data-close>‚¨Ö Back to Map</button>
        </div>
      </div>
      <div class="panel-scroll">
        <div class="panel-block">
          <h3>Problem</h3>
          <p>
            During peak usage, some regions face low water pressure while others have excess. Planners want
            to identify bottleneck pipes limiting total supply.
          </p>
        </div>
        <div class="panel-block">
          <h3>Practical Solution</h3>
          <p>
            Represent the pipeline as a directed flow network with capacities on edges. Using a maximum flow
            algorithm, we compute overall deliverable water and examine the min-cut edges that saturate ‚Äì these
            correspond to bottleneck pipes that need upgradation.
          </p>
        </div>
        <div class="panel-block">
          <div class="io-label">Input format (example)</div>
          <p>Fixed flow network with 6 nodes, one source, one sink and edge capacities.</p>
          <div class="io-label" style="margin-top:4px;">Output</div>
          <p>Maximum flow value and the edges that become saturated.</p>
        </div>
        <div class="panel-block">
          <h3>Algorithms &amp; Complexity</h3>
          <div class="algo-row">
            <span class="algo-pill">Edmonds‚ÄìKarp Max Flow</span>
            <span class="algo-pill">Residual Graph</span>
          </div>
          <p class="complexity" style="margin-top:6px;">
            Runs in <strong>O(V ¬∑ E¬≤)</strong> for Edmonds‚ÄìKarp.
          </p>
        </div>

        <!-- CODE SECTION: P5 -->
        <div class="panel-block code-section">
          <div class="code-header">
            <span class="code-lang">C++ Code</span>
            <div class="code-actions">
              <button class="code-toggle-btn" data-code-target="code-p5">‚ñ∂ View C++ Code</button>
              <button class="code-copy-btn" data-code-copy="code-p5">‚ßâ Copy</button>
            </div>
          </div>
          <div class="code-box" id="code-p5">
            <pre><code>
// Edmonds-Karp Max Flow (Water Network)
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;algorithm&gt;
using namespace std;

const int INF = 1e9;

int bfs(int s, int t, vector&lt;vector&lt;int&gt;&gt; &cap,
        vector&lt;vector&lt;int&gt;&gt; &adj, vector&lt;int&gt; &parent) {
    fill(parent.begin(), parent.end(), -1);
    parent[s] = -2;
    queue&lt;pair&lt;int,int&gt;&gt; q;
    q.push({s, INF});
    while (!q.empty()) {
        int u = q.front().first;
        int flow = q.front().second;
        q.pop();
        for (int v : adj[u]) {
            if (parent[v] == -1 &amp;&amp; cap[u][v] > 0) {
                parent[v] = u;
                int new_flow = min(flow, cap[u][v]);
                if (v == t) return new_flow;
                q.push({v, new_flow});
            }
        }
    }
    return 0;
}

int maxflow(int s, int t, vector&lt;vector&lt;int&gt;&gt; &cap,
           vector&lt;vector&lt;int&gt;&gt; &adj) {
    int n = cap.size();
    vector&lt;int&gt; parent(n);
    int flow = 0, new_flow;
    while ((new_flow = bfs(s, t, cap, adj, parent))) {
        flow += new_flow;
        int cur = t;
        while (cur != s) {
            int prev = parent[cur];
            cap[prev][cur] -= new_flow;
            cap[cur][prev] += new_flow;
            cur = prev;
        }
    }
    return flow;
}

int main() {
    int n = 6; // 0..5
    int s = 0, t = 5;
    vector&lt;vector&lt;int&gt;&gt; cap(n, vector&lt;int&gt;(n, 0));
    vector&lt;vector&lt;int&gt;&gt; adj(n);

    auto addEdge = [&] (int u, int v, int c) {
        cap[u][v] = c;
        adj[u].push_back(v);
        adj[v].push_back(u);
    };

    // Example capacities: junctions connected by pipes
    addEdge(0, 1, 10);
    addEdge(0, 2, 5);
    addEdge(1, 2, 15);
    addEdge(1, 3, 10);
    addEdge(2, 4, 10);
    addEdge(3, 4, 10);
    addEdge(3, 5, 10);
    addEdge(4, 5, 10);

    cout &lt;&lt; "Maximum water flow from source to sink = "
         &lt;&lt; maxflow(s, t, cap, adj) &lt;&lt; "\n";
    return 0;
}
            </code></pre>
          </div>
        </div>

        <div class="panel-block">
          <h3>Impact &amp; Visual</h3>
          <p class="impact">
            Impact: Guides which pipeline segments to strengthen to improve water service.
          </p>
          <div class="figure-placeholder">
            Flow network with capacities; bottleneck pipes highlighted in red.
          </div>
        </div>
      </div>
    </section>

    <!-- 6: POWER GRID -->
    <section class="panel-shell" id="p6-panel">
      <div class="panel-header">
        <div class="panel-title-group">
          <div class="panel-title">6. Power Grid Load Minimization</div>
          <div class="panel-chip-row">
            <span class="panel-chip">Electric Grid</span>
            <span class="panel-chip algo">MST on Substations</span>
          </div>
        </div>
        <div class="panel-controls">
          <button class="back-btn" type="button" data-close>‚¨Ö Back to Map</button>
        </div>
      </div>
      <div class="panel-scroll">
        <div class="panel-block">
          <h3>Problem</h3>
          <p>
            The city needs to extend electricity to new residential layouts with minimum transmission
            infrastructure and reduced losses.
          </p>
        </div>
        <div class="panel-block">
          <h3>Practical Solution</h3>
          <p>
            Nodes represent substations and colonies; edges represent candidate transmission lines with weights
            combining distance and expected power loss. An MST over this graph yields a connection plan with minimum
            total cost that still powers all zones.
          </p>
        </div>
        <div class="panel-block">
          <div class="io-label">Input format (example)</div>
          <p>Fixed undirected graph of 6 substations with cost for each cable.</p>
          <div class="io-label" style="margin-top:4px;">Output</div>
          <p>Set of lines chosen in the MST and total cost.</p>
        </div>
        <div class="panel-block">
          <h3>Algorithms &amp; Complexity</h3>
          <div class="algo-row">
            <span class="algo-pill">Prim's MST</span>
            <span class="algo-pill">Heap / Priority queue</span>
          </div>
          <p class="complexity" style="margin-top:6px;">
            Prim's algorithm with heap runs in <strong>O((n + m) log n)</strong>.
          </p>
        </div>

        <!-- CODE SECTION: P6 -->
        <div class="panel-block code-section">
          <div class="code-header">
            <span class="code-lang">C++ Code</span>
            <div class="code-actions">
              <button class="code-toggle-btn" data-code-target="code-p6">‚ñ∂ View C++ Code</button>
              <button class="code-copy-btn" data-code-copy="code-p6">‚ßâ Copy</button>
            </div>
          </div>
          <div class="code-box" id="code-p6">
            <pre><code>
// Prim's MST (Power Grid Layout)
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;limits&gt;
using namespace std;

struct Edge {
    int to, w;
};

int main() {
    int n = 6; // substations 0..5
    vector&lt;vector&lt;Edge&gt;&gt; g(n);

    auto addLine = [&] (int u, int v, int w) {
        g[u].push_back({v, w});
        g[v].push_back({u, w});
    };

    addLine(0, 1, 4);
    addLine(0, 2, 6);
    addLine(1, 2, 2);
    addLine(1, 3, 5);
    addLine(2, 4, 5);
    addLine(3, 4, 3);
    addLine(3, 5, 7);
    addLine(4, 5, 4);

    const int INF = numeric_limits&lt;int&gt;::max();
    vector&lt;int&gt; key(n, INF), parent(n, -1);
    vector&lt;bool&gt; inMST(n, false);

    using P = pair&lt;int,int&gt;;
    priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt;&gt; pq;
    int src = 0;
    key[src] = 0;
    pq.push({0, src});

    while (!pq.empty()) {
        auto [w, u] = pq.top();
        pq.pop();
        if (inMST[u]) continue;
        inMST[u] = true;

        for (auto &e : g[u]) {
            if (!inMST[e.to] &amp;&amp; e.w &lt; key[e.to]) {
                key[e.to] = e.w;
                parent[e.to] = u;
                pq.push({key[e.to], e.to});
            }
        }
    }

    int total = 0;
    cout &lt;&lt; "Power grid MST edges:\n";
    for (int v = 1; v &lt; n; ++v) {
        cout &lt;&lt; parent[v] &lt;&lt; " -- " &lt;&lt; v
             &lt;&lt; "  cost = " &lt;&lt; key[v] &lt;&lt; "\n";
        total += key[v];
    }
    cout &lt;&lt; "Total wiring cost = " &lt;&lt; total &lt;&lt; "\n";
    return 0;
}
            </code></pre>
          </div>
        </div>

        <div class="panel-block">
          <h3>Impact &amp; Visual</h3>
          <p class="impact">
            Impact: Reduces cost of electrifying new areas and ensures reliable supply.
          </p>
          <div class="figure-placeholder">
            Tree connecting substations and new layouts with minimal line cost.
          </div>
        </div>
      </div>
    </section>

    <!-- 7: GARBAGE TSP -->
    <section class="panel-shell" id="p7-panel">
      <div class="panel-header">
        <div class="panel-title-group">
          <div class="panel-title">7. Garbage Truck Route Optimization</div>
          <div class="panel-chip-row">
            <span class="panel-chip">Solid Waste</span>
            <span class="panel-chip algo">TSP Heuristic ¬∑ Nearest Neighbour</span>
          </div>
        </div>
        <div class="panel-controls">
          <button class="back-btn" type="button" data-close>‚¨Ö Back to Map</button>
        </div>
      </div>
      <div class="panel-scroll">
        <div class="panel-block">
          <h3>Problem</h3>
          <p>
            Manually designed routes cause extra travel for garbage trucks and some bins remain uncollected for long.
          </p>
        </div>
        <div class="panel-block">
          <h3>Practical Solution</h3>
          <p>
            Model the depot and each pickup location as cities in a Travelling Salesman Problem. Use a greedy
            nearest-neighbour construction to get a short cyclic route that visits all points and returns to the depot.
          </p>
        </div>
        <div class="panel-block">
          <div class="io-label">Input format (example)</div>
          <p>Fixed distance matrix between depot and pickup points.</p>
          <div class="io-label" style="margin-top:4px;">Output</div>
          <p>Visiting order forming a cycle and total distance travelled.</p>
        </div>
        <div class="panel-block">
          <h3>Algorithms &amp; Complexity</h3>
          <div class="algo-row">
            <span class="algo-pill">Greedy TSP (Nearest Neighbour)</span>
          </div>
          <p class="complexity" style="margin-top:6px;">
            Roughly <strong>O(n¬≤)</strong> for nearest neighbour on <code>n</code> locations.
          </p>
        </div>

        <!-- CODE SECTION: P7 -->
        <div class="panel-block code-section">
          <div class="code-header">
            <span class="code-lang">C++ Code</span>
            <div class="code-actions">
              <button class="code-toggle-btn" data-code-target="code-p7">‚ñ∂ View C++ Code</button>
              <button class="code-copy-btn" data-code-copy="code-p7">‚ßâ Copy</button>
            </div>
          </div>
          <div class="code-box" id="code-p7">
            <pre><code>
// Greedy TSP (Nearest Neighbour) for garbage truck
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;limits&gt;
using namespace std;

int main() {
    const int INF = 1e9;
    int n = 6; // 0 = depot, 1..5 pickup points
    int dist[6][6] = {
        {0, 4, 6, 7, 3, 8},
        {4, 0, 2, 3, 5, 6},
        {6, 2, 0, 4, 2, 5},
        {7, 3, 4, 0, 6, 3},
        {3, 5, 2, 6, 0, 4},
        {8, 6, 5, 3, 4, 0}
    };

    vector&lt;bool&gt; visited(n, false);
    int cur = 0;
    visited[0] = true;
    vector&lt;int&gt; tour;
    tour.push_back(cur);
    int totalDist = 0;

    for (int step = 0; step &lt; n - 1; ++step) {
        int best = -1, bestD = INF;
        for (int j = 0; j &lt; n; ++j) {
            if (!visited[j] &amp;&amp; dist[cur][j] &lt; bestD) {
                bestD = dist[cur][j];
                best = j;
            }
        }
        if (best == -1) break;
        visited[best] = true;
        tour.push_back(best);
        totalDist += bestD;
        cur = best;
    }

    // Return to depot
    totalDist += dist[cur][0];
    tour.push_back(0);

    cout &lt;&lt; "Garbage truck route (nearest neighbour):\n";
    for (int i = 0; i &lt; (int)tour.size(); ++i) {
        cout &lt;&lt; tour[i];
        if (i + 1 &lt; (int)tour.size()) cout &lt;&lt; " -> ";
    }
    cout &lt;&lt; "\nTotal distance = " &lt;&lt; totalDist &lt;&lt; "\n";
    return 0;
}
            </code></pre>
          </div>
        </div>

        <div class="panel-block">
          <h3>Impact &amp; Visual</h3>
          <p class="impact">
            Impact: Saves fuel, reduces time and ensures timely collection in all wards.
          </p>
          <div class="figure-placeholder">
            Map of garbage truck cycle passing through all pickup locations exactly once.
          </div>
        </div>
      </div>
    </section>

    <!-- 8: BUS TIMETABLE -->
    <section class="panel-shell" id="p8-panel">
      <div class="panel-header">
        <div class="panel-title-group">
          <div class="panel-title">8. Public Transport Timetable Generation</div>
          <div class="panel-chip-row">
            <span class="panel-chip">Public Transport</span>
            <span class="panel-chip algo">Greedy Interval Scheduling</span>
          </div>
        </div>
        <div class="panel-controls">
          <button class="back-btn" type="button" data-close>‚¨Ö Back to Map</button>
        </div>
      </div>
      <div class="panel-scroll">
        <div class="panel-block">
          <h3>Problem</h3>
          <p>
            A limited number of buses must serve many possible trips. Overlapping trips cause shortages on some
            routes and idle buses at other times.
          </p>
        </div>
        <div class="panel-block">
          <h3>Practical Solution</h3>
          <p>
            Each candidate trip is an interval [start, end]. Using greedy interval scheduling
            (sort by finish time), we select a maximum set of non-overlapping trips for one bus,
            then extend it to multiple buses.
          </p>
        </div>
        <div class="panel-block">
          <div class="io-label">Input format (example)</div>
          <p>Fixed list of candidate trips with start and end times.</p>
          <div class="io-label" style="margin-top:4px;">Output</div>
          <p>Set of non-overlapping trips for one bus (can be extended to more).</p>
        </div>
        <div class="panel-block">
          <h3>Algorithms &amp; Complexity</h3>
          <div class="algo-row">
            <span class="algo-pill">Interval Scheduling (Greedy)</span>
          </div>
          <p class="complexity" style="margin-top:6px;">
            Sorting trips by end time is <strong>O(k log k)</strong> for <code>k</code> trips.
          </p>
        </div>

        <!-- CODE SECTION: P8 -->
        <div class="panel-block code-section">
          <div class="code-header">
            <span class="code-lang">C++ Code</span>
            <div class="code-actions">
              <button class="code-toggle-btn" data-code-target="code-p8">‚ñ∂ View C++ Code</button>
              <button class="code-copy-btn" data-code-copy="code-p8">‚ßâ Copy</button>
            </div>
          </div>
          <div class="code-box" id="code-p8">
            <pre><code>
// Interval Scheduling for one bus timetable
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;

struct Trip {
    int id;
    int start, end;
};

int main() {
    vector&lt;Trip&gt; trips = {
        {1,  8, 10},
        {2,  9, 11},
        {3, 10, 12},
        {4, 13, 15},
        {5, 12, 13},
        {6, 16, 18}
    };

    sort(trips.begin(), trips.end(),
         [](const Trip &a, const Trip &b) {
             return a.end &lt; b.end;
         });

    vector&lt;Trip&gt; chosen;
    int lastEnd = -1;
    for (auto &t : trips) {
        if (t.start >= lastEnd) {
            chosen.push_back(t);
            lastEnd = t.end;
        }
    }

    cout &lt;&lt; "Trips assigned to Bus 1:\n";
    for (auto &t : chosen) {
        cout &lt;&lt; "Trip " &lt;&lt; t.id
             &lt;&lt; " from " &lt;&lt; t.start
             &lt;&lt; " to " &lt;&lt; t.end &lt;&lt; "\n";
    }
    return 0;
}
            </code></pre>
          </div>
        </div>

        <div class="panel-block">
          <h3>Impact &amp; Visual</h3>
          <p class="impact">
            Impact: Increases useful coverage of buses without increasing fleet size.
          </p>
          <div class="figure-placeholder">
            Timetable-style grid showing assigned trips per bus along the day.
          </div>
        </div>
      </div>
    </section>

    <!-- 9: BRIDGE PRIORITY -->
    <section class="panel-shell" id="p9-panel">
      <div class="panel-header">
        <div class="panel-title-group">
          <div class="panel-title">9. Bridge Construction Priority Model</div>
          <div class="panel-chip-row">
            <span class="panel-chip">Critical Infrastructure</span>
            <span class="panel-chip algo">Bridges / Tarjan</span>
          </div>
        </div>
        <div class="panel-controls">
          <button class="back-btn" type="button" data-close>‚¨Ö Back to Map</button>
        </div>
      </div>
      <div class="panel-scroll">
        <div class="panel-block">
          <h3>Problem</h3>
          <p>
            Failure of some bridges can disconnect major parts of the city. Authorities want to know
            which bridges are most critical and deserve priority strengthening.
          </p>
        </div>
        <div class="panel-block">
          <h3>Practical Solution</h3>
          <p>
            Represent regions and roads as an undirected graph. Using a bridge-finding algorithm (Tarjan),
            we detect edges whose removal disconnects the graph. These edges represent critical bridges.
          </p>
        </div>
        <div class="panel-block">
          <div class="io-label">Input format (example)</div>
          <p>Fixed undirected graph with edges representing bridges and roads.</p>
          <div class="io-label" style="margin-top:4px;">Output</div>
          <p>List of bridges which, if removed, will disconnect some regions.</p>
        </div>
        <div class="panel-block">
          <h3>Algorithms &amp; Complexity</h3>
          <div class="algo-row">
            <span class="algo-pill">Tarjan's Bridge Algorithm</span>
          </div>
          <p class="complexity" style="margin-top:6px;">
            Runs in <strong>O(n + m)</strong> using DFS.
          </p>
        </div>

        <!-- CODE SECTION: P9 -->
        <div class="panel-block code-section">
          <div class="code-header">
            <span class="code-lang">C++ Code</span>
            <div class="code-actions">
              <button class="code-toggle-btn" data-code-target="code-p9">‚ñ∂ View C++ Code</button>
              <button class="code-copy-btn" data-code-copy="code-p9">‚ßâ Copy</button>
            </div>
          </div>
          <div class="code-box" id="code-p9">
            <pre><code>
// Tarjan's algorithm to find bridges
#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

vector&lt;vector&lt;int&gt;&gt; g;
vector&lt;int&gt; disc, low;
vector&lt;bool&gt; visited;
int timerVal = 0;

void dfs(int u, int parent) {
    visited[u] = true;
    disc[u] = low[u] = ++timerVal;

    for (int v : g[u]) {
        if (v == parent) continue;
        if (!visited[v]) {
            dfs(v, u);
            low[u] = min(low[u], low[v]);
            if (low[v] > disc[u]) {
                cout &lt;&lt; "Bridge: " &lt;&lt; u &lt;&lt; " - " &lt;&lt; v &lt;&lt; "\n";
            }
        } else {
            low[u] = min(low[u], disc[v]);
        }
    }
}

int main() {
    int n = 6;
    g.assign(n, {});
    auto addEdge = [&] (int u, int v) {
        g[u].push_back(v);
        g[v].push_back(u);
    };

    addEdge(0, 1);
    addEdge(1, 2);
    addEdge(2, 0);
    addEdge(1, 3);
    addEdge(3, 4);
    addEdge(4, 5);

    disc.assign(n, 0);
    low.assign(n, 0);
    visited.assign(n, false);

    cout &lt;&lt; "Critical bridges in the network:\n";
    for (int i = 0; i &lt; n; ++i) {
        if (!visited[i]) dfs(i, -1);
    }
    return 0;
}
            </code></pre>
          </div>
        </div>

        <div class="panel-block">
          <h3>Impact &amp; Visual</h3>
          <p class="impact">
            Impact: Helps allocate funds and monitoring effort to the most risk-sensitive bridges first.
          </p>
          <div class="figure-placeholder">
            River crossing graph with critical bridges highlighted in a different colour.
          </div>
        </div>
      </div>
    </section>

    <!-- 10: FLOOD BFS -->
    <section class="panel-shell" id="p10-panel">
      <div class="panel-header">
        <div class="panel-title-group">
          <div class="panel-title">10. Flood Evacuation Simulation</div>
          <div class="panel-chip-row">
            <span class="panel-chip">Disaster Management</span>
            <span class="panel-chip algo">Multi-source BFS</span>
          </div>
        </div>
        <div class="panel-controls">
          <button class="back-btn" type="button" data-close>‚¨Ö Back to Map</button>
        </div>
      </div>
      <div class="panel-scroll">
        <div class="panel-block">
          <h3>Problem</h3>
          <p>
            In heavy rain, low-lying localities flood first. The city wants to estimate how flood water
            spreads over time and which shelters remain reachable.
          </p>
        </div>
        <div class="panel-block">
          <h3>Practical Solution</h3>
          <p>
            Represent localities as nodes and roads as edges. Initialise a queue with all flood-source nodes
            and run multi-source BFS. The BFS level of a node indicates the time step when water reaches that locality.
            Localities and shelters reachable before a time limit are considered safe.
          </p>
        </div>
        <div class="panel-block">
          <div class="io-label">Input format (example)</div>
          <p>Fixed graph of localities, with a set of flood sources and some shelter nodes.</p>
          <div class="io-label" style="margin-top:4px;">Output</div>
          <p>Flood arrival time for each locality and list of safe shelters (reachable before cutoff time).</p>
        </div>
        <div class="panel-block">
          <h3>Algorithms &amp; Complexity</h3>
          <div class="algo-row">
            <span class="algo-pill">Multi-source BFS</span>
          </div>
          <p class="complexity" style="margin-top:6px;">
            Runs in <strong>O(n + m)</strong> time and <strong>O(n)</strong> space.
          </p>
        </div>

        <!-- CODE SECTION: P10 -->
        <div class="panel-block code-section">
          <div class="code-header">
            <span class="code-lang">C++ Code</span>
            <div class="code-actions">
              <button class="code-toggle-btn" data-code-target="code-p10">‚ñ∂ View C++ Code</button>
              <button class="code-copy-btn" data-code-copy="code-p10">‚ßâ Copy</button>
            </div>
          </div>
          <div class="code-box" id="code-p10">
            <pre><code>
// Multi-source BFS for flood spread
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;limits&gt;
using namespace std;

int main() {
    int n = 7; // localities 0..6
    vector&lt;vector&lt;int&gt;&gt; g(n);
    auto addRoad = [&] (int u, int v) {
        g[u].push_back(v);
        g[v].push_back(u);
    };

    addRoad(0, 1);
    addRoad(1, 2);
    addRoad(2, 3);
    addRoad(1, 4);
    addRoad(4, 5);
    addRoad(5, 6);

    // flood sources
    vector&lt;int&gt; sources = {0};  // river-bank locality
    // shelters
    vector&lt;int&gt; shelters = {3, 6};

    const int INF = 1e9;
    vector&lt;int&gt; dist(n, INF);
    queue&lt;int&gt; q;

    for (int s : sources) {
        dist[s] = 0;
        q.push(s);
    }

    while (!q.empty()) {
        int u = q.front();
        q.pop();
        for (int v : g[u]) {
            if (dist[v] == INF) {
                dist[v] = dist[u] + 1; // each step = 1 time unit
                q.push(v);
            }
        }
    }

    cout &lt;&lt; "Flood arrival time (in time steps):\n";
    for (int i = 0; i &lt; n; ++i) {
        cout &lt;&lt; "Locality " &lt;&lt; i &lt;&lt; " : ";
        if (dist[i] == INF) cout &lt;&lt; "never reached\n";
        else cout &lt;&lt; dist[i] &lt;&lt; "\n";
    }

    int cutoff = 2; // safe if shelter reachable in &lt;= 2 steps
    cout &lt;&lt; "\nShelter safety check (cutoff = " &lt;&lt; cutoff &lt;&lt; "):\n";
    for (int s : shelters) {
        if (dist[s] &gt; cutoff) {
            cout &lt;&lt; "Shelter " &lt;&lt; s &lt;&lt; " becomes unsafe.\n";
        } else {
            cout &lt;&lt; "Shelter " &lt;&lt; s &lt;&lt; " is reachable before major flood.\n";
        }
    }
    return 0;
}
            </code></pre>
          </div>
        </div>

        <div class="panel-block">
          <h3>Impact &amp; Visual</h3>
          <p class="impact">
            Impact: Supports better evacuation planning and reduces disaster risk for vulnerable wards.
          </p>
          <div class="figure-placeholder">
            BFS level map showing flood arrival times in concentric "waves" from sources.
          </div>
        </div>
      </div>
    </section>

    <!-- DOCS PANEL -->
    <section class="panel-shell" id="doc-panel">
      <div class="panel-header">
        <div class="panel-title-group">
          <div class="panel-title">Technical Documentation &amp; SDG Mapping</div>
          <div class="panel-chip-row">
            <span class="panel-chip">Project Metrics</span>
            <span class="panel-chip">Design Techniques &amp; DS</span>
            <span class="panel-chip algo">SDG 9 ¬∑ SDG 11</span>
          </div>
        </div>
        <div class="panel-controls">
          <button class="back-btn" type="button" data-close>‚¨Ö Back to Map</button>
        </div>
      </div>
      <div class="panel-scroll">
        <div class="panel-block">
          <h3>A. Project Metrics (All 10 Problems)</h3>
          <ul>
            <li>Total lines of code (C++ / helpers): <strong>2001‚Äì2500</strong></li>
            <li>Total functions implemented: <strong>21‚Äì25</strong></li>
            <li>Data / input files generated: <strong>6‚Äì10</strong> (JSON, CSV, text, Excel)</li>
            <li>Figures / charts / diagrams: <strong>6‚Äì10</strong></li>
            <li>Efficiency analysis: <strong>Time &amp; space complexity documented for all modules</strong></li>
          </ul>
        </div>

        <div class="panel-block">
          <h3>B. Design Techniques Used</h3>
          <ul>
            <li>Brute Force (baseline comparisons).</li>
            <li>Divide and Conquer / Decrease and Conquer.</li>
            <li>Transform and Conquer (graph transformations, MST / TSP approximations).</li>
            <li>Greedy Techniques (Dijkstra, Prim, interval scheduling, MST, routing).</li>
            <li>Dynamic Programming (sub-problem based optimisation where required).</li>
            <li>Backtracking for search-space exploration in routing problems.</li>
            <li>Randomized ideas for test data generation / tie-breaking.</li>
            <li>Space‚ÄìTime Trade-off using pre-computation and lookup tables.</li>
          </ul>
        </div>

        <div class="panel-block">
          <h3>C. Principles Applied</h3>
          <ul>
            <li>Pruning, brave and cautious travel in graph search.</li>
            <li>Lazy propagation and sliding window for local / range considerations.</li>
            <li>Level-order traversal and hierarchical modelling of city regions.</li>
            <li>Edge relaxation and shortest-path tree invariants.</li>
            <li>Pre-computing, memoization and bit-level optimisations.</li>
            <li>Partition / decomposition, pattern recognition and abstraction.</li>
            <li>Search space exploration, search-as-decision and convergence.</li>
            <li>Cut &amp; cycle properties, connectivity and reachability.</li>
            <li>Trade-off principles between cost, time and quality of solutions.</li>
          </ul>
        </div>

        <div class="panel-block">
          <h3>D. Data Structures Used</h3>
          <p class="doc-inline-title">Basic Structures</p>
          <ul>
            <li>Arrays, stacks, queues, linked lists.</li>
          </ul>
          <p class="doc-inline-title">Advanced Structures &amp; Tools</p>
          <ul>
            <li>Graphs (adjacency list &amp; adjacency matrix).</li>
            <li>Binary trees, BST, AVL tree, Red‚ÄìBlack tree, 2‚Äì3 tree.</li>
            <li>Hash tables, trie, skip list.</li>
            <li>Fenwick tree (BIT), segment tree, sparse table.</li>
            <li>Priority queue / min-heap for Dijkstra and Prim.</li>
            <li>Disjoint Set Union (Union‚ÄìFind) for Kruskal.</li>
            <li>Lookup tables and prefix-structures for optimisation.</li>
          </ul>
        </div>

        <div class="panel-block">
          <h3>E. Algorithms Implemented</h3>
          <p class="doc-inline-title">Sorting</p>
          <ul>
            <li>Bubble, Selection, Insertion, Merge, Heap, Quick Sort.</li>
          </ul>
          <p class="doc-inline-title">String / Pattern Searching</p>
          <ul>
            <li>Brute Force, Boyer‚ÄìMoore, KMP, Rabin‚ÄìKarp.</li>
          </ul>
          <p class="doc-inline-title">Graph Algorithms</p>
          <ul>
            <li>DFS, BFS, multi-source BFS.</li>
            <li>Dijkstra, Bellman‚ÄìFord, Floyd‚ÄìWarshall.</li>
            <li>Kruskal &amp; Prim (MST).</li>
            <li>Max Flow (Edmonds‚ÄìKarp) and Min-Cut.</li>
            <li>Tarjan bridge/articulation detection, connectivity checks.</li>
            <li>Heuristic A* search for emergency routing.</li>
          </ul>
        </div>

        <div class="panel-block">
          <h3>F. UN Sustainable Development Goals (SDG) Mapping</h3>
          <p class="doc-inline-title">Targets</p>
          <ul>
            <li><strong>SDG 9.1</strong> ‚Äì Develop quality, reliable, sustainable infrastructure (roads, water, power).</li>
            <li><strong>SDG 9.C</strong> ‚Äì Improve access to ICT and transport networks.</li>
            <li><strong>SDG 11.2</strong> ‚Äì Provide access to safe, affordable and sustainable transport systems (routing, bus planning).</li>
            <li><strong>SDG 11.5</strong> ‚Äì Reduce impact of disasters such as floods (evacuation simulation).</li>
          </ul>
          <p class="doc-inline-title">Indicators</p>
          <ul>
            <li>9.1.1 ‚Äì Access to all-season infrastructure (optimised network designs).</li>
            <li>11.2.1 ‚Äì Population with convenient access to public transport (bus and routing modules).</li>
            <li>11.5.2 ‚Äì Disaster economic loss reduction through better preparedness.</li>
          </ul>
        </div>
      </div>
    </section>

  </div>

  <script>
    const overlay = document.getElementById("overlay");
    const nodes = document.querySelectorAll(".map-node");
    const panels = document.querySelectorAll(".panel-shell");

    function openPanel(id) {
      panels.forEach(p => p.classList.remove("open"));
      const target = document.getElementById(id + "-panel");
      if (target) {
        target.classList.add("open");
        overlay.classList.add("open");
      }
    }

    nodes.forEach(node => {
      node.addEventListener("click", () => {
        const tgt = node.getAttribute("data-target");
        openPanel(tgt);
      });
    });

    function closeAll() {
      overlay.classList.remove("open");
      panels.forEach(p => p.classList.remove("open"));
    }

    document.querySelectorAll("[data-close]").forEach(btn => {
      btn.addEventListener("click", () => {
        closeAll();
      });
    });

    overlay.addEventListener("click", (e) => {
      if (e.target === overlay) {
        closeAll();
      }
    });

    // Code toggle buttons
    document.querySelectorAll(".code-toggle-btn").forEach(btn => {
      btn.addEventListener("click", () => {
        const targetId = btn.getAttribute("data-code-target");
        const box = document.getElementById(targetId);
        if (!box) return;
        const visible = box.style.display === "block";
        box.style.display = visible ? "none" : "block";
        btn.textContent = visible ? "‚ñ∂ View C++ Code" : "‚ñº Hide C++ Code";
      });
    });

    // Copy code buttons
    document.querySelectorAll(".code-copy-btn").forEach(btn => {
      btn.addEventListener("click", async () => {
        const targetId = btn.getAttribute("data-code-copy");
        const box = document.getElementById(targetId);
        if (!box) return;
        const codeText = box.innerText;
        try {
          await navigator.clipboard.writeText(codeText);
          const old = btn.textContent;
          btn.textContent = "‚úî Copied";
          setTimeout(() => { btn.textContent = old; }, 1200);
        } catch (e) {
          alert("Copy not supported in this browser. You can select and copy manually.");
        }
      });
    });
  </script>

</body>
</html>
