<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Land Use Optimization ‚Äì Algorithms</title>

<!-- Prism.js Syntax Highlighting -->
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.css" rel="stylesheet"/>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>

<style>
/* -------------------------------------------
   GLOBAL STYLING
------------------------------------------- */
:root {
  --bg: #eef5ff;
  --text: #000;
  --sidebar-bg: #104e99;
  --panel-bg: #f9fbff;
  --code-bg: #1e1e1e;
}

.dark {
  --bg: #0c0f15;
  --text: #e6e6e6;
  --sidebar-bg: #0d3a6b;
  --panel-bg: #141821;
  --code-bg: #000;
}

body {
  margin: 0;
  font-family: Arial, sans-serif;
  background: var(--bg);
  color: var(--text);
  display: flex;
  height: 100vh;
  overflow: hidden;
  transition: background 0.5s ease;
}

/* -------------------------------------------
   LEFT SIDEBAR
------------------------------------------- */
.sidebar {
  width: 25%;
  background: var(--sidebar-bg);
  color: white;
  padding: 20px;
  overflow-y: auto;
  animation: slideIn 0.7s ease;
}

.sidebar h2 {
  font-size: 22px;
  margin-bottom: 12px;
  text-align: center;
}

.problem {
  background: rgba(255,255,255,0.15);
  padding: 12px;
  margin-bottom: 10px;
  border-radius: 8px;
  cursor: pointer;
  transition: 0.2s;
  font-size: 15px;
}
.problem:hover {
  background: rgba(255,255,255,0.35);
  transform: scale(1.03);
}

/* -------------------------------------------
   CENTER CONTENT
------------------------------------------- */
.content {
  width: 75%;
  padding: 25px;
  overflow-y: auto;
  background: var(--panel-bg);
  animation: fadeIn 1s ease;
}

.content h2 {
  margin-top: 0;
  font-size: 28px;
}

pre {
  background: var(--code-bg) !important;
  padding: 18px;
  border-radius: 8px;
  margin-top: 20px;
  overflow-x: auto;
  font-size: 15px;
  transition: background 0.4s ease;
}

/* -------------------------------------------
   DARK MODE TOGGLE BUTTON
------------------------------------------- */
.toggle-container {
  text-align: center;
  padding: 10px;
  margin-bottom: 10px;
}

.toggle-btn {
  background: white;
  color: black;
  padding: 8px 15px;
  font-size: 14px;
  border-radius: 6px;
  border: none;
  cursor: pointer;
  transition: 0.3s;
}
.toggle-btn:hover {
  transform: scale(1.05);
}

/* -------------------------------------------
   ANIMATIONS
------------------------------------------- */
@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes slideIn {
  from { transform: translateX(-60px); opacity: 0; }
  to { transform: translateX(0); opacity: 1; }
}
</style>

<script>
function toggleDarkMode() {
  document.body.classList.toggle("dark");
}

function loadProblem(title, desc, code) {
  document.getElementById("title").innerHTML = title;
  document.getElementById("description").innerHTML = desc;
  document.getElementById("code").innerHTML = code;
  Prism.highlightAll();
}
</script>

</head>

<body>

<!-- SIDEBAR -->
<div class="sidebar">
  <div class="toggle-container">
    <button class="toggle-btn" onclick="toggleDarkMode()">üåô Toggle Dark Mode</button>
  </div>

  <h2>Problems</h2>

  <div class="problem" onclick="loadProblem('Optimal Hospital Location', desc1, code1)">1. Optimal Hospital Location</div>
  <div class="problem" onclick="loadProblem('School Allocation to Students', desc2, code2)">2. School Allocation to Students</div>
  <div class="problem" onclick="loadProblem('Smart Parking Slot Allocation', desc3, code3)">3. Smart Parking Slot Allocation</div>
  <div class="problem" onclick="loadProblem('Industrial vs Residential Separation', desc4, code4)">4. Industrial vs Residential Separation</div>
  <div class="problem" onclick="loadProblem('Public Park Placement Optimization', desc5, code5)">5. Public Park Placement Optimization</div>
  <div class="problem" onclick="loadProblem('Land Subdivision Optimization', desc6, code6)">6. Land Subdivision Optimization</div>
  <div class="problem" onclick="loadProblem('High Footfall Commercial Zone Prediction', desc7, code7)">7. High Footfall Commercial Zone Prediction</div>
  <div class="problem" onclick="loadProblem('Creation of Green Belt Buffers', desc8, code8)">8. Creation of Green Belt Buffers</div>
  <div class="problem" onclick="loadProblem('Footpath Connectivity Plan', desc9, code9)">9. Footpath Connectivity Plan</div>
  <div class="problem" onclick="loadProblem('Underground Utility Routing', desc10, code10)">10. Underground Utility Routing</div>
</div>

<!-- CENTER PANEL -->
<div class="content">
  <h2 id="title">Select a Problem</h2>
  <p id="description">Click a problem from the left to view its description, time complexity, and code.</p>
  <pre><code id="code" class="language-python"># Code will appear here</code></pre>
</div>

<script>
/* ===========================================================
   PROBLEM 1 ‚Äì MEDIAN-BASED OPTIMAL HOSPITAL LOCATION
=========================================================== */
const desc1 = `
<b>Concepts Used:</b> Median, Sorting (Quick Sort), Divide & Conquer.<br><br>
<b>Time Complexity:</b> O(n log n) due to sorting.<br><br>
The hospital is placed at the statistical median to minimize total travel distance.
`;

const code1 = `
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr)//2]
    left = [x for x in arr if x < pivot]
    mid  = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quick_sort(left) + mid + quick_sort(right)

def optimal_hospital_location(points):
    """
    Computes the optimal hospital position by taking the median.
    """
    sorted_points = quick_sort(points)
    n = len(sorted_points)
    median = sorted_points[n // 2]
    return median
`;

/* ===========================================================
   PROBLEM 2 ‚Äì SCHOOL ALLOCATION USING BIPARTITE MATCHING
=========================================================== */
const desc2 = `
<b>Concepts Used:</b> DFS, Bipartite Matching, Recursion.<br><br>
<b>Time Complexity:</b> O(V √ó E).<br><br>
Assign students to schools using maximum matching.
`;

const code2 = `
def bpm(student, graph, seen, match):
    for school in graph[student]:
        if not seen[school]:
            seen[school] = True
            if match[school] == -1 or bpm(match[school], graph, seen, match):
                match[school] = student
                return True
    return False

def max_matching(graph, n_students, n_schools):
    match = [-1] * n_schools
    result = 0

    for student in range(n_students):
        seen = [False] * n_schools
        if bpm(student, graph, seen, match):
            result += 1
    return result, match
`;

/* ===========================================================
   PROBLEM 3 ‚Äì SMART PARKING USING DYNAMIC PROGRAMMING
=========================================================== */
const desc3 = `
<b>Concepts Used:</b> Sorting, DP Table.<br><br>
<b>Time Complexity:</b> O(n¬≤).<br><br>
Minimizes walking distance using dynamic programming.
`;

const code3 = `
def min_distance_assignment(cars, slots):
    cars.sort()
    slots.sort()

    n, m = len(cars), len(slots)
    dp = [[10**9] * (m + 1) for _ in range(n + 1)]
    for j in range(m + 1):
        dp[0][j] = 0

    for i in range(1, n+1):
        for j in range(1, m+1):
            cost = abs(cars[i-1] - slots[j-1])
            dp[i][j] = min(dp[i][j-1], dp[i-1][j-1] + cost)

    return dp[n][m]
`;

/* ===========================================================
   PROBLEM 4 ‚Äì GRAPH COLORING FOR ZONING
=========================================================== */
const desc4 = `
<b>Concepts Used:</b> Greedy Coloring, Graph Theory.<br><br>
<b>Time Complexity:</b> O(V¬≤).<br><br>
Ensures industrial and residential zones never touch.
`;

const code4 = `
def graph_coloring(graph):
    colors = {}
    for node in graph:
        neighbor_colors = {colors[n] for n in graph[node] if n in colors}
        for c in range(1, 6):
            if c not in neighbor_colors:
                colors[node] = c
                break
    return colors
`;

/* ===========================================================
   PROBLEM 5 ‚Äì PUBLIC PARK OPTIMIZATION USING FENWICK TREE
=========================================================== */
const desc5 = `
<b>Concepts Used:</b> Fenwick Tree, Range Queries.<br><br>
<b>Time Complexity:</b> O(log n) per update/query.<br><br>
Used to track and optimize green coverage in an area.
`;

const code5 = `
class FenwickTree:
    def __init__(self, n):
        self.tree = [0]*(n+1)

    def update(self, i, delta):
        while i < len(self.tree):
            self.tree[i] += delta
            i += i & -i

    def query(self, i):
        s = 0
        while i > 0:
            s += self.tree[i]
            i -= i & -i
        return s

    def range_query(self, l, r):
        return self.query(r) - self.query(l-1)
`;

/* ===========================================================
   PROBLEM 6 ‚Äì LAND SUBDIVISION USING DIVIDE & CONQUER
=========================================================== */
const desc6 = `
<b>Concepts Used:</b> Recursion, Divide & Conquer.<br><br>
<b>Time Complexity:</b> O(log n).<br><br>
Splits land optimally similar to Quick Sort partitioning.
`;

const code6 = `
def subdivide(length):
    if length <= 1:
        return [length]
    mid = length // 2
    return subdivide(mid) + subdivide(length - mid)
`;

/* ===========================================================
   PROBLEM 7 ‚Äì FOOTFALL PREDICTION USING HEAPS
=========================================================== */
const desc7 = `
<b>Concepts Used:</b> Heaps, Priority Queues.<br><br>
<b>Time Complexity:</b> O(n log k).<br><br>
Used to find highest footfall commercial zones.
`;

const code7 = `
import heapq

def top_k_zones(zones, k):
    return heapq.nlargest(k, zones, key=lambda x: x.footfall)
`;

/* ===========================================================
   PROBLEM 8 ‚Äì GREEN BELT BUFFER USING BACKTRACKING
=========================================================== */
const desc8 = `
<b>Concepts Used:</b> Backtracking, Recursion.<br><br>
<b>Time Complexity:</b> O(2‚Åø).<br><br>
Ensures valid eco-buffer placements around cities.
`;

const code8 = `
def place_buffers(zones, idx, placed):
    if idx == len(zones):
        return True

    for choose in [True, False]:
        if choose:
            if placed and zones[idx] - placed[-1] < 3:
                continue
            placed.append(zones[idx])

        if place_buffers(zones, idx+1, placed):
            return True

        if choose:
            placed.pop()

    return False
`;

/* ===========================================================
   PROBLEM 9 ‚Äì FOOTPATH CONNECTIVITY USING FLOYD-WARSHALL
=========================================================== */
const desc9 = `
<b>Concepts Used:</b> Floyd‚ÄìWarshall, Dynamic Programming.<br><br>
<b>Time Complexity:</b> O(n¬≥).<br><br>
Computes all-pairs shortest walking paths.
`;

const code9 = `
def floyd_warshall(dist):
    n = len(dist)

    for k in range(n):
        for i in range(n):
            for j in range(n):
                if dist[i][k] + dist[k][j] < dist[i][j]:
                    dist[i][j] = dist[i][k] + dist[k][j]

    return dist
`;

/* ===========================================================
   PROBLEM 10 ‚Äì UNDERGROUND ROUTING USING DIJKSTRA
=========================================================== */
const desc10 = `
<b>Concepts Used:</b> Dijkstra, Priority Queue.<br><br>
<b>Time Complexity:</b> O((V + E) log V).<br><br>
Used to find minimal-cost routes for underground utilities.
`;

const code10 = `
import heapq

def dijkstra(graph, start):
    pq = [(0, start)]
    dist = {node: float("inf") for node in graph}
    dist[start] = 0

    while pq:
        d, node = heapq.heappop(pq)

        if d > dist[node]:
            continue

        for neighbor, weight in graph[node]:
            new_cost = d + weight

            if new_cost < dist[neighbor]:
                dist[neighbor] = new_cost
                heapq.heappush(pq, (new_cost, neighbor))

    return dist
`;
</script>

</body>
</html>
