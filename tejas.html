<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Land Use, Zoning & Location Optimization — Tejas Keri</title>

<!-- Fonts -->
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600;800&family=Poppins:wght@300;400;600;700&display=swap" rel="stylesheet">

<!-- Prism (syntax highlighting) -->
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-clike.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-cpp.min.js"></script>

<style>
:root{
  --bg: #f4f7fb;
  --panel: #ffffff;
  --muted: #475569;
  --accent: #0f4fa8;
  --accent-2: #0b6fb6;
  --radius: 14px;
  --card-shadow: 0 12px 34px rgba(14,30,60,0.06);
  --text: #052033;
  --muted-2: #6b7280;
}

*{box-sizing:border-box}
html,body{height:100%;margin:0;font-family:"Poppins",system-ui,-apple-system,"Segoe UI",Roboto,Arial;background:linear-gradient(180deg,#f7fbfd 0%,#f4f7fb 100%);color:var(--text);-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;}

/* page frame */
.container{max-width:1180px;margin:28px auto;padding:18px;}

/* top nav */
.header{
  display:flex;
  align-items:center;
  gap:18px;
  background:linear-gradient(90deg, rgba(15,79,168,0.95), rgba(11,111,182,0.95));
  color:white;
  padding:18px;
  border-radius:12px;
  box-shadow: 0 8px 30px rgba(6,40,90,0.18);
}
.header .title{
  font-size:20px;
  font-weight:700;
  letter-spacing:0.1px;
}
.header .nav-right{margin-left:auto;font-size:14px;opacity:0.95}

/* hero area with image left, big title right */
.hero{
  display:flex;
  gap:18px;
  align-items:center;
  margin-top:18px;
}
.hero .hero-img{
  width:100%;
  max-width: 1100px;
  border-radius:16px;
  overflow:hidden;
  box-shadow: var(--card-shadow);
}
.hero .hero-banner{
  position:relative;
  padding:28px;
  background: linear-gradient(90deg, rgba(3,70,130,1), rgba(8,110,170,1));
  border-radius:12px;
  color:white;
  margin-top: -86px;
  box-shadow: 0 12px 36px rgba(5,50,100,0.12);
}
.hero .hero-banner h1{
  margin:0;font-size:28px;font-weight:700;
}
.hero .hero-banner p{margin:8px 0 0;color:rgba(255,255,255,0.9);font-size:14px;max-width:900px}

/* grid of cards */
.grid{
  display:grid;
  grid-template-columns: repeat(3, 1fr);
  gap:18px;
  margin-top:28px;
}
@media (max-width:1100px){ .grid{grid-template-columns: repeat(2,1fr);} }
@media (max-width:680px){ .grid{grid-template-columns: 1fr;} .hero .hero-banner{margin-top:0} .header{flex-direction:column;align-items:flex-start}}

/* card */
.card{
  background:var(--panel);
  border-radius:12px;
  padding:18px;
  border-left:6px solid rgba(11,111,182,0.12);
  box-shadow: var(--card-shadow);
}
.card h3{margin:0 0 8px 0;font-size:18px;color:var(--text)}
.card small{display:block;color:var(--muted-2);margin-bottom:12px}
.card p{margin:0 0 12px 0;color:var(--muted-2);font-size:14px}

/* code area inside card: collapsible */
.code-area{
  background:#0f1724;
  border-radius:10px;
  padding:12px;
  color:#cbeefc;
  overflow:auto;
  max-height:360px;
}

/* button */
.btn{
  display:inline-block;padding:8px 12px;border-radius:999px;background:linear-gradient(90deg,var(--accent),var(--accent-2));color:white;text-decoration:none;font-weight:700;font-size:13px;box-shadow:0 8px 18px rgba(8,80,140,0.12)
}

/* footer */
.footer{
  margin-top:28px;padding:16px;border-radius:12px;background:#042a4a;color:white;text-align:center;font-size:14px;box-shadow:0 8px 20px rgba(4,20,40,0.08)
}

/* make pre code readable */
pre { margin: 0; background: transparent; border: 0; padding: 0; }
code[class*="language-"]{ font-family: "JetBrains Mono", monospace; font-size:13px; line-height:1.4; white-space:pre; color: #cbeefc; display:block; }

/* small helper */
.center{max-width:1100px;margin:0 auto}
</style>
</head>
<body>

<div class="container center">

  <!-- Header -->
  <div class="header" role="banner" aria-label="DAA Portfolio header">
    <div style="display:flex;align-items:center;gap:14px">
      <div style="width:44px;height:44px;border-radius:8px;background:rgba(255,255,255,0.12);display:flex;align-items:center;justify-content:center;font-weight:800">TK</div>
      <div>
        <div class="title">Tejas Keri</div>
        <div style="font-size:12px;opacity:0.9">Design & Analysis of Algorithms — Land Use & Location Optimization</div>
      </div>
    </div>
    <div class="nav-right">Home</div>
  </div>

  <!-- Hero banner with uploaded image -->
  <div style="margin-top:18px;">
    <div class="hero">
      <div class="hero-img" style="flex:1">
        <!-- Use the image available in the session container -->
        <img src="/mnt/data/387b514b-1126-4a13-a04e-c3fb3bc57a6f.jpeg" alt="Land Use Projects" style="width:100%;height:auto;display:block;object-fit:cover" />
      </div>
    </div>

    <div class="hero-banner" style="margin-top:18px">
      <h1>Land Use, Zoning & Location Optimization Projects</h1>
      <p>These problems involve spatial allocation, clustering, matching, zoning, and optimal city planning using algorithms. Click any card below to view the C++ solution snippet for that problem.</p>
    </div>
  </div>

  <!-- Grid: only the 10 problems from the screenshot -->
  <div class="grid" role="list" aria-label="Project cards">

    <!-- 1 -->
    <article class="card" id="card-1" role="listitem" aria-labelledby="title-1">
      <h3 id="title-1">1. Optimal Hospital Location</h3>
      <small>Algorithm: k-Medians / 1D median (example)</small>
      <p>Place hospitals to minimize average distance for citizens. For 1D or on tree-like networks use median; for k-median clustering use iterative improvement or k-means variants.</p>
      <div class="code-area" aria-live="polite">
<pre><code class="language-cpp">// Hospital Location (1D median)
#include &lt;bits/stdc++.h&gt;
using namespace std;

double median_1d(vector<long long>& pts){
    sort(pts.begin(), pts.end());
    int n = pts.size();
    if(n % 2 == 1) return pts[n/2];
    return (pts[n/2 - 1] + pts[n/2]) / 2.0;
}

int main(){
    vector<long long> pts = {1,5,9,3,8};
    cout << "Median: " << median_1d(pts) << '\\n';
    return 0;
}</code></pre>
      </div>
    </article>

    <!-- 2 -->
    <article class="card" id="card-2" role="listitem" aria-labelledby="title-2">
      <h3 id="title-2">2. School Allocation to Students</h3>
      <small>Algorithm: Bipartite Matching / Max-Flow (Dinic)</small>
      <p>Assign students to nearest valid schools respecting capacities using a flow network.</p>
      <div class="code-area" aria-live="polite">
<pre><code class="language-cpp">// Dinic's Algorithm (C++)
#include &lt;bits/stdc++.h&gt;
using namespace std;

struct Edge{int to; long long cap; int rev;};
struct Dinic {
    int n; vector<vector<Edge>> g; vector<int> level, it;
    Dinic(int n):n(n),g(n),level(n),it(n){}
    void add_edge(int u,int v,long long c){
        g[u].push_back({v,c,(int)g[v].size()});
        g[v].push_back({u,0,(int)g[u].size()-1});
    }
    bool bfs(int s,int t){
        fill(level.begin(), level.end(), -1);
        queue<int>q; level[s]=0; q.push(s);
        while(!q.empty()){
            int u=q.front(); q.pop();
            for(auto &e:g[u]) if(e.cap>0 && level[e.to]==-1){ level[e.to]=level[u]+1; q.push(e.to); }
        }
        return level[t]!=-1;
    }
    long long dfs(int u,int t,long long f){
        if(u==t) return f;
        for(int &i=it[u]; i<(int)g[u].size(); ++i){
            Edge &e = g[u][i];
            if(e.cap>0 && level[e.to]==level[u]+1){
                long long ret = dfs(e.to,t,min(f,e.cap));
                if(ret>0){ e.cap -= ret; g[e.to][e.rev].cap += ret; return ret; }
            }
        }
        return 0;
    }
    long long max_flow(int s,int t){
        long long flow=0;
        while(bfs(s,t)){
            fill(it.begin(), it.end(), 0);
            while(true){ long long f = dfs(s,t,LLONG_MAX); if(f==0) break; flow+=f; }
        }
        return flow;
    }
};

int main(){
    // Build flow network and call max_flow
    return 0;
}</code></pre>
      </div>
    </article>

    <!-- 3 -->
    <article class="card" id="card-3" role="listitem" aria-labelledby="title-3">
      <h3 id="title-3">3. Smart Parking Slot Allocation</h3>
      <small>Algorithm: Hungarian Algorithm (assignment)</small>
      <p>Assign cars to parking slots minimizing total walking distance (assignment problem).</p>
      <div class="code-area" aria-live="polite">
<pre><code class="language-cpp">// Hungarian Algorithm (assignment) - 1-based internally
#include &lt;bits/stdc++.h&gt;
using namespace std;

vector<int> hungarian(const vector<vector<long long>>& a){
    int n = a.size();
    vector<long long> u(n+1), v(n+1);
    vector<int> p(n+1), way(n+1);
    for(int i=1;i<=n;++i){
        p[0]=i; int j0=0;
        vector<long long> minv(n+1, LLONG_MAX);
        vector<char> used(n+1,false);
        while(true){
            used[j0]=true;
            int i0 = p[j0]; long long delta=LLONG_MAX; int j1=0;
            for(int j=1;j<=n;++j) if(!used[j]){
                long long cur = a[i0-1][j-1]-u[i0]-v[j];
                if(cur<minv[j]){ minv[j]=cur; way[j]=j0; }
                if(minv[j]<delta){ delta=minv[j]; j1=j; }
            }
            for(int j=0;j<=n;++j){ if(used[j]){ u[p[j]]+=delta; v[j]-=delta; } else minv[j]-=delta; }
            j0=j1;
            if(p[j0]==0) break;
        }
        while(true){
            int j1=way[j0]; p[j0]=p[j1]; j0=j1; if(j0==0) break;
        }
    }
    vector<int> ans(n,-1);
    for(int j=1;j<=n;++j) if(p[j]!=0) ans[p[j]-1]=j-1;
    return ans;
}

int main(){
    // Build cost matrix and call hungarian()
    return 0;
}</code></pre>
      </div>
    </article>

    <!-- 4 -->
    <article class="card" id="card-4" role="listitem" aria-labelledby="title-4">
      <h3 id="title-4">4. Industrial vs Residential Separation</h3>
      <small>Algorithm: Graph Coloring / Bipartite check</small>
      <p>Color regions so industries do not touch residential zones — graph bipartite checks or coloring on planar graphs.</p>
      <div class="code-area" aria-live="polite">
<pre><code class="language-cpp">// Graph bipartite check (BFS)
#include &lt;bits/stdc++.h&gt;
using namespace std;

bool is_bipartite(const vector<vector<int>>& g){
    int n = g.size(); vector<int> color(n, -1);
    for(int i=0;i<n;++i){
        if(color[i]!=-1) continue;
        queue<int> q; q.push(i); color[i]=0;
        while(!q.empty()){
            int u=q.front(); q.pop();
            for(int v: g[u]){
                if(color[v]==-1){ color[v]=color[u]^1; q.push(v); }
                else if(color[v]==color[u]) return false;
            }
        }
    }
    return true;
}

int main(){ return 0; }</code></pre>
      </div>
    </article>

    <!-- 5 -->
    <article class="card" id="card-5" role="listitem" aria-labelledby="title-5">
      <h3 id="title-5">5. Public Park Placement Optimization</h3>
      <small>Algorithm: Greedy + Fenwick Tree (max coverage)</small>
      <p>Select k park sites maximizing population coverage, often solved with greedy approximation and efficient counting structures.</p>
      <div class="code-area" aria-live="polite">
<pre><code class="language-cpp">// Fenwick Tree (Binary Indexed Tree)
#include &lt;bits/stdc++.h&gt;
using namespace std;

struct Fenwick{
    int n; vector<long long> bit;
    Fenwick(int n):n(n),bit(n+1,0){}
    void add(int idx, long long val){ for(++idx; idx<=n; idx += idx & -idx) bit[idx]+=val; }
    long long sum(int idx){ long long r=0; for(++idx; idx>0; idx -= idx & -idx) r+=bit[idx]; return r; }
    long long range_sum(int l,int r){ if(r<l) return 0; return sum(r) - (l? sum(l-1):0); }
};

int main(){ return 0; }</code></pre>
      </div>
    </article>

    <!-- 6 -->
    <article class="card" id="card-6" role="listitem" aria-labelledby="title-6">
      <h3 id="title-6">6. Land Subdivision Optimization</h3>
      <small>Algorithm: Divide & Conquer / geometric utilities</small>
      <p>Divide land into balanced usable plots. Basic geometry helpers (polygon area via shoelace) are commonly used for area calculations.</p>
      <div class="code-area" aria-live="polite">
<pre><code class="language-cpp">// Polygon area via Shoelace
#include &lt;bits/stdc++.h&gt;
using namespace std;

double polygon_area(const vector<pair<double,double>>& poly){
    double s=0; int n=poly.size();
    for(int i=0;i<n;++i){
        double x1=poly[i].first, y1=poly[i].second;
        double x2=poly[(i+1)%n].first, y2=poly[(i+1)%n].second;
        s += x1*y2 - x2*y1;
    }
    return fabs(s)/2.0;
}

int main(){ return 0; }</code></pre>
      </div>
    </article>

    <!-- 7 -->
    <article class="card" id="card-7" role="listitem" aria-labelledby="title-7">
      <h3 id="title-7">7. High Footfall Commercial Zone Prediction</h3>
      <small>Algorithm: Clustering (k-means like)</small>
      <p>Predict commercial hotspots using movement density and clustering algorithms.</p>
      <div class="code-area" aria-live="polite">
<pre><code class="language-cpp">// Simple clustering logic example (k-means like)
#include &lt;bits/stdc++.h&gt;
using namespace std;

using P = pair<double,double>;
vector<vector<P>> assign_clusters(const vector<P>& points, const vector<P>& centers){
    int k = centers.size(); vector<vector<P>> clusters(k);
    for(auto &p: points){
        int best = 0; double bestd = 1e300;
        for(int i=0;i<k;++i){ double d = pow(p.first-centers[i].first,2) + pow(p.second-centers[i].second,2); if(d<bestd){ bestd=d; best=i; } }
        clusters[best].push_back(p);
    }
    return clusters;
}

int main(){ return 0; }</code></pre>
      </div>
    </article>

    <!-- 8 -->
    <article class="card" id="card-8" role="listitem" aria-labelledby="title-8">
      <h3 id="title-8">8. Creation of Green Belt Buffers</h3>
      <small>Algorithm: BFS/DFS layers on grid</small>
      <p>Form multi-zone buffer around polluted areas via BFS expansion layers (distance maps).</p>
      <div class="code-area" aria-live="polite">
<pre><code class="language-cpp">// BFS buffer layers on grid
#include &lt;bits/stdc++.h&gt;
using namespace std;

vector<vector<int>> buffer_layers(const vector<vector<int>>& grid, const vector<pair<int,int>>& sources){
    int n = grid.size(), m = grid[0].size();
    vector<vector<int>> dist(n, vector<int>(m, -1));
    deque<pair<int,int>> q;
    for(auto &s: sources){ dist[s.first][s.second]=0; q.push_back(s); }
    const int dr[4]={1,-1,0,0}; const int dc[4]={0,0,1,-1};
    while(!q.empty()){
        auto cur = q.front(); q.pop_front();
        int r=cur.first, c=cur.second;
        for(int k=0;k<4;++k){ int nr=r+dr[k], nc=c+dc[k];
            if(nr>=0 && nr<n && nc>=0 && nc<m && dist[nr][nc]==-1){ dist[nr][nc]=dist[r][c]+1; q.emplace_back(nr,nc); }
        }
    }
    return dist;
}

int main(){ return 0; }</code></pre>
      </div>
    </article>

    <!-- 9 -->
    <article class="card" id="card-9" role="listitem" aria-labelledby="title-9">
      <h3 id="title-9">9. Footpath Connectivity Plan</h3>
      <small>Algorithm: Shortest Path (Dijkstra)</small>
      <p>Model junctions as nodes and compute safe shortest routes with Dijkstra.</p>
      <div class="code-area" aria-live="polite">
<pre><code class="language-cpp">// Dijkstra Shortest Path
#include &lt;bits/stdc++.h&gt;
using namespace std;

unordered_map<int, long long> dijkstra(const unordered_map<int, vector<pair<int,long long>>>& graph, int start){
    unordered_map<int,long long> dist;
    for(auto &kv: graph) dist[kv.first] = LLONG_MAX;
    dist[start]=0;
    priority_queue<pair<long long,int>, vector<pair<long long,int>>, greater<pair<long long,int>>> pq;
    pq.push({0,start});
    while(!pq.empty()){
        auto [d,u] = pq.top(); pq.pop();
        if(d>dist[u]) continue;
        auto it = graph.find(u);
        if(it == graph.end()) continue;
        for(auto [v,w]: it->second){
            long long nd = d + w;
            if(nd < dist[v]){ dist[v]=nd; pq.push({nd,v}); }
        }
    }
    return dist;
}

int main(){ return 0; }</code></pre>
      </div>
    </article>

    <!-- 10 -->
    <article class="card" id="card-10" role="listitem" aria-labelledby="title-10">
      <h3 id="title-10">10. Underground Utility Routing</h3>
      <small>Algorithm: A* Search on grid (Manhattan heuristic)</small>
      <p>Plan underground routes avoiding obstacles using A* with a Manhattan or Euclidean heuristic.</p>
      <div class="code-area" aria-live="polite">
<pre><code class="language-cpp">// A* Search on grid (Manhattan heuristic)
#include &lt;bits/stdc++.h&gt;
using namespace std;

int heuristic(pair<int,int> a, pair<int,int> b){ return abs(a.first-b.first) + abs(a.second-b.second); }

vector<pair<int,int>> astar(const vector<vector<int>>& grid, pair<int,int> start, pair<int,int> goal){
    int n = grid.size(), m = grid[0].size();
    using Node = tuple<int,int,int,int>; // f, g, r, c
    priority_queue<Node, vector<Node>, greater<Node>> open;
    map<pair<int,int>, pair<int,int>> came_from;
    map<pair<int,int>, int> gscore;
    open.push({heuristic(start,goal), 0, start.first, start.second});
    gscore[start]=0;
    const int dr[4]={1,-1,0,0}; const int dc[4]={0,0,1,-1};
    while(!open.empty()){
        auto [f,g,r,c] = open.top(); open.pop();
        pair<int,int> cur={r,c};
        if(cur==goal){
            vector<pair<int,int>> path; auto curp=cur;
            while(came_from.count(curp)){
                path.push_back(curp); curp = came_from[curp];
            }
            path.push_back(start);
            reverse(path.begin(), path.end());
            return path;
        }
        for(int k=0;k<4;++k){ int nr=r+dr[k], nc=c+dc[k];
            if(nr>=0 && nr<n && nc>=0 && nc<m && grid[nr][nc]!=1){
                pair<int,int> nxt={nr,nc}; int tentative = g + 1;
                if(!gscore.count(nxt) || tentative < gscore[nxt]){
                    gscore[nxt]=tentative;
                    came_from[nxt]=cur;
                    open.push({tentative + heuristic(nxt,goal), tentative, nr, nc});
                }
            }
        }
    }
    return {};
}

int main(){ return 0; }</code></pre>
      </div>
    </article>

  </div> <!-- end grid -->

  <div style="text-align:center;margin-top:28px">
    <a class="btn" href="#" onclick="window.scrollTo({top:0,behavior:'smooth'});return false;">← Back to Top</a>
  </div>

  <div class="footer">
    © 2024 Tejas Keri — Portfolio
  </div>

</div>

<!-- Accessibility: focus outlines and keyboard support -->
<script>
document.addEventListener('keydown', function(e){
  // pressing '1'..'9' or '0' jumps to the card (1..10)
  if(e.key >= '0' && e.key <= '9'){
    let idx = (e.key === '0') ? 10 : Number(e.key);
    const el = document.getElementById('card-' + idx);
    if(el) el.scrollIntoView({behavior:'smooth', block:'center'});
  }
});
</script>

</body>
</html>
