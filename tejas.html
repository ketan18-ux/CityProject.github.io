<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>DAA Portfolio — Tejas B. Keri</title>

<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600;800&family=Poppins:wght@300;400;600;700&display=swap" rel="stylesheet">

<style>
body {
  margin:0; padding:0;
  font-family: Poppins, sans-serif;
  background:#fff;
}
.container {
  width:95%;
  max-width:1600px;
  margin:auto;
  padding:40px 0;
}
h1 {
  font-size:40px;
  text-align:center;
  font-weight:700;
  margin-bottom:40px;
}
.grid {
  display:grid;
  grid-template-columns:repeat(2,1fr);
  gap:30px;
}
.card {
  background:#fafafa;
  border-radius:14px;
  padding:25px;
  border:1px solid #e5e5e5;
  box-shadow:0 0 10px rgba(0,0,0,0.08);
}
.card h2 {
  font-size:28px;
  margin-bottom:15px;
  font-weight:700;
}
.section-title {
  margin-top:18px;
  font-weight:600;
  font-size:20px;
}
pre {
  background:#1e1e1e;
  color:#00ffee;
  padding:15px;
  border-radius:10px;
  overflow:auto;
  font-family:"JetBrains Mono", monospace;
  line-height:1.4;
}
.sdg-list { padding-left:20px; }
</style>
</head>

<body>
<div class="container">
<h1>Design & Analysis of Algorithms — Portfolio (10 Problems)</h1>

<div class="grid">

<!-- ===================================================== -->
<!-- =================== PROBLEM 1 ======================== -->
<!-- ===================================================== -->
<div class="card">
<h2>Problem 1 — Towers of Hanoi (Recursion)</h2>

<div class="section-title">Problem Content</div>
<p>Solve the classic Towers of Hanoi problem using recursion with minimal moves.</p>

<div class="section-title">Algorithmic Solution</div>
<p>A recursive divide-and-conquer solution moves n−1 disks to auxiliary, last disk to target, then n−1 back.</p>

<div class="section-title">Input / Output</div>
<p><b>Input:</b> n disks<br><b>Output:</b> Steps to solve</p>

<div class="section-title">SDGs</div>
<ul class="sdg-list">
<li>SDG 4 — Quality Education</li>
</ul>

<div class="section-title">C++ Code</div>
<pre>
#include &lt;iostream&gt;
using namespace std;

void hanoi(int n, char src, char aux, char dest){
    if(n==1){
        cout &lt;&lt; src &lt;&lt; " -> " &lt;&lt; dest &lt;&lt; "\n";
        return;
    }
    hanoi(n-1, src, dest, aux);
    cout &lt;&lt; src &lt;&lt; " -> " &lt;&lt; dest &lt;&lt; "\n";
    hanoi(n-1, aux, src, dest);
}

int main(){
    int n; cin >> n;
    hanoi(n,'A','B','C');
}
</pre>
</div>

<!-- ===================================================== -->
<!-- =================== PROBLEM 2 ======================== -->
<!-- ===================================================== -->
<div class="card">
<h2>Problem 2 — N-Queens (Backtracking)</h2>

<div class="section-title">Problem Content</div>
<p>Place N queens such that no queen attacks another.</p>

<div class="section-title">Algorithmic Solution</div>
<p>Backtracking explores positions row-wise and prunes invalid placements.</p>

<div class="section-title">Input / Output</div>
<p><b>Input:</b> N<br><b>Output:</b> Valid board configuration(s)</p>

<div class="section-title">SDGs</div>
<ul class="sdg-list"><li>SDG 9 — Innovation</li></ul>

<div class="section-title">C++ Code</div>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

bool safe(vector<vector<int>>&b,int r,int c,int n){
    for(int i=0;i&lt;r;i++) if(b[i][c]) return false;
    for(int i=r,j=c;i>=0 && j>=0;i--,j--) if(b[i][j]) return false;
    for(int i=r,j=c;i>=0 && j&lt;n;i--,j++) if(b[i][j]) return false;
    return true;
}

bool solve(vector<vector<int>>&b,int r,int n){
    if(r==n){
        for(auto &x:b){ for(int v:x) cout<<(v?"Q ":". "); cout<<"\n"; }
        return true;
    }
    for(int c=0;c&lt;n;c++){
        if(safe(b,r,c,n)){
            b[r][c]=1;
            if(solve(b,r+1,n)) return true;
            b[r][c]=0;
        }
    }
    return false;
}

int main(){
    int n; cin>>n;
    vector<vector<int>> b(n,vector<int>(n,0));
    solve(b,0,n);
}
</pre>
</div>

<!-- ===================================================== -->
<!-- =================== PROBLEM 3 ======================== -->
<!-- ===================================================== -->
<div class="card">
<h2>Problem 3 — Merge Sort</h2>

<div class="section-title">Problem Content</div>
<p>Sort an array using divide-and-conquer merge sort.</p>

<div class="section-title">Algorithmic Solution</div>
<p>Split, recursively sort, then merge.</p>

<div class="section-title">Input / Output</div>
<p><b>Input:</b> n and array<br><b>Output:</b> sorted array</p>

<div class="section-title">SDGs</div>
<ul class="sdg-list"><li>SDG 4 — Quality Education</li></ul>

<div class="section-title">C++ Code</div>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

void mergeArr(vector<int>&a,int l,int m,int r){
    vector<int> L(a.begin()+l, a.begin()+m+1);
    vector<int> R(a.begin()+m+1, a.begin()+r+1);
    int i=0,j=0,k=l;
    while(i&lt;L.size() && j&lt;R.size())
        a[k++] = (L[i]&lt;=R[j])?L[i++]:R[j++];
    while(i&lt;L.size()) a[k++]=L[i++];
    while(j&lt;R.size()) a[k++]=R[j++];
}

void mergeSort(vector<int>&a,int l,int r){
    if(l>=r) return;
    int m=(l+r)/2;
    mergeSort(a,l,m);
    mergeSort(a,m+1,r);
    mergeArr(a,l,m,r);
}

int main(){
    int n; cin>>n;
    vector<int>a(n);
    for(int&i:a)cin>>i;
    mergeSort(a,0,n-1);
    for(int x:a)cout<<x<<" ";
}
</pre>
</div>

<!-- ===================================================== -->
<!-- =================== PROBLEM 4 ======================== -->
<!-- ===================================================== -->
<div class="card">
<h2>Problem 4 — Binary Heap & Heap Sort</h2>

<div class="section-title">Problem Content</div>
<p>Use heap data structure to sort elements efficiently.</p>

<div class="section-title">Algorithmic Solution</div>
<p>Build max-heap, repeatedly extract max.</p>

<div class="section-title">Input / Output</div>
<p><b>Input:</b> array<br><b>Output:</b> sorted array</p>

<div class="section-title">SDGs</div>
<ul class="sdg-list"><li>SDG 9</li></ul>

<div class="section-title">C++ Code</div>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

void heapify(vector<int>&a,int n,int i){
    int largest=i,l=2*i+1,r=2*i+2;
    if(l&lt;n && a[l]>a[largest]) largest=l;
    if(r&lt;n && a[r]>a[largest]) largest=r;
    if(largest!=i){
        swap(a[i],a[largest]);
        heapify(a,n,largest);
    }
}

void heapSort(vector<int>&a){
    int n=a.size();
    for(int i=n/2-1;i>=0;i--) heapify(a,n,i);
    for(int i=n-1;i>0;i--){
        swap(a[0],a[i]);
        heapify(a,i,0);
    }
}

int main(){
    int n; cin>>n;
    vector<int>a(n); for(int&i:a)cin>>i;
    heapSort(a);
    for(int x:a)cout<<x<<" ";
}
</pre>
</div>

<!-- ===================================================== -->
<!-- =================== PROBLEM 5 ======================== -->
<!-- ===================================================== -->
<div class="card">
<h2>Problem 5 — Trie (Prefix Search)</h2>

<div class="section-title">Problem Content</div>
<p>Store strings and perform prefix search efficiently.</p>

<div class="section-title">Algorithmic Solution</div>
<p>Trie nodes store children for each character; prefix lookup is O(length).</p>

<div class="section-title">Input / Output</div>
<p><b>Input:</b> words, prefix<br><b>Output:</b> Does prefix exist?</p>

<div class="section-title">SDGs</div>
<ul class="sdg-list"><li>SDG 9</li></ul>

<div class="section-title">C++ Code</div>
<pre>
#include &lt;iostream&gt;
#include &lt;map&gt;
using namespace std;

struct Trie {
    bool end=false;
    map<char,Trie*> child;
};

void insertWord(Trie*root,string s){
    for(char c:s){
        if(!root->child[c]) root->child[c]=new Trie();
        root=root->child[c];
    }
    root->end=true;
}

bool prefix(Trie*root,string p){
    for(char c:p){
        if(!root->child[c]) return false;
        root=root->child[c];
    }
    return true;
}

int main(){
    Trie*root=new Trie();
    int n; cin>>n;
    while(n--){
        string s; cin>>s;
        insertWord(root,s);
    }
    string p; cin>>p;
    cout<<(prefix(root,p)?"YES":"NO");
}
</pre>
</div>

<!-- ===================================================== -->
<!-- =================== PROBLEM 6 ======================== -->
<!-- ===================================================== -->
<div class="card">
<h2>Problem 6 — KMP String Matching</h2>

<div class="section-title">Problem Content</div>
<p>Find pattern occurrences in a text using KMP.</p>

<div class="section-title">Algorithmic Solution</div>
<p>LPS preprocessing ensures linear-time search.</p>

<div class="section-title">Input / Output</div>
<p><b>Input:</b> text, pattern<br><b>Output:</b> indices of match</p>

<div class="section-title">SDGs</div>
<ul class="sdg-list"><li>SDG 4</li></ul>

<div class="section-title">C++ Code</div>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

vector<int> lpsBuild(string p){
    int n=p.size(),len=0,i=1;
    vector<int>lps(n,0);
    while(i<n){
        if(p[i]==p[len]) lps[i++]=++len;
        else if(len) len=lps[len-1];
        else i++;
    }
    return lps;
}

void kmp(string t,string p){
    vector<int> lps = lpsBuild(p);
    int i=0,j=0;
    while(i&lt;t.size()){
        if(t[i]==p[j]) i++,j++;
        if(j==p.size()){
            cout<<"Found at "<<i-j<<"\n";
            j=lps[j-1];
        } else if(i<t.size() && t[i]!=p[j]){
            if(j) j=lps[j-1];
            else i++;
        }
    }
}

int main(){
    string t,p; cin>>t>>p;
    kmp(t,p);
}
</pre>
</div>

<!-- ===================================================== -->
<!-- =================== PROBLEM 7 ======================== -->
<!-- ===================================================== -->
<div class="card">
<h2>Problem 7 — Dijkstra’s Algorithm</h2>

<div class="section-title">Problem Content</div>
<p>Find the shortest path in weighted graph.</p>

<div class="section-title">Algorithmic Solution</div>
<p>Greedy relaxation using min-priority queue.</p>

<div class="section-title">Input / Output</div>
<p><b>Input:</b> graph<br><b>Output:</b> distances</p>

<div class="section-title">SDGs</div>
<ul class="sdg-list"><li>SDG 9</li></ul>

<div class="section-title">C++ Code</div>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;climits&gt;
using namespace std;

int main(){
    int n,m,src; cin>>n>>m>>src;
    vector<vector<pair<int,int>>> adj(n);
    while(m--){
        int u,v,w; cin>>u>>v>>w;
        adj[u].push_back({v,w});
    }
    vector<int> dist(n,INT_MAX);
    dist[src]=0;
    priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;
    pq.push({0,src});

    while(!pq.empty()){
        auto [d,u]=pq.top(); pq.pop();
        if(d!=dist[u]) continue;
        for(auto &e:adj[u]){
            int v=e.first,w=e.second;
            if(d+w<dist[v]){
                dist[v]=d+w;
                pq.push({dist[v],v});
            }
        }
    }
    for(int d:dist) cout<<d<<" ";
}
</pre>
</div>

<!-- ===================================================== -->
<!-- =================== PROBLEM 8 ======================== -->
<!-- ===================================================== -->
<div class="card">
<h2>Problem 8 — Kruskal’s MST</h2>

<div class="section-title">Problem Content</div>
<p>Find minimum spanning tree using Union-Find.</p>

<div class="section-title">Algorithmic Solution</div>
<p>Sort edges, join smallest non-cycle edges.</p>

<div class="section-title">Input / Output</div>
<p><b>Input:</b> edges<br><b>Output:</b> MST weight</p>

<div class="section-title">SDGs</div>
<ul class="sdg-list"><li>SDG 9</li></ul>

<div class="section-title">C++ Code</div>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;

int findP(vector<int>&p,int x){
    return (p[x]==x)?x:p[x]=findP(p,p[x]);
}

int main(){
    int n,m; cin>>n>>m;
    vector<tuple<int,int,int>> e;
    while(m--){
        int u,v,w; cin>>u>>v>>w;
        e.push_back({w,u,v});
    }
    sort(e.begin(),e.end());
    vector<int> p(n);
    for(int i=0;i<n;i++) p[i]=i;

    int mst=0;
    for(auto &[w,u,v]:e){
        u=findP(p,u); v=findP(p,v);
        if(u!=v){
            mst+=w;
            p[u]=v;
        }
    }
    cout<<mst;
}
</pre>
</div>

<!-- ===================================================== -->
<!-- =================== PROBLEM 9 ======================== -->
<!-- ===================================================== -->
<div class="card">
<h2>Problem 9 — Segment Tree (Range Sum Query)</h2>

<div class="section-title">Problem Content</div>
<p>Query range sums efficiently.</p>

<div class="section-title">Algorithmic Solution</div>
<p>Segment Tree builds O(n), queries O(log n).</p>

<div class="section-title">Input / Output</div>
<p><b>Input:</b> array, queries<br><b>Output:</b> range sums</p>

<div class="section-title">SDGs</div>
<ul class="sdg-list"><li>SDG 9</li></ul>

<div class="section-title">C++ Code</div>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

vector<int> seg;

void build(vector<int>&a,int idx,int l,int r){
    if(l==r){ seg[idx]=a[l]; return; }
    int m=(l+r)/2;
    build(a,2*idx,l,m);
    build(a,2*idx+1,m+1,r);
    seg[idx]=seg[2*idx]+seg[2*idx+1];
}

int query(int idx,int l,int r,int ql,int qr){
    if(qr<l || ql>r) return 0;
    if(ql<=l && r<=qr) return seg[idx];
    int m=(l+r)/2;
    return query(2*idx,l,m,ql,qr)+query(2*idx+1,m+1,r,ql,qr);
}

int main(){
    int n; cin>>n;
    vector<int>a(n);
    for(int&i:a)cin>>i;
    seg.resize(4*n);
    build(a,1,0,n-1);
    int q; cin>>q;
    while(q--){
        int l,r; cin>>l>>r;
        cout<<query(1,0,n-1,l,r)<<"\n";
    }
}
</pre>
</div>

<!-- ===================================================== -->
<!-- =================== PROBLEM 10 ======================= -->
<!-- ===================================================== -->
<div class="card">
<h2>Problem 10 — AVL Tree (Balanced BST)</h2>

<div class="section-title">Problem Content</div>
<p>Insert keys into an AVL Tree while maintaining balance.</p>

<div class="section-title">Algorithmic Solution</div>
<p>Rotations (LL, RR, LR, RL) maintain height-balanced property.</p>

<div class="section-title">Input / Output</div>
<p><b>Input:</b> keys<br><b>Output:</b> inorder traversal</p>

<div class="section-title">SDGs</div>
<ul class="sdg-list"><li>SDG 9</li></ul>

<div class="section-title">C++ Code</div>
<pre>
#include &lt;iostream&gt;
using namespace std;

struct Node{
    int key,h;
    Node*l,*r;
    Node(int k):key(k),h(1),l(NULL),r(NULL){}
};

int height(Node*n){return n?n->h:0;}
int bal(Node*n){return height(n->l)-height(n->r);}

Node* rightR(Node*y){
    Node*x=y->l; Node*T=x->r;
    x->r=y; y->l=T;
    y->h=max(height(y->l),height(y->r))+1;
    x->h=max(height(x->l),height(x->r))+1;
    return x;
}

Node* leftR(Node*x){
    Node*y=x->r; Node*T=y->l;
    y->l=x; x->r=T;
    x->h=max(height(x->l),height(x->r))+1;
    y->h=max(height(y->l),height(y->r))+1;
    return y;
}

Node* insertAVL(Node*node,int k){
    if(!node) return new Node(k);
    if(k<node->key) node->l=insertAVL(node->l,k);
    else node->r=insertAVL(node->r,k);

    node->h=max(height(node->l),height(node->r))+1;
    int b=bal(node);

    if(b>1 && k<node->l->key) return rightR(node);
    if(b<-1 && k>node->r->key) return leftR(node);
    if(b>1 && k>node->l->key){
        node->l=leftR(node->l);
        return rightR(node);
    }
    if(b<-1 && k<node->r->key){
        node->r=rightR(node->r);
        return leftR(node);
    }
    return node;
}

void inorder(Node*n){
    if(!n)return;
    inorder(n->l);
    cout<<n->key<<" ";
    inorder(n->r);
}

int main(){
    int n; cin>>n;
    Node*root=NULL;
    while(n--){
        int k; cin>>k;
        root=insertAVL(root,k);
    }
    inorder(root);
}
</pre>
</div>

</div>
</div>
</body>
</html>
