<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>DAA Portfolio — TEJAS.B.KERI</title>

<!-- Fonts -->
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;600;800&family=Poppins:wght@300;400;600;700&display=swap" rel="stylesheet">

<!-- Prism for syntax highlighting -->
<link id="prismTheme" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>

<style>
  /* ============================
     THEME VARIABLES (dark default)
     ============================ */
  :root{
    --bg-0: #061226;
    --bg-1: #08162b;
    --panel: #0b1530;
    --muted: #9aa6bf;
    --accent: #22d3ee;
    --accent-2: #0891b2;
    --glass: rgba(255,255,255,0.03);
    --card-shadow: 0 12px 40px rgba(2,6,23,0.6);
    --radius-lg: 14px;
    --radius-xl: 20px;
    --max-width: 1180px;
  }

  /* Light mode overrides - applied to html.light */
  html.light {
    --bg-0: #f6fbff;
    --bg-1: #f1f6fb;
    --panel: #ffffff;
    --muted: #475569;
    --accent: #06b6d4;
    --accent-2: #0284c7;
    --card-shadow: 0 10px 28px rgba(16,24,40,0.06);
  }

  /* ============================
     Base & layout
     ============================ */
  html,body{
    height:100%;
    margin:0;
    font-family: "Poppins", system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    background: radial-gradient(circle at 10% 10%, var(--bg-0) 0%, var(--bg-1) 50%, var(--bg-0) 100%);
    color: #e6eef8;
    -webkit-font-smoothing:antialiased;
    -moz-osx-font-smoothing:grayscale;
    transition: background 0.35s ease, color 0.28s ease;
  }

  html.light body { color: #0b1220; }

  .container {
    max-width: var(--max-width);
    margin: 20px auto 60px;
    padding: 0 14px;
  }

  /* ============================
     Header
     ============================ */
  .top {
    margin-bottom: 18px;
    padding: 22px;
    border-radius: var(--radius-xl);
    background: linear-gradient(90deg, rgba(16,36,59,0.86), rgba(17,44,62,0.76));
    box-shadow: var(--card-shadow);
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:16px;
  }

  .brand {
    display:flex;
    gap:14px;
    align-items:center;
  }
  .logo {
    width:56px;
    height:56px;
    border-radius:14px;
    background: conic-gradient(from 180deg,#06b6d4,#22d3ee,#7c3aed,#f97316);
    display:flex;
    align-items:center;
    justify-content:center;
    font-weight:800;
    color:#021521;
    box-shadow: 0 10px 30px rgba(2,6,23,0.45);
    font-family: "Poppins", sans-serif;
  }
  .title {
    display:flex;
    flex-direction:column;
    gap:4px;
  }
  .title h1 { margin:0; font-size:20px; color:#e8fbff; letter-spacing:-0.2px; }
  .title p { margin:0; font-size:13px; color:var(--muted); }

  .badges {
    display:flex;
    gap:8px;
    flex-wrap:wrap;
    align-items:center;
  }
  .badge {
    padding:8px 12px;
    border-radius:999px;
    background: rgba(255,255,255,0.03);
    border:1px solid rgba(255,255,255,0.03);
    color:var(--muted);
    font-size:13px;
  }
  .badge strong { color:#fff; margin-right:6px; }

  .top-actions {
    display:flex;
    gap:12px;
    align-items:center;
  }
  .home-btn {
    display:inline-flex;
    align-items:center;
    gap:8px;
    padding:10px 14px;
    border-radius:999px;
    background: linear-gradient(90deg,var(--accent),var(--accent-2));
    color:#012025;
    font-weight:700;
    text-decoration:none;
    box-shadow: 0 12px 36px rgba(6,182,212,0.12);
  }

  /* ============================
     Main layout: sidebar + center
     ============================ */
  .main {
    display:flex;
    gap:20px;
    align-items:flex-start;
  }

  .sidebar {
    width: 30%;
    min-width: 260px;
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border-radius: var(--radius-lg);
    padding:16px;
    box-shadow: var(--card-shadow);
    height: 72vh;
    overflow:auto;
    border:1px solid rgba(255,255,255,0.03);
  }

  .sidebar h3 { margin:0 0 10px 0; color:#dff7ff; font-size:16px; }
  .sidebar p { color:var(--muted); font-size:13px; margin-bottom:12px; }

  .problem-item {
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
    padding:12px;
    border-radius:12px;
    background: rgba(255,255,255,0.02);
    margin-bottom:12px;
    cursor:pointer;
    color:var(--muted);
    border:1px solid rgba(255,255,255,0.02);
    transition: transform .12s ease, background .12s ease, box-shadow .12s ease;
    outline:none;
  }
  .problem-item:hover { transform: translateX(6px); background: linear-gradient(90deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01)); color:#e6f7ff; border-color: rgba(20,160,200,0.12); }
  .problem-item:focus { box-shadow: 0 0 0 6px rgba(34,211,238,0.12); transform: translateX(4px); }
  .problem-item.active { background: linear-gradient(90deg, rgba(6,182,212,0.12), rgba(7,125,170,0.07)); color: #eafcff; border-color: rgba(6,182,212,0.18); box-shadow: 0 10px 30px rgba(2,6,23,0.45); }

  .problem-left { display:flex; align-items:center; gap:12px; }
  .problem-index { font-weight:800; color:#9fe9ff; min-width:34px; text-align:center; }
  .problem-title-small { font-size:14px; font-weight:600; color:inherit; }

  /* Center panel */
  .center {
    width: 70%;
    background: linear-gradient(180deg, rgba(10,20,45,0.72), rgba(8,16,32,0.78));
    border-radius: var(--radius-lg);
    padding:20px;
    min-height:72vh;
    box-shadow: var(--card-shadow);
    border:1px solid rgba(255,255,255,0.02);
    overflow:auto;
  }
  .center .inner { max-width: 980px; margin: 0 auto; }
  .center h2 { margin:0 0 8px 0; font-size:22px; color:#e8fbff; }
  .center .desc { color:var(--muted); line-height:1.6; margin-bottom:12px; }
  .complexity { display:inline-block; margin-top:8px; padding:10px 14px; border-radius:10px; background: rgba(255,255,255,0.02); color:#d9f7ff; border:1px solid rgba(255,255,255,0.03); font-size:14px; }

  /* Welcome screen */
  .welcome {
    display:flex;
    flex-direction:column;
    gap:12px;
    animation: fadeIn .5s ease;
  }
  .welcome h2 { margin:0; font-size:26px; color:#f0fbff; }
  .welcome p { color:var(--muted); max-width:900px; }
  .welcome .steps { background: rgba(255,255,255,0.02); padding:12px; border-radius:12px; border:1px solid rgba(255,255,255,0.02); color:var(--muted); }
  .welcome .steps li { margin-bottom:6px; }

  @keyframes fadeIn { from { opacity:0; transform: translateY(8px);} to { opacity:1; transform: translateY(0);} }

  /* Code block */
  pre {
    margin-top:18px;
    border-radius:12px;
    padding:18px;
    background:#0f1724 !important;
    box-shadow: 0 10px 30px rgba(2,6,23,0.6);
    overflow:auto;
  }
  code { font-family: 'JetBrains Mono', monospace !important; font-size:13px; }

  /* Floating toggle */
  .toggle-floating {
    position: fixed;
    right:18px;
    bottom:18px;
    padding:10px 14px;
    border-radius:10px;
    background: linear-gradient(90deg,var(--accent),var(--accent-2));
    color:#001b23;
    border:none;
    cursor:pointer;
    font-weight:700;
    box-shadow: 0 12px 36px rgba(6,182,212,0.12);
    z-index:9999;
  }

  .hidden { display:none !important; }

  /* Responsive */
  @media (max-width: 980px) {
    .main { flex-direction:column; }
    .sidebar { width:100%; height:26vh; }
    .center { width:100%; height:auto; }
    .container { padding: 10px; }
  }

  /* Focus outline class toggled when tabbing */
  .using-keyboard .problem-item:focus { box-shadow: 0 0 0 6px rgba(34,211,238,0.12); }
</style>
</head>
<body>
<div class="container">

  <!-- Top header -->
  <header class="top" role="banner" aria-label="Portfolio header">
    <div class="brand">
      <div class="logo" aria-hidden="true">YN</div>
      <div class="title">
        <h1>Smart City Infrastructure & Routing Design — DAA Portfolio</h1>
        <p>Design &amp; Analysis of Algorithms — Student: <strong>TEJAS.B.KERI</strong></p>
      </div>
    </div>

    <div class="top-actions" role="navigation" aria-label="Top actions">
      <div class="badges" aria-hidden="true">
        <span class="badge"><strong>Faculty:</strong> Prakash Hegade</span>
        <span class="badge"><strong>Course:</strong> Design &amp; Analysis of Algorithms</span>
        <span class="badge"><strong>Focus:</strong> Land Use, Zoning &amp; Location Optimization Projects</span>
      </div>

      <a class="home-btn" href="index.html" title="Back to home">← Back to Home</a>
    </div>
  </header>

  <!-- Main area -->
  <div class="main" role="main">
    <!-- Sidebar (left) -->
    <aside class="sidebar" aria-label="Case study gallery">
      <h3>A. Case Study Gallery</h3>
      <p>Ten real-world inspired problems. Click any item to expand its description, time complexity and a detailed implementation.</p>

      <!-- Problem list populated by JS -->
      <div id="problemList" role="list" aria-label="Problem list">
        <!-- fallback content for no-JS -->
        <noscript>
          <ul>
            <li>1. Optimal Hospital Location</li>
            <li>2. School Allocation to Students</li>
            <li>3. Smart Parking Slot Allocation</li>
            <li>4. Industrial vs Residential Separation</li>
            <li>5. Public Park Placement Optimization</li>
            <li>6. Land Subdivision Optimization</li>
            <li>7. High Footfall Commercial Zone Prediction</li>
            <li>8. Creation of Green Belt Buffers</li>
            <li>9. Footpath Connectivity Plan</li>
            <li>10. Underground Utility Routing</li>
          </ul>
        </noscript>
      </div>
    </aside>

    <!-- Center (right) -->
    <main class="center" aria-live="polite">
      <div class="inner">
        <!-- Welcome -->
        <section id="welcome" class="welcome" aria-hidden="false">
          <h2>Welcome — Smart City DAA Portfolio</h2>
          <p>
            This portfolio contains ten algorithmic case studies focused on land use, zoning and location optimization for city design.
            Click a problem on the left to open its explanation, algorithmic approach, time complexity, and reference code.
          </p>

          <div class="steps">
            <strong>How to use:</strong>
            <ol style="margin-top:8px;">
              <li>Click any problem on the left to load its details in the center.</li>
              <li>The <strong>Time Complexity</strong> badge will show algorithmic complexity for the chosen approach.</li>
              <li>The large code block below contains a long, well-commented implementation for the selected problem.</li>
              <li>Use <strong>Esc</strong> to return to this welcome screen. Use the floating toggle to switch dark/light mode.</li>
            </ol>
          </div>

          <p style="color:var(--muted); margin-top:8px;">Tip: Use Arrow keys to focus problems, and press Enter/Space to open.</p>
        </section>

        <!-- Problem area (hidden initially) -->
        <section id="problemArea" class="hidden" aria-hidden="true">
          <div style="display:flex; align-items:center; justify-content:space-between;">
            <h2 id="problemTitle">Problem Title</h2>
            <div>
              <span id="problemComplexity" class="complexity">Time Complexity — (select a problem)</span>
              <button id="backToWelcome" class="home-btn" style="margin-left:10px; padding:8px 12px; font-size:13px;">← Back to Welcome</button>
            </div>
          </div>

          <div id="problemDesc" class="desc" style="margin-top:12px;">Problem description will appear here when you select an item from the left.</div>

          <pre><code id="problemCode" class="language-python"># Code will appear here when you select a problem.</code></pre>
        </section>
      </div>
    </main>
  </div>

  <div style="height:24px;"></div>
  <footer style="max-width:var(--max-width); margin: 0 auto; color:var(--muted); text-align:center;">
    © TEJAS.B.KERI · Design &amp; Analysis of Algorithms · Portfolio
  </footer>

</div>

<!-- Floating dark/light toggle -->
<button id="themeToggle" class="toggle-floating" aria-pressed="false">Toggle Dark / Light</button>

<script>
/* ============================
   Problems data (10 items)
   Each problem: id, title, desc, complexity, code (long)
   ============================ */

const problems = [
  {
    id: 1,
    title: "Optimal Hospital Location",
    desc: `<strong>Problem summary:</strong> Place hospitals so that the total travel distance citizens take to their nearest hospital is minimized. Use median-based placement for 1D and k-median approximations for 2D scenarios.`,
    complexity: `<strong>Time Complexity:</strong> 1D median: O(n log n). k-median approx: O(k n t) where t is iterations.`,
    code:
\`# Optimal Hospital Location — Extended Example
# 1D median solution + k-median approx (kmeans++ + iterative refinement)

import random
import math

def median_1d(points):
    pts = sorted(points)
    n = len(pts)
    if n == 0: return None
    if n % 2 == 1: return pts[n//2]
    return 0.5 * (pts[n//2 - 1] + pts[n//2])

def squared_distance(a, b):
    return (a[0]-b[0])**2 + (a[1]-b[1])**2

def kmeans_plus_plus(points, k, rng=random):
    if not points or k <= 0: return []
    centers = [rng.choice(points)]
    dists = [squared_distance(p, centers[0]) for p in points]
    for _ in range(1, k):
        total = sum(dists)
        if total == 0:
            centers.append(rng.choice(points)); continue
        r = rng.random() * total; acc = 0.0; chosen = None
        for i, val in enumerate(dists):
            acc += val
            if acc >= r: chosen = points[i]; break
        if chosen is None: chosen = rng.choice(points)
        centers.append(chosen)
        for i, p in enumerate(points):
            d = squared_distance(p, centers[-1])
            if d < dists[i]: dists[i] = d
    return centers

def assign_points(points, centers):
    clusters = [[] for _ in centers]
    for p in points:
        best_i = 0; best_d = squared_distance(p, centers[0])
        for i in range(1, len(centers)):
            d = squared_distance(p, centers[i])
            if d < best_d: best_d = d; best_i = i
        clusters[best_i].append(p)
    return clusters

def recompute_centers(clusters):
    new_centers = []
    for c in clusters:
        if not c: new_centers.append((0.0, 0.0)); continue
        sx = sum(p[0] for p in c)/len(c)
        sy = sum(p[1] for p in c)/len(c)
        new_centers.append((sx, sy))
    return new_centers

def k_median_approx(points, k=3, iterations=50):
    if not points or k <= 0: return []
    centers = kmeans_plus_plus(points, k)
    for it in range(iterations):
        clusters = assign_points(points, centers)
        new_centers = recompute_centers(clusters)
        converged = all(math.hypot(new_centers[i][0]-centers[i][0], new_centers[i][1]-centers[i][1]) <= 1e-6 for i in range(k))
        centers = new_centers
        if converged: break
    return centers

# End of example.
\`
  },

  {
    id: 2,
    title: "School Allocation to Students",
    desc: `<strong>Problem summary:</strong> Assign students to schools respecting capacity constraints and minimizing travel distance. Model as bipartite matching/max-flow and solve with Dinic for efficiency.`,
    complexity: `<strong>Time Complexity:</strong> Dinic: practical O(E sqrt(V)) for bipartite graphs.`,
    code:
\`# School Allocation — Dinic's algorithm implementation (detailed)
from collections import deque

class Dinic:
    def __init__(self, n):
        self.n = n; self.adj = [[] for _ in range(n)]

    def add_edge(self, u, v, cap):
        self.adj[u].append([v, cap, len(self.adj[v])])
        self.adj[v].append([u, 0, len(self.adj[u]) - 1])

    def bfs(self, s, t, level):
        for i in range(len(level)): level[i] = -1
        q = deque([s]); level[s] = 0
        while q:
            u = q.popleft()
            for v, cap, rev in self.adj[u]:
                if cap and level[v] < 0:
                    level[v] = level[u] + 1; q.append(v)
        return level[t] >= 0

    def send(self, u, t, f, level, it):
        if u == t: return f
        for i in range(it[u], len(self.adj[u])):
            v, cap, rev = self.adj[u][i]
            if cap and level[v] == level[u] + 1:
                pushed = self.send(v, t, min(f, cap), level, it)
                if pushed:
                    self.adj[u][i][1] -= pushed
                    self.adj[v][self.adj[u][i][2]][1] += pushed
                    return pushed
            it[u] += 1
        return 0

    def max_flow(self, s, t):
        flow = 0; level = [-1]*self.n
        while self.bfs(s, t, level):
            it = [0]*self.n
            while True:
                pushed = self.send(s, t, 10**18, level, it)
                if not pushed: break
                flow += pushed
        return flow
\`
  },

  {
    id: 3,
    title: "Smart Parking Slot Allocation",
    desc: `<strong>Problem summary:</strong> Assign cars to parking slots minimizing walking distance. Use Hungarian for exact min-cost assignment or greedy heuristics for large-scale scenarios.`,
    complexity: `<strong>Time Complexity:</strong> Hungarian: O(n^3). Greedy: O(n^2).`,
    code:
\`# Smart Parking Allocation — Hungarian algorithm (teaching implementation)
def hungarian(cost_matrix):
    n = len(cost_matrix)
    u = [0]*(n+1); v = [0]*(n+1); p = [0]*(n+1); way = [0]*(n+1)
    for i in range(1, n+1):
        p[0] = i; j0 = 0; minv = [float('inf')]*(n+1); used = [False]*(n+1)
        while True:
            used[j0] = True; i0 = p[j0]; delta = float('inf'); j1 = 0
            for j in range(1, n+1):
                if not used[j]:
                    cur = cost_matrix[i0-1][j-1] - u[i0] - v[j]
                    if cur < minv[j]: minv[j] = cur; way[j] = j0
                    if minv[j] < delta: delta = minv[j]; j1 = j
            for j in range(n+1):
                if used[j]: u[p[j]] += delta; v[j] -= delta
                else: minv[j] -= delta
            j0 = j1
            if p[j0] == 0: break
        while True:
            j1 = way[j0]; p[j0] = p[j1]; j0 = j1
            if j0 == 0: break
    assignment = [-1]*n
    for j in range(1, n+1):
        if p[j] != 0: assignment[p[j]-1] = j-1
    total_cost = -v[0]
    return assignment, total_cost
\`
  },

  {
    id: 4,
    title: "Industrial vs Residential Separation",
    desc: `<strong>Problem summary:</strong> Ensure industrial blocks do not touch residential zones by coloring/assigning zones. Check for bipartite separation; otherwise apply greedy recoloring heuristics.`,
    complexity: `<strong>Time Complexity:</strong> Bipartite check O(V+E).`,
    code:
\`# Industrial vs Residential Separation — bipartite check and greedy coloring
def is_bipartite(graph):
    color = {}
    for node in graph:
        if node in color: continue
        stack = [node]; color[node] = 0
        while stack:
            u = stack.pop()
            for v in graph[u]:
                if v not in color:
                    color[v] = color[u]^1; stack.append(v)
                elif color[v] == color[u]:
                    return False, None
    return True, color
\`
  },

  {
    id: 5,
    title: "Public Park Placement Optimization",
    desc: `<strong>Problem summary:</strong> Select park locations to maximize covered population. Use greedy max-cover and a Fenwick tree for efficient range queries.`,
    complexity: `<strong>Time Complexity:</strong> O(k * n * log n) with Fenwick updates.`,
    code:
\`# Public Park Placement Optimization — Fenwick (BIT) approach
class Fenwick:
    def __init__(self, n):
        self.n = n; self.bit = [0]*(n+1)
    def update(self, i, delta):
        while i <= self.n:
            self.bit[i] += delta; i += i & -i
    def query(self, i):
        s = 0
        while i > 0:
            s += self.bit[i]; i -= i & -i
        return s
    def range_sum(self, l, r):
        if l > r: return 0
        return self.query(r) - self.query(l-1)
\`
  },

  {
    id: 6,
    title: "Land Subdivision Optimization",
    desc: `<strong>Problem summary:</strong> Divide land into smaller usable plots optimizing area balance and accessibility using recursive partitioning (kd-like splits).`,
    complexity: `<strong>Time Complexity:</strong> Balanced partitions O(n log n).`,
    code:
\`# Land Subdivision — kd-like recursive partitions
def area_of_polygon(points):
    s = 0; n = len(points)
    for i in range(n):
        x1,y1 = points[i]; x2,y2 = points[(i+1)%n]
        s += x1*y2 - x2*y1
    return abs(s)/2.0

def split_bbox_midpoint(points, axis='x'):
    xs=[p[0] for p in points]; ys=[p[1] for p in points]
    if axis=='x':
        mid = (min(xs)+max(xs))/2.0
        left = [p for p in points if p[0] <= mid]; right = [p for p in points if p[0]>mid]
    else:
        mid = (min(ys)+max(ys))/2.0
        left = [p for p in points if p[1] <= mid]; right = [p for p in points if p[1] > mid]
    return left, right
\`
  },

  {
    id: 7,
    title: "High Footfall Commercial Zone Prediction",
    desc: `<strong>Problem summary:</strong> Predict commercial hotspots from mobility data using density clustering and top-k selection.`,
    complexity: `<strong>Time Complexity:</strong> Naive density O(n^2); use spatial indices for faster queries.`,
    code:
\`# High Footfall — density estimation + top-k extraction
import heapq, math
def euclid(a,b): return math.hypot(a[0]-b[0], a[1]-b[1])
def naive_density(points, radius):
    densities = [0]*len(points)
    for i,p in enumerate(points):
        for j,q in enumerate(points):
            if euclid(p,q) <= radius: densities[i] += 1
    return densities
\`
  },

  {
    id: 8,
    title: "Creation of Green Belt Buffers",
    desc: `<strong>Problem summary:</strong> Place green belts respecting minimum distance and land restrictions using backtracking with pruning.`,
    complexity: `<strong>Time Complexity:</strong> Backtracking worst-case O(2^n) but practical pruning helps.`,
    code:
\`# Green Belt Buffers — backtracking
def feasible(placed, candidate, min_dist):
    for p in placed:
        if abs(p - candidate) < min_dist: return False
    return True
def place_belts(candidates, min_dist):
    placed=[]; solutions=[]
    def dfs(idx):
        if idx == len(candidates): solutions.append(list(placed)); return
        dfs(idx+1)
        if feasible(placed, candidates[idx], min_dist):
            placed.append(candidates[idx]); dfs(idx+1); placed.pop()
    dfs(0); return solutions
\`
  },

  {
    id: 9,
    title: "Footpath Connectivity Plan",
    desc: `<strong>Problem summary:</strong> Detect disconnected pedestrian components, compute all-pairs shortest paths and propose links to improve connectivity (Floyd-Warshall or repeated Dijkstra).`,
    complexity: `<strong>Time Complexity:</strong> Floyd-Warshall O(V^3); Dijkstra O((V+E) log V).`,
    code:
\`# Footpath Connectivity — Floyd-Warshall & propose links
def floyd_warshall(adj):
    n = len(adj); dist=[row[:] for row in adj]
    for k in range(n):
        for i in range(n):
            for j in range(n):
                if dist[i][k] + dist[k][j] < dist[i][j]:
                    dist[i][j] = dist[i][k] + dist[k][j]
    return dist
\`
  },

  {
    id: 10,
    title: "Underground Utility Routing",
    desc: `<strong>Problem summary:</strong> Route utilities as disjoint or near-disjoint paths. Sequential Dijkstra with reservation heuristics is one practical method.`,
    complexity: `<strong>Time Complexity:</strong> Dijkstra O((V+E) log V) per commodity.`,
    code:
\`# Underground Utility Routing — sequential Dijkstra
import heapq
def dijkstra(graph, source):
    dist={node:float('inf') for node in graph}; prev={node:None for node in graph}
    dist[source]=0; pq=[(0,source)]
    while pq:
        d,u=heapq.heappop(pq)
        if d!=dist[u]: continue
        for v,w in graph[u]:
            nd=d+w
            if nd < dist[v]: dist[v]=nd; prev[v]=u; heapq.heappush(pq,(nd,v))
    return dist, prev
\`
  }
]; // end problems array

/* ============================
   DOM references
   ============================ */
const listEl = document.getElementById('problemList');
const welcomeSection = document.getElementById('welcome');
const problemArea = document.getElementById('problemArea');
const titleEl = document.getElementById('problemTitle');
const descEl = document.getElementById('problemDesc');
const complexityEl = document.getElementById('problemComplexity');
const codeEl = document.getElementById('problemCode');
const themeToggle = document.getElementById('themeToggle');
const backToWelcomeBtn = document.getElementById('backToWelcome');

/* ============================
   Helper: render sidebar with all problems visible
   ============================ */
function renderSidebar() {
  listEl.innerHTML = '';
  problems.forEach(p => {
    const el = document.createElement('div');
    el.className = 'problem-item';
    el.tabIndex = 0;
    el.role = 'button';
    el.dataset.id = p.id;
    el.innerHTML = \`
      <div class="problem-left">
        <div class="problem-index">#\${p.id}</div>
        <div class="problem-title-small">\${p.title}</div>
      </div>
      <div style="color:var(--muted); font-size:12px;">\${p.title.split(' ').slice(0,3).join(' ')}…</div>
    \`;
    el.addEventListener('click', () => openProblem(p.id));
    el.addEventListener('keydown', (ev) => {
      if (ev.key === 'Enter' || ev.key === ' ') { ev.preventDefault(); openProblem(p.id); }
    });
    listEl.appendChild(el);
  });
}

/* ============================
   Open a problem: show center + code
   ============================ */
let activeId = null;
function openProblem(id) {
  activeId = id;
  // set active class
  document.querySelectorAll('.problem-item').forEach(it => {
    it.classList.toggle('active', String(it.dataset.id) === String(id));
  });

  const p = problems.find(x => x.id === id);
  if (!p) return;

  // hide welcome
  welcomeSection.classList.add('hidden');
  // show problem area
  problemArea.classList.remove('hidden'); problemArea.setAttribute('aria-hidden','false');

  // set content
  titleEl.innerHTML = p.title;
  descEl.innerHTML = p.desc;
  complexityEl.innerHTML = p.complexity;

  // set code block text and highlight
  codeEl.textContent = p.code.trim();
  try { Prism.highlightElement(codeEl); } catch(e) {}
  // scroll center to top
  document.querySelector('.center').scrollTop = 0;
}

/* ============================
   Reset to welcome screen
   ============================ */
function resetToWelcome() {
  activeId = null;
  document.querySelectorAll('.problem-item').forEach(it => it.classList.remove('active'));
  problemArea.classList.add('hidden'); problemArea.setAttribute('aria-hidden','true');
  welcomeSection.classList.remove('hidden'); welcomeSection.setAttribute('aria-hidden','false');
}

/* ============================
   Keyboard navigation: up/down to focus sidebar
   ============================ */
document.addEventListener('keydown', (e) => {
  const items = Array.from(document.querySelectorAll('.problem-item'));
  if (!items.length) return;
  const focused = document.activeElement;
  const idx = items.indexOf(focused);

  if (e.key === 'ArrowDown') {
    e.preventDefault();
    const next = idx === -1 ? 0 : Math.min(items.length-1, idx+1);
    items[next].focus();
  } else if (e.key === 'ArrowUp') {
    e.preventDefault();
    const prev = idx === -1 ? items.length-1 : Math.max(0, idx-1);
    items[prev].focus();
  } else if (e.key === 'Escape') {
    resetToWelcome();
  }
});

/* ============================
   Theme toggle (reliable)
   - toggle class on <html> only
   - update button text and aria-pressed
   - switch Prism theme link for readability in light mode
   ============================ */
function setTheme(isLight) {
  const html = document.documentElement;
  const prismLink = document.getElementById('prismTheme');
  if (isLight) {
    html.classList.add('light');
    themeToggle.textContent = 'Switch to Dark';
    themeToggle.setAttribute('aria-pressed','true');
    // use a light prism theme (if desired). We'll leave default dark prism but adjust to tomorrow for dark
    prismLink.href = 'https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css';
  } else {
    html.classList.remove('light');
    themeToggle.textContent = 'Switch to Light';
    themeToggle.setAttribute('aria-pressed','false');
    prismLink.href = 'https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css';
  }
}

// initial theme state: dark
setTheme(false);

// toggle handler
themeToggle.addEventListener('click', () => {
  const isLight = document.documentElement.classList.toggle('light');
  setTheme(isLight);
});

/* ============================
   Back to welcome button
   ============================ */
backToWelcomeBtn.addEventListener('click', resetToWelcome);

/* ============================
   Header double-click to reset (dev convenience)
   ============================ */
document.querySelector('.title h1')?.addEventListener('dblclick', resetToWelcome);

/* ============================
   Focus ring toggle for keyboard users
   ============================ */
(function focusOutline() {
  let keyboard = false;
  window.addEventListener('keydown', (e) => {
    if (e.key === 'Tab') {
      keyboard = true;
      document.documentElement.classList.add('using-keyboard');
    }
  });
  window.addEventListener('mousedown', () => {
    if (keyboard) {
      keyboard = false;
      document.documentElement.classList.remove('using-keyboard');
    }
  });
})();

/* ============================
   Initialize UI: render sidebar and show welcome
   ============================ */
renderSidebar();
resetToWelcome();

/* ============================
   Small UX: if user reloads and had a hash like #problem/3 you could open it.
   But default behavior is to show welcome screen (no auto-open).
   ============================ */

window.addEventListener('hashchange', () => {
  const id = (location.hash.match(/problem\/(\d+)/) || [])[1];
  if (id) openProblem(Number(id));
});

</script>
</body>
</html>
