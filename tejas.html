<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>DAA Portfolio — Tejas B. Keri</title>

<!-- Fonts -->
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600;800&family=Poppins:wght@300;400;600;700&display=swap" rel="stylesheet">

<!-- Prism for syntax highlighting -->
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-clike.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-cpp.min.js"></script>

<style>
/* -----------------------------
   LIGHT THEME (ONLY)
   ----------------------------- */
:root{
  --bg: #f4f7fb;
  --panel: #ffffff;
  --muted: #475569;
  --accent: #0ea5e9;
  --accent-2: #0284c7;
  --glass: rgba(2,6,23,0.04);
  --card-shadow: 0 8px 22px rgba(16,24,40,0.08);
  --radius: 14px;
  --trans-fast: 160ms;
  --trans: 220ms;
  --trans-slow: 360ms;
  --glow: 0 8px 24px rgba(14,165,233,0.06);
  --text: #0f1724;
  --muted-2: #6b7280;
  --code-bg: #0f1724;
  --code-text: #cbeefc;
}

/* -----------------------------
   BASE PAGE
   ----------------------------- */
html,body{
  height:100%;
  margin:0;
  font-family: "Poppins", system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  background: linear-gradient(180deg, #f7fbfd 0%, #f4f7fb 100%);
  color: var(--text);
  transition: background var(--trans-slow) ease, color var(--trans-slow) ease;
  -webkit-font-smoothing:antialiased;
  -moz-osx-font-smoothing:grayscale;
  line-height:1.45;
  -webkit-tap-highlight-color: transparent;
  padding: 18px 12px;
  box-sizing: border-box;
}

/* -----------------------------
   HEADER
   ----------------------------- */
.top {
  max-width:1200px;
  margin: 10px auto;
  padding:18px;
  border-radius:18px;
  background: linear-gradient(90deg, rgba(255,255,255,0.9) 0%, rgba(250,250,250,0.9) 100%);
  box-shadow: var(--card-shadow);
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:20px;
}
.top-left h1{ margin:0; font-size:20px; color:var(--text); letter-spacing: -0.2px; }
.badges{ display:flex; gap:8px; flex-wrap:wrap; margin-top:8px; }
.badge{
  background: rgba(2,6,23,0.03);
  border:1px solid rgba(2,6,23,0.04);
  padding:6px 10px;
  font-size:12px;
  color:var(--muted-2);
  border-radius:999px;
}
.badge strong{ color:var(--text); margin-right:6px; font-weight:600; }
.top-right{ display:flex; align-items:center; gap:14px; }
.home-btn{
  padding:10px 16px;
  background:linear-gradient(90deg,var(--accent),var(--accent-2));
  color:white;
  font-weight:700;
  border-radius:999px;
  text-decoration:none;
  box-shadow: 0 6px 18px rgba(2, 27, 37, 0.08);
}

/* -----------------------------
   LAYOUT
   ----------------------------- */
.wrapper {
  max-width:1200px;
  margin: 18px auto 60px;
  display:flex;
  gap:20px;
  align-items:start;
  padding: 0 12px;
}
@media (max-width: 980px){
  .wrapper { flex-direction: column; padding: 0 8px; }
}

/* -----------------------------
   SIDEBAR (modern, collapsible)
   ----------------------------- */
.sidebar {
  width: 360px;
  min-width: 240px;
  max-width: 380px;
  background: linear-gradient(180deg, rgba(255,255,255,0.95), rgba(255,255,255,0.98));
  border-radius: var(--radius);
  padding: 12px;
  height: 78vh;
  overflow:auto;
  box-shadow: var(--card-shadow);
  position: relative;
  transition: width var(--trans);
  display:flex;
  flex-direction:column;
  gap:8px;
}

.sidebar.collapsed {
  width: 68px;
  padding-left: 10px;
  padding-right: 10px;
}

.sidebar .sidebar-top {
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
}
.collapse-btn {
  border:0;
  background:transparent;
  padding:8px;
  border-radius:10px;
  cursor:pointer;
  display:inline-flex;
  align-items:center;
  justify-content:center;
}
.collapse-btn:focus { outline:2px solid rgba(14,165,233,0.18); }

/* search and controls */
.controls {
  display:flex;
  gap:8px;
  align-items:center;
  margin-bottom:6px;
}
.search {
  flex:1;
  display:flex;
  align-items:center;
  gap:8px;
  background: rgba(2,6,23,0.04);
  padding:8px 10px;
  border-radius:999px;
  border:1px solid rgba(2,6,23,0.03);
  color:var(--muted-2);
}
.search input{
  background:transparent;
  border:0;
  outline:0;
  color:inherit;
  width:100%;
  font-size:13px;
}
.count-pill {
  font-size:13px;
  color:var(--muted-2);
  padding:6px 10px;
  border-radius:8px;
  background: rgba(2,6,23,0.03);
  white-space:nowrap;
}

/* force single column list of cards */
.cards-list{
  display:grid;
  grid-template-columns: 1fr; /* SINGLE COLUMN */
  gap:12px;
  margin-top:6px;
}

/* -----------------------------
   PROBLEM CARD (single-row, elevated)
   ----------------------------- */
.problem-card{
  background: linear-gradient(180deg, rgba(250,250,250,0.95), rgba(248,248,249,0.98));
  border-radius:12px;
  padding:12px;
  cursor:pointer;
  color:var(--muted-2);
  transition: transform var(--trans) cubic-bezier(.2,.9,.3,1), box-shadow var(--trans), background var(--trans);
  border:1px solid rgba(2,6,23,0.03);
  display:flex;
  gap:12px;
  align-items:flex-start;
  min-height:86px;
  position:relative;
  overflow:hidden;
  outline: none;
}
.problem-card .index {
  min-width:44px;
  height:44px;
  border-radius:10px;
  display:flex;
  align-items:center;
  justify-content:center;
  font-weight:700;
  font-family:"JetBrains Mono", monospace;
  color:var(--accent-2);
  background: linear-gradient(180deg, rgba(14,165,233,0.08), rgba(14,165,233,0.04));
  border:1px solid rgba(14,165,233,0.06);
  box-shadow: var(--glow);
  flex-shrink:0;
}
.problem-card .body {
  flex:1;
  display:flex;
  flex-direction:column;
  gap:6px;
}
.problem-card h4{ margin:0; font-size:15px; color:var(--text); line-height:1.1; }
.problem-card .meta {
  font-size:13px;
  color:var(--muted-2);
  display:flex;
  justify-content:space-between;
  gap:8px;
  align-items:center;
}
.problem-card .preview {
  margin-top:6px;
  font-family: "JetBrains Mono", monospace;
  font-size:12px;
  color:var(--muted-2);
  background: rgba(2,6,23,0.02);
  padding:8px 10px;
  border-radius:8px;
  max-width:100%;
  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;
}
.problem-card .sdg-chips {
  display:flex;
  gap:6px;
  flex-wrap:wrap;
  margin-top:6px;
}
.sdg-chip {
  background: rgba(14,165,233,0.08);
  color: #035d73;
  padding:4px 8px;
  font-size:11px;
  border-radius:999px;
  border:1px solid rgba(14,165,233,0.06);
}

/* hover lift + glow */
.problem-card:hover{
  transform: translateY(-6px);
  box-shadow: 0 12px 28px rgba(16,24,40,0.08);
  background: linear-gradient(180deg, rgba(255,255,255,0.98), rgba(250,250,251,0.98));
  color:var(--text);
}
.problem-card:active{
  transform: translateY(-2px) scale(0.998);
}

/* active card indicator */
.problem-card.active {
  box-shadow: 0 16px 36px rgba(16,24,40,0.10);
  border: 1px solid rgba(14,165,233,0.10);
  background: linear-gradient(90deg, rgba(14,165,233,0.03), rgba(2,132,199,0.02));
  color:var(--text);
}

/* collapsed state small elements */
.sidebar.collapsed .body { display:none; }
.sidebar.collapsed .sdg-chips { display:none; }
.sidebar.collapsed .preview { display:none; }
.sidebar.collapsed .meta small { display:none; }
.sidebar.collapsed .index { min-width:40px; height:40px; }

/* -----------------------------
   CENTER PANEL (DETAILS + CODE)
   ----------------------------- */
.center{
  flex:1;
  background: var(--panel);
  border-radius:var(--radius);
  padding:22px;
  min-height:72vh;
  overflow:auto;
  box-shadow:var(--card-shadow);
}
.center h2{ margin-top:0; font-size:20px; color:var(--text); }
.center .desc { color:var(--muted-2); margin:10px 0 12px; font-size:14px; }
.center .complexity { font-size:13px; color:var(--muted-2); margin-bottom:14px; }
.center .sdg-row { display:flex; gap:8px; flex-wrap:wrap; margin-bottom:14px; }
.center .sdg-row .sdg-chip { background: rgba(14,165,233,0.09); color:#034e5a; padding:6px 10px; font-size:12px; border-radius:999px; border:1px solid rgba(14,165,233,0.08); }
pre { background: var(--code-bg) !important; padding:18px; border-radius:12px; overflow:auto; color:var(--code-text); }
code { font-family:"JetBrains Mono", monospace; font-size:14px; display:block; white-space:pre; color:var(--code-text); }

/* small responsive tweaks */
@media (max-width: 880px){
  .sidebar { width: 100%; max-width: none; min-width: auto; height: auto; order: 2; }
  .center { order: 1; }
  .wrapper { gap:12px; }
}
@media (max-width: 520px){
  .sidebar.collapsed { width: 56px; }
  .problem-card { min-height:72px; padding:10px; gap:8px; }
}

/* accessibility helper */
.sr-only{
  position:absolute!important;
  height:1px;width:1px;
  overflow:hidden;clip:rect(1px,1px,1px,1px);white-space:nowrap;border:0;padding:0;margin:-1px;
}

/* small icon style */
.icon {
  width:18px; height:18px; display:inline-block; vertical-align:middle;
}
</style>
</head>

<body>

<!-- HEADER -->
<div class="top" role="banner">
  <div class="top-left">
    <h1>Smart City Infrastructure & Routing Design — DAA Portfolio</h1>
    <div class="badges" aria-hidden="true">
      <span class="badge"><strong>Student:</strong> TEJAS.B.KERI</span>
      <span class="badge"><strong>Faculty:</strong> Prakash Hegade</span>
      <span class="badge"><strong>Course:</strong> Design & Analysis of Algorithms</span>
      <span class="badge"><strong>Focus:</strong> Land Use & Location Optimization</span>
    </div>
  </div>
  <div class="top-right">
    <span class="meta-pill">2024 · DAA City Design</span>
    <a class="home-btn" href="#">← Back to Home</a>
  </div>
</div>

<!-- MAIN WRAPPER -->
<div class="wrapper" role="main" aria-live="polite">

  <!-- SIDEBAR -->
  <aside id="sidebar" class="sidebar" aria-label="Problem gallery">
    <div class="sidebar-top">
      <div style="display:flex;gap:8px;align-items:center;">
        <button id="collapseBtn" class="collapse-btn" title="Collapse sidebar" aria-pressed="false" aria-label="Collapse sidebar">
          <!-- hamburger icon -->
          <svg class="icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
            <path d="M4 6h16M4 12h12M4 18h16" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        </button>
        <div>
          <strong style="font-size:13px;color:var(--text);display:block">A. Case Study Gallery</strong>
          <small style="color:var(--muted-2);font-size:12px">Click a card to view description, SDGs & code</small>
        </div>
      </div>
      <div class="count-pill" id="count">10 items</div>
    </div>

    <div class="controls" aria-hidden="false">
      <div class="search" role="search" aria-label="Search problems">
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" aria-hidden="true" style="opacity:0.9"><path d="M21 21l-4.35-4.35" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/></svg>
        <input id="searchInput" type="text" placeholder="Search problems (title, id, SDG)..." aria-label="Search problems" />
      </div>
    </div>

    <div id="problemList" class="cards-list" tabindex="0" role="list"></div>
  </aside>

  <!-- CENTER content -->
  <main class="center" id="center" tabindex="0" role="main">
    <h2 id="problemTitle">Select a problem from the left</h2>
    <div class="desc" id="problemDesc">Click a problem card to view the explanation.</div>
    <div class="sdg-row" id="problemSdgs" aria-hidden="true"></div>
    <div class="complexity" id="problemComplexity">Time Complexity — (select a problem)</div>
    <pre aria-live="polite" id="codeBlock"><code id="problemCode" class="language-cpp">// Code will appear here.</code></pre>
  </main>
</div>

<script>
/* ----------------------------------------------------
   PROBLEM DATA (kept intact - C++ code answers)
---------------------------------------------------- */
const problems = [
  {
    id: 1,
    title: "Optimal Hospital Location",
    desc: "Place hospitals so that the total distance citizens travel is minimized.",
    complexity: "O(n log n) using median method; O(knt) for k-median clustering.",
    sdgs: ["SDG 3: Good Health", "SDG 9: Industry & Infrastructure", "SDG 11: Sustainable Cities", "SDG 10: Reduced Inequalities"],
    code: `// Hospital Location (1D median)
#include <bits/stdc++.h>
using namespace std;

double median_1d(vector<long long> pts){
    sort(pts.begin(), pts.end());
    int n = pts.size();
    if(n % 2 == 1) return pts[n/2];
    return (pts[n/2 - 1] + pts[n/2]) / 2.0;
}

int main(){
    vector<long long> pts = {1,5,9,3,8};
    cout << "Median: " << median_1d(pts) << '\\n';
    return 0;
}`
  },
  {
    id: 2,
    title: "School Allocation to Students",
    desc: "Assign students to the nearest school under capacity constraints using Max-Flow.",
    complexity: "O(E sqrt(V)) using Dinic’s Algorithm.",
    sdgs: ["SDG 4: Quality Education", "SDG 10: Reduced Inequalities", "SDG 11: Sustainable Cities"],
    code: `// Dinic's Algorithm (C++)
#include <bits/stdc++.h>
using namespace std;

struct Edge{int to; long long cap; int rev;};
struct Dinic {
    int n; vector<vector<Edge>> g; vector<int> level, it;
    Dinic(int n):n(n),g(n),level(n),it(n){}
    void add_edge(int u,int v,long long c){
        g[u].push_back({v,c,(int)g[v].size()});
        g[v].push_back({u,0,(int)g[u].size()-1});
    }
    bool bfs(int s,int t){
        fill(level.begin(), level.end(), -1);
        queue<int>q; level[s]=0; q.push(s);
        while(!q.empty()){
            int u=q.front(); q.pop();
            for(auto &e:g[u]) if(e.cap>0 && level[e.to]==-1){ level[e.to]=level[u]+1; q.push(e.to); }
        }
        return level[t]!=-1;
    }
    long long dfs(int u,int t,long long f){
        if(u==t) return f;
        for(int &i=it[u]; i<(int)g[u].size(); ++i){
            Edge &e = g[u][i];
            if(e.cap>0 && level[e.to]==level[u]+1){
                long long ret = dfs(e.to,t,min(f,e.cap));
                if(ret>0){ e.cap -= ret; g[e.to][e.rev].cap += ret; return ret; }
            }
        }
        return 0;
    }
    long long max_flow(int s,int t){
        long long flow=0;
        while(bfs(s,t)){
            fill(it.begin(), it.end(), 0);
            while(true){ long long f = dfs(s,t,LLONG_MAX); if(f==0) break; flow+=f; }
        }
        return flow;
    }
};

int main(){
    // Example usage: build network and call max_flow
    return 0;
}`
  },
  {
    id: 3,
    title: "Smart Parking Slot Allocation",
    desc: "Assign cars to slots minimizing walking distance using Hungarian Algorithm.",
    complexity: "O(n^3)",
    sdgs: ["SDG 11: Sustainable Cities", "SDG 9: Industry & Infrastructure", "SDG 13: Climate Action"],
    code: `// Hungarian Algorithm (assignment) - 1-based internally
#include <bits/stdc++.h>
using namespace std;

vector<int> hungarian(const vector<vector<long long>>& a){
    int n = a.size();
    vector<long long> u(n+1), v(n+1);
    vector<int> p(n+1), way(n+1);
    for(int i=1;i<=n;++i){
        p[0]=i; int j0=0;
        vector<long long> minv(n+1, LLONG_MAX);
        vector<char> used(n+1,false);
        while(true){
            used[j0]=true;
            int i0 = p[j0]; long long delta=LLONG_MAX; int j1=0;
            for(int j=1;j<=n;++j) if(!used[j]){
                long long cur = a[i0-1][j-1]-u[i0]-v[j];
                if(cur<minv[j]){ minv[j]=cur; way[j]=j0; }
                if(minv[j]<delta){ delta=minv[j]; j1=j; }
            }
            for(int j=0;j<=n;++j){ if(used[j]){ u[p[j]]+=delta; v[j]-=delta; } else minv[j]-=delta; }
            j0=j1;
            if(p[j0]==0) break;
        }
        while(true){
            int j1=way[j0]; p[j0]=p[j1]; j0=j1; if(j0==0) break;
        }
    }
    vector<int> ans(n,-1);
    for(int j=1;j<=n;++j) if(p[j]!=0) ans[p[j]-1]=j-1;
    return ans;
}

int main(){
    // Build cost matrix and call hungarian()
    return 0;
}`
  },
  {
    id: 4,
    title: "Industrial vs Residential Separation",
    desc: "Color blocks ensuring industries do not touch residential regions.",
    complexity: "O(V+E) for bipartite check.",
    sdgs: ["SDG 11: Sustainable Cities", "SDG 3: Good Health", "SDG 12: Responsible Consumption"],
    code: `// Graph bipartite check (BFS)
#include <bits/stdc++.h>
using namespace std;

bool is_bipartite(const vector<vector<int>>& g){
    int n = g.size(); vector<int> color(n, -1);
    for(int i=0;i<n;++i){
        if(color[i]!=-1) continue;
        queue<int> q; q.push(i); color[i]=0;
        while(!q.empty()){
            int u=q.front(); q.pop();
            for(int v: g[u]){
                if(color[v]==-1){ color[v]=color[u]^1; q.push(v); }
                else if(color[v]==color[u]) return false;
            }
        }
    }
    return true;
}

int main(){ return 0; }`
  },
  {
    id: 5,
    title: "Public Park Placement Optimization",
    desc: "Select park sites to maximize population coverage using greedy + Fenwick Tree.",
    complexity: "O(k n log n)",
    sdgs: ["SDG 11: Sustainable Cities", "SDG 3: Good Health", "SDG 15: Life on Land"],
    code: `// Fenwick Tree (Binary Indexed Tree)
#include <bits/stdc++.h>
using namespace std;

struct Fenwick{
    int n; vector<long long> bit;
    Fenwick(int n):n(n),bit(n+1,0){}
    void add(int idx, long long val){ for(++idx; idx<=n; idx += idx & -idx) bit[idx]+=val; }
    long long sum(int idx){ long long r=0; for(++idx; idx>0; idx -= idx & -idx) r+=bit[idx]; return r; }
    long long range_sum(int l,int r){ if(r<l) return 0; return sum(r) - (l? sum(l-1):0); }
};

int main(){ return 0; }`
  },
  {
    id: 6,
    title: "Land Subdivision Optimization",
    desc: "Divide land into balanced subplots using recursive kd-like partitioning.",
    complexity: "O(n log n)",
    sdgs: ["SDG 11: Sustainable Cities", "SDG 15: Life on Land", "SDG 8: Decent Work"],
    code: `// Polygon area via Shoelace
#include <bits/stdc++.h>
using namespace std;

double polygon_area(const vector<pair<double,double>>& poly){
    double s=0; int n=poly.size();
    for(int i=0;i<n;++i){
        double x1=poly[i].first, y1=poly[i].second;
        double x2=poly[(i+1)%n].first, y2=poly[(i+1)%n].second;
        s += x1*y2 - x2*y1;
    }
    return fabs(s)/2.0;
}

int main(){ return 0; }`
  },
  {
    id: 7,
    title: "High Footfall Commercial Zone Prediction",
    desc: "Predict high footfall zones using clustering + movement density.",
    complexity: "O(nk) per iteration",
    sdgs: ["SDG 8: Decent Work & Economic Growth", "SDG 11: Sustainable Cities", "SDG 9: Industry & Innovation"],
    code: `// Simple clustering logic example (k-means like)
#include <bits/stdc++.h>
using namespace std;

using P = pair<double,double>;
vector<vector<P>> assign_clusters(const vector<P>& points, const vector<P>& centers){
    int k = centers.size(); vector<vector<P>> clusters(k);
    for(auto &p: points){
        int best = 0; double bestd = 1e300;
        for(int i=0;i<k;++i){ double d = pow(p.first-centers[i].first,2) + pow(p.second-centers[i].second,2); if(d<bestd){ bestd=d; best=i; } }
        clusters[best].push_back(p);
    }
    return clusters;
}

int main(){ return 0; }`
  },
  {
    id: 8,
    title: "Creation of Green Belt Buffers",
    desc: "Use BFS/DFS layers to form multi-zone buffer around polluted areas.",
    complexity: "O(V+E)",
    sdgs: ["SDG 3: Good Health", "SDG 11: Sustainable Cities", "SDG 13: Climate Action", "SDG 15: Life on Land"],
    code: `// BFS buffer layers on grid
#include <bits/stdc++.h>
using namespace std;

vector<vector<int>> buffer_layers(const vector<vector<int>>& grid, const vector<pair<int,int>>& sources){
    int n = grid.size(), m = grid[0].size();
    vector<vector<int>> dist(n, vector<int>(m, -1));
    deque<pair<int,int>> q;
    for(auto &s: sources){ dist[s.first][s.second]=0; q.push_back(s); }
    const int dr[4]={1,-1,0,0}; const int dc[4]={0,0,1,-1};
    while(!q.empty()){
        auto cur = q.front(); q.pop_front();
        int r=cur.first, c=cur.second;
        for(int k=0;k<4;++k){ int nr=r+dr[k], nc=c+dc[k];
            if(nr>=0 && nr<n && nc>=0 && nc<m && dist[nr][nc]==-1){ dist[nr][nc]=dist[r][c]+1; q.emplace_back(nr,nc); }
        }
    }
    return dist;
}

int main(){ return 0; }`
  },
  {
    id: 9,
    title: "Footpath Connectivity Plan",
    desc: "Model nodes as junctions and compute shortest safe routes.",
    complexity: "Dijkstra — O(E log V)",
    sdgs: ["SDG 11: Sustainable Cities", "SDG 3: Good Health", "SDG 9: Industry & Infrastructure"],
    code: `// Dijkstra Shortest Path
#include <bits/stdc++.h>
using namespace std;

unordered_map<int, long long> dijkstra(const unordered_map<int, vector<pair<int,long long>>>& graph, int start){
    unordered_map<int,long long> dist;
    for(auto &kv: graph) dist[kv.first] = LLONG_MAX;
    dist[start]=0;
    priority_queue<pair<long long,int>, vector<pair<long long,int>>, greater<pair<long long,int>>> pq;
    pq.push({0,start});
    while(!pq.empty()){
        auto [d,u] = pq.top(); pq.pop();
        if(d>dist[u]) continue;
        auto it = graph.find(u);
        if(it == graph.end()) continue;
        for(auto [v,w]: it->second){
            long long nd = d + w;
            if(nd < dist[v]){ dist[v]=nd; pq.push({nd,v}); }
        }
    }
    return dist;
}

int main(){ return 0; }`
  },
  {
    id: 10,
    title: "Underground Utility Routing",
    desc: "Plan underground cables avoiding obstacles using A*.",
    complexity: "O(E log V)",
    sdgs: ["SDG 9: Industry & Infrastructure", "SDG 11: Sustainable Cities", "SDG 6: Clean Water & Sanitation"],
    code: `// A* Search on grid (Manhattan heuristic)
#include <bits/stdc++.h>
using namespace std;

int heuristic(pair<int,int> a, pair<int,int> b){ return abs(a.first-b.first) + abs(a.second-b.second); }

vector<pair<int,int>> astar(const vector<vector<int>>& grid, pair<int,int> start, pair<int,int> goal){
    int n = grid.size(), m = grid[0].size();
    using Node = tuple<int,int,int,int>; // f, g, r, c
    priority_queue<Node, vector<Node>, greater<Node>> open;
    map<pair<int,int>, pair<int,int>> came_from;
    map<pair<int,int>, int> gscore;
    open.push({heuristic(start,goal), 0, start.first, start.second});
    gscore[start]=0;
    const int dr[4]={1,-1,0,0}; const int dc[4]={0,0,1,-1};
    while(!open.empty()){
        auto [f,g,r,c] = open.top(); open.pop();
        pair<int,int> cur={r,c};
        if(cur==goal){
            vector<pair<int,int>> path; auto curp=cur;
            while(came_from.count(curp)){
                path.push_back(curp); curp = came_from[curp];
            }
            path.push_back(start);
            reverse(path.begin(), path.end());
            return path;
        }
        for(int k=0;k<4;++k){ int nr=r+dr[k], nc=c+dc[k];
            if(nr>=0 && nr<n && nc>=0 && nc<m && grid[nr][nc]!=1){
                pair<int,int> nxt={nr,nc}; int tentative = g + 1;
                if(!gscore.count(nxt) || tentative < gscore[nxt]){
                    gscore[nxt]=tentative;
                    came_from[nxt]=cur;
                    open.push({tentative + heuristic(nxt,goal), tentative, nr, nc});
                }
            }
        }
    }
    return {};
}
int main(){ return 0; }`
  },
  {

int main(){ return 0; }`
  }
];

/* ----------------------------------------------------
   Utilities & DOM refs
---------------------------------------------------- */
const listEl = document.getElementById('problemList');
const centerTitle = document.getElementById('problemTitle');
const centerDesc = document.getElementById('problemDesc');
const centerComplexity = document.getElementById('problemComplexity');
const centerCode = document.getElementById('problemCode');
const centerSdgs = document.getElementById('problemSdgs');
const countEl = document.getElementById('count');
const searchInput = document.getElementById('searchInput');
const sidebar = document.getElementById('sidebar');
const collapseBtn = document.getElementById('collapseBtn');

let currentId = null;

function escapeHtml(s){
  return String(s)
    .replace(/&/g,'&amp;')
    .replace(/</g,'&lt;')
    .replace(/>/g,'&gt;');
}

// show first two non-empty trimmed lines as preview
function previewCode(codeStr){
  const lines = String(codeStr||'')
    .split('\n')
    .map(l=>l.replace(/\t/g,'    ').trim())
    .filter(l => l.length > 0);
  let out = lines.slice(0,2).join(' ⸱ ');
  if(out.length > 90) out = out.slice(0,87) + '...';
  return escapeHtml(out) || '';
}

function createCardEl(p) {
  const btn = document.createElement('button');
  btn.type = "button";
  btn.className = 'problem-card';
  btn.setAttribute('data-id', p.id);
  btn.setAttribute('aria-pressed', 'false');
  btn.setAttribute('title', p.title);
  btn.setAttribute('role', 'listitem');

  // ensure SDG chips are safe
  const sdgHtml = (p.sdgs || []).map(s => `<span class="sdg-chip">${escapeHtml(s)}</span>`).join(' ');

  btn.innerHTML = `
    <div class="index" aria-hidden="true">${p.id}</div>
    <div class="body">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <h4>${escapeHtml(p.title)}</h4>
        <div class="meta" aria-hidden="true">
          <small>${escapeHtml((p.complexity||'').split(';')[0])}</small>
        </div>
      </div>
      <div class="meta">${escapeHtml(p.desc)}</div>
      <div class="sdg-chips">${sdgHtml}</div>
      <div class="preview" aria-hidden="true">${previewCode(p.code)}</div>
    </div>
  `;

  btn.addEventListener('click', () => loadProblem(p.id, true));
  btn.addEventListener('keydown', (ev) => {
    if (ev.key === 'Enter' || ev.key === ' ') {
      ev.preventDefault();
      loadProblem(p.id, true);
    }
  });
  return btn;
}

function renderCards(items){
  listEl.innerHTML = '';
  const frag = document.createDocumentFragment();
  items.forEach(p => {
    frag.appendChild(createCardEl(p));
  });
  listEl.appendChild(frag);
  countEl.innerText = `${items.length} items`;
}

function clearCenter(){
  centerTitle.innerText = "Select a problem from the left";
  centerDesc.innerText = "Click a problem card to view the explanation.";
  centerComplexity.innerText = "Time Complexity — (select a problem)";
  centerCode.textContent = "// Code will appear here.";
  centerSdgs.innerHTML = '';
  currentId = null;
}

// load into center panel and highlight
function loadProblem(id, focusCenter=false){
  const p = problems.find(x => x.id === id);
  if(!p) return;
  currentId = id;
  centerTitle.innerText = p.title;
  centerDesc.innerText = p.desc;
  centerComplexity.innerText = p.complexity;
  // Use textContent to avoid executing any HTML inside code sample
  centerCode.textContent = p.code;

  // Try safe Prism highlight if available
  try {
    if(window.Prism && typeof Prism.highlightElement === 'function'){
      Prism.highlightElement(centerCode);
    }
  } catch (e) {
    // silently ignore highlighting errors
    console.warn('Prism highlight failed', e);
  }

  // SDGs in center
  centerSdgs.innerHTML = '';
  if(p.sdgs && p.sdgs.length){
    p.sdgs.forEach(s => {
      const span = document.createElement('span');
      span.className = 'sdg-chip';
      span.innerText = s;
      centerSdgs.appendChild(span);
    });
    centerSdgs.setAttribute('aria-hidden','false');
  } else {
    centerSdgs.setAttribute('aria-hidden','true');
  }

  // active styling
  document.querySelectorAll('.problem-card').forEach(el => {
    const elId = Number(el.getAttribute('data-id'));
    if(elId === id){
      el.classList.add('active');
      el.setAttribute('aria-pressed', 'true');
      // Scroll into view without heavy animation to avoid layout jank
      try { el.scrollIntoView({ block: 'nearest', behavior: 'smooth' }); } catch(e){ el.scrollIntoView(false); }
      // focus the card for accessibility, but prevent scrolling (we already scrolled)
      try { el.focus({preventScroll:true}); } catch(e){ el.focus(); }
    } else {
      el.classList.remove('active');
      el.setAttribute('aria-pressed', 'false');
    }
  });

  if(focusCenter){
    try { document.getElementById('center').focus({preventScroll:true}); } catch(e){ document.getElementById('center').focus(); }
  }
}

/* -------------------------
   SEARCH & FILTER (includes SDGs)
------------------------- */
function filter(q){
  const term = String(q||'').trim().toLowerCase();
  if(!term){
    renderCards(problems);
    return;
  }
  const filtered = problems.filter(p => {
    const sdgText = (p.sdgs || []).join(' ');
    const s = `${p.id} ${p.title} ${p.desc} ${p.complexity} ${sdgText}`.toLowerCase();
    return s.includes(term);
  });
  renderCards(filtered);

  if(currentId){
    const exists = filtered.some(p => p.id === currentId);
    if(!exists) clearCenter();
  }
}

function debounce(fn, wait=180){
  let t;
  return (...args) => {
    clearTimeout(t);
    t = setTimeout(()=>fn(...args), wait);
  };
}

/* -------------------------
   KEYBOARD NAVIGATION (Up/Down)
------------------------- */
document.addEventListener('keydown', (ev) => {
  if(['ArrowDown','ArrowUp'].indexOf(ev.key) === -1) return;
  const cards = Array.from(document.querySelectorAll('.problem-card'));
  if(cards.length === 0) return;
  let idx = cards.findIndex(c => Number(c.getAttribute('data-id')) === currentId);
  if(idx === -1) {
    // If none selected, start at first for ArrowDown, last for ArrowUp
    idx = (ev.key === 'ArrowDown') ? -1 : 0;
  }
  if(ev.key === 'ArrowDown') idx = Math.min(cards.length - 1, idx + 1);
  if(ev.key === 'ArrowUp') idx = Math.max(0, idx - 1);
  const next = cards[idx];
  if(next){
    const id = Number(next.getAttribute('data-id'));
    loadProblem(id, true);
  }
});

/* -------------------------
   SIDEBAR COLLAPSE
------------------------- */
function setCollapsed(collapsed){
  if(collapsed){
    sidebar.classList.add('collapsed');
    collapseBtn.setAttribute('aria-pressed','true');
    collapseBtn.title = "Expand sidebar";
  } else {
    sidebar.classList.remove('collapsed');
    collapseBtn.setAttribute('aria-pressed','false');
    collapseBtn.title = "Collapse sidebar";
  }
  // persist preference to localStorage (optional)
  try { localStorage.setItem('daasidebar_collapsed', collapsed ? '1' : '0'); } catch(e){}
}

collapseBtn.addEventListener('click', () => {
  const collapsed = sidebar.classList.contains('collapsed');
  setCollapsed(!collapsed);
});

// restore collapsed state if available
try {
  const prev = localStorage.getItem('daasidebar_collapsed');
  if(prev === '1') setCollapsed(true);
} catch(e){}

/* -------------------------
   INIT
------------------------- */
renderCards(problems);
// Optionally auto-open first item:
if(problems && problems.length) loadProblem(problems[0].id, true);

// Search binding (with debounce)
searchInput.addEventListener('input', debounce((e) => {
  filter(e.target.value);
}));

// Expose for debug (safe)
window.__DAA = { problems, loadProblem, filter, setCollapsed };
</script>

</body>
</html>
