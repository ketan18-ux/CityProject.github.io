<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>DAA Portfolio — TEJAS.B.KERI</title>

<!-- Fonts -->
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600;800&family=Poppins:wght@300;400;600;700&display=swap" rel="stylesheet">

<!-- Prism for syntax highlighting -->
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>

<style>
  :root{
    --bg:#061226;
    --panel:#0b1530;
    --muted:#9aa6bf;
    --accent:#22d3ee;
    --glass: rgba(255,255,255,0.04);
    --card-shadow: 0 10px 30px rgba(2,6,23,0.6);
    --radius-lg: 14px;
    --radius-xl: 20px;
  }

  .light {
    --bg:#f6fbff;
    --panel:#ffffff;
    --muted:#475569;
    --accent:#06b6d4;
    --card-shadow: 0 8px 22px rgba(16,24,40,0.06);
  }

  html,body{
    height:100%;
    margin:0;
    font-family: "Poppins", system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    background: radial-gradient(circle at top left, #041022 0%, #071025 40%, #071025 100%);
    color: #e6eef8;
    -webkit-font-smoothing:antialiased;
    -moz-osx-font-smoothing:grayscale;
    transition: background 0.45s ease, color 0.35s ease;
  }

  /* Header */
  .top {
    max-width:1200px;
    margin:28px auto 12px;
    padding:22px;
    border-radius: var(--radius-xl);
    background: linear-gradient(90deg, rgba(16,36,59,0.88) 0%, rgba(17,44,62,0.78) 100%);
    box-shadow: var(--card-shadow);
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:20px;
    backdrop-filter: blur(8px) saturate(120%);
  }
  .top-left{ display:flex; flex-direction:column; gap:12px; }
  .top-left h1{ margin:0; font-size:28px; letter-spacing:-0.3px; color:#def4ff; }
  .badges{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
  .badge{
    background: rgba(255,255,255,0.03);
    border:1px solid rgba(255,255,255,0.04);
    padding:8px 14px;
    font-size:13px;
    color:var(--muted);
    border-radius:999px;
  }
  .badge strong{ color:#fff; font-weight:600; margin-right:8px; }

  .top-right { display:flex; align-items:center; gap:14px; }
  .home-btn{
    display:inline-flex;
    align-items:center;
    gap:10px;
    padding:12px 18px;
    background:linear-gradient(90deg,#06b6d4,#0891b2);
    color:#022430;
    font-weight:700;
    border-radius:999px;
    text-decoration:none;
    box-shadow:0 8px 28px rgba(3,120,163,0.18);
    transition: transform 0.16s ease;
  }
  .home-btn:hover{ transform: translateY(-3px); }
  .meta-pill{
    background:rgba(255,255,255,0.03);
    padding:8px 12px;
    border-radius:999px;
    color:var(--muted);
    font-size:13px;
    border:1px solid rgba(255,255,255,0.03);
  }

  /* Layout */
  .main {
    max-width:1200px;
    margin:18px auto 60px;
    display:flex;
    gap:20px;
    padding:8px;
  }

  /* Sidebar */
  .sidebar{
    width:28%;
    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border-radius:var(--radius-lg);
    padding:18px;
    box-shadow: var(--card-shadow);
    height:72vh;
    overflow:auto;
    border:1px solid rgba(255,255,255,0.03);
  }
  .sidebar h3{ margin:0 0 12px 0; font-size:18px; color:#dff7ff; }
  .sidebar p{ color:var(--muted); font-size:13px; margin-bottom:14px; }

  .problem-item{
    background: rgba(255,255,255,0.02);
    border-radius:12px;
    padding:12px 14px;
    margin-bottom:12px;
    cursor:pointer;
    color:var(--muted);
    display:flex;
    justify-content:space-between;
    align-items:center;
    transition: all 0.15s ease;
    border: 1px solid rgba(255,255,255,0.02);
    outline: none;
  }
  .problem-item:hover{
    transform: translateX(6px);
    background: linear-gradient(90deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
    color:#e6f7ff;
    border-color: rgba(20,160,200,0.12);
  }
  .problem-item.active{
    background: linear-gradient(90deg, rgba(6,182,212,0.12), rgba(7,125,170,0.07));
    color: #eafcff;
    border-color: rgba(6,182,212,0.18);
    box-shadow: 0 10px 30px rgba(2,6,23,0.45);
  }
  .problem-index{ font-weight:700; color:#9fe9ff; margin-right:12px; }

  .problem-item:focus {
    box-shadow: 0 0 0 4px rgba(34,211,238,0.14);
    transform: translateX(4px);
  }

  /* center panel */
  .center{
    width:72%;
    background: linear-gradient(180deg, rgba(10,20,45,0.72), rgba(8,16,32,0.78));
    border-radius:var(--radius-lg);
    padding:22px;
    min-height:72vh;
    box-shadow: var(--card-shadow);
    border:1px solid rgba(255,255,255,0.02);
    overflow:auto;
  }
  .center h2{ margin:0 0 8px 0; font-size:22px; color:#e8fbff; }
  .center .desc{ color:var(--muted); line-height:1.6; margin-bottom:12px; }

  .complexity{
    margin-top:10px;
    display:inline-block;
    background:linear-gradient(90deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    padding:10px 14px;
    border-radius:10px;
    color:#d9f7ff;
    border:1px solid rgba(255,255,255,0.03);
    font-size:14px;
  }

  /* Welcome screen styling */
  .welcome {
    display:flex;
    flex-direction:column;
    gap:14px;
    align-items:flex-start;
    animation: fadeIn 0.6s ease;
  }
  .welcome h2 { font-size:26px; margin:0; color:#f0fbff; }
  .welcome p { color:var(--muted); max-width:780px; }
  .steps {
    background: rgba(255,255,255,0.02);
    padding:14px;
    border-radius:12px;
    border:1px solid rgba(255,255,255,0.02);
  }
  .cta-note { margin-top:8px; color:var(--muted); }

  @keyframes fadeIn {
    from { opacity:0; transform: translateY(8px); }
    to { opacity:1; transform: translateY(0); }
  }

  /* code block */
  pre {
    margin-top:18px;
    border-radius:12px;
    padding:18px;
    background:#0f1724 !important;
    box-shadow: 0 10px 30px rgba(2,6,23,0.6);
    overflow:auto;
  }
  code { font-family: "JetBrains Mono", monospace !important; font-size:14px; }

  /* responsiveness */
  @media (max-width: 980px){
    .main{ flex-direction:column; padding:10px; }
    .sidebar{ width:100%; height:28vh; }
    .center{ width:100%; height:60vh; }
  }

  /* dark/light toggle button (floating) */
  .toggle-floating {
    position: fixed;
    right: 18px;
    bottom: 18px;
    z-index: 9999;
    padding: 10px 12px;
    background: linear-gradient(90deg,#06b6d4,#0891b2);
    color: #001b23;
    border-radius: 10px;
    cursor: pointer;
    border: none;
    font-weight: 700;
    box-shadow: 0 10px 30px rgba(6,182,212,0.12);
  }

</style>
</head>
<body>

<!-- Header -->
<div class="top" role="banner" aria-label="Portfolio header">
  <div class="top-left">
    <h1>Smart City Infrastructure & Routing Design — DAA Portfolio</h1>
    <div class="badges" role="list" aria-label="portfolio badges">
      <span class="badge" role="listitem"><strong>Student:</strong> TEJAS.B.KERI</span>
      <span class="badge" role="listitem"><strong>Faculty:</strong> Prakash Hegade</span>
      <span class="badge" role="listitem"><strong>Course:</strong> Design &amp; Analysis of Algorithms</span>
      <span class="badge" role="listitem"><strong>Focus:</strong> Land Use, Zoning &amp; Location Optimization Projects</span>
    </div>
  </div>

  <div class="top-right">
    <span class="meta-pill" aria-hidden="true">2024 · DAA City Design</span>
    <a class="home-btn" href="index.html" title="Back to home">← Back to Home</a>
  </div>
</div>

<!-- Main area -->
<div class="main" role="main">
  <!-- Sidebar -->
  <aside class="sidebar" aria-label="Case study gallery">
    <h3>A. Case Study Gallery</h3>
    <p>Ten real-world inspired problems. Click any item to expand its description, I/O model and complexity.</p>

    <div id="problemList" role="list" aria-label="Problem list">
      <noscript>
        <ul>
          <li>1. Optimal Hospital Location</li>
          <li>2. School Allocation to Students</li>
          <li>3. Smart Parking Slot Allocation</li>
          <li>4. Industrial vs Residential Separation</li>
          <li>5. Public Park Placement Optimization</li>
          <li>6. Land Subdivision Optimization</li>
          <li>7. High Footfall Commercial Zone Prediction</li>
          <li>8. Creation of Green Belt Buffers</li>
          <li>9. Footpath Connectivity Plan</li>
          <li>10. Underground Utility Routing</li>
        </ul>
      </noscript>
    </div>
  </aside>

  <!-- Center panel -->
  <main class="center" id="centerPanel" aria-live="polite">
    <div id="centerContent" class="welcome">
      <h2>Welcome — Smart City DAA Portfolio</h2>
      <p>
        This portfolio contains ten algorithmic case studies focused on land use, zoning and location optimization
        for city design. Each case study includes:
      </p>

      <div class="steps">
        <ul>
          <li><strong>High-level problem summary</strong> — what the city problem is and why it's important.</li>
          <li><strong>Time complexity</strong> — algorithmic complexity for the chosen approach.</li>
          <li><strong>Reference code</strong> — an implementation with detailed comments and design notes.</li>
        </ul>
      </div>

      <p class="cta-note">
        How to access the portfolio:
      </p>
      <ol style="color:var(--muted); margin-left:18px;">
        <li>Click any problem on the left column to load its summary and code.</li>
        <li>Use the <em>Toggle Dark / Light</em> button to switch themes.</li>
        <li>Use the keyboard arrow keys to navigate problems (Up / Down) and Enter / Space to select.</li>
      </ol>

      <p style="margin-top:10px; color:var(--muted);">
        Click a problem on the left to begin →
      </p>
    </div>

    <!-- Problem title / description / complexity and code will replace the welcome content when loaded -->
    <div id="problemArea" class="hidden" aria-hidden="true">
      <h2 id="problemTitle">Title will appear here</h2>
      <div class="desc" id="problemDesc">Description will appear here.</div>
      <div class="complexity" id="problemComplexity">Time Complexity — (select a problem)</div>
      <pre><code id="problemCode" class="language-python"># Code will appear here when you select a problem.</code></pre>
    </div>
  </main>
</div>

<!-- Floating toggle -->
<button class="toggle-floating" id="toggleBtn" aria-label="Toggle dark light">Toggle Dark / Light</button>

<script>
/* ============================
   Problems data (10 items)
   Each problem includes:
    - id
    - title
    - desc (HTML)
    - complexity (HTML)
    - code (string - Python)
   (Long code blocks included.)
   ============================ */

const problems = [
  {
    id: 1,
    title: "Optimal Hospital Location",
    desc: `<strong>Problem summary:</strong> Place hospitals so that the total travel distance citizens take to their nearest hospital is minimized. Use median-based placement for 1D scenarios and k-median approximations (k-means++ seeds + Lloyd-style iterations) for 2D placement when multiple hospitals are needed.`,
    complexity: `<strong>Time Complexity:</strong> Median (1D) approach: O(n log n) due to sorting. k-median (approx) with t iterations: O(k n t).`,

    code:
\`# Optimal Hospital Location — Extended Implementation & Notes
# This example includes:
#  - a 1D median method (exact minimizer for sum of distances)
#  - a k-median approximate solver using kmeans++ style seeding and Lloyd iterations
#  - helper utilities for distance and synthetic data generation
#
# Note: This implementation is educational and aims to show algorithmic design choices.

import random
import math
from collections import defaultdict

def median_1d(points):
    \"\"\"Compute 1D median (minimizes L1 distance)\"\"\"
    pts = sorted(points)
    n = len(pts)
    if n == 0:
        return None
    if n % 2 == 1:
        return pts[n // 2]
    # any point between the two middle elements is optimal; we return the midpoint
    return 0.5 * (pts[n//2 - 1] + pts[n//2])

def squared_distance(a, b):
    return (a[0]-b[0])**2 + (a[1]-b[1])**2

def kmeans_plus_plus(points, k, rng=random):
    \"\"\"k-means++ initialization: choose first center uniformly then pick new centers
       with probability proportional to squared distance to nearest center.
    \"\"\"
    if not points or k <= 0:
        return []
    centers = []
    centers.append(rng.choice(points))
    dist = [squared_distance(p, centers[0]) for p in points]
    for _ in range(1, k):
        s = sum(dist)
        if s == 0:
            centers.append(rng.choice(points))
            continue
        r = rng.random() * s
        acc = 0.0
        chosen = None
        for i, d in enumerate(dist):
            acc += d
            if acc >= r:
                chosen = points[i]
                break
        if chosen is None:
            chosen = rng.choice(points)
        centers.append(chosen)
        # update distances
        for i, p in enumerate(points):
            ds = squared_distance(p, centers[-1])
            if ds < dist[i]:
                dist[i] = ds
    return centers

def assign_points(points, centers):
    clusters = [[] for _ in centers]
    for p in points:
        best_i = 0
        best_d = squared_distance(p, centers[0])
        for i in range(1, len(centers)):
            d = squared_distance(p, centers[i])
            if d < best_d:
                best_d = d
                best_i = i
        clusters[best_i].append(p)
    return clusters

def recompute_centers(clusters):
    new_centers = []
    for c in clusters:
        if not c:
            # keep a dummy placeholder to avoid shrinkage; in practice, you may reseed
            new_centers.append((0.0, 0.0))
            continue
        x = sum(p[0] for p in c) / len(c)
        y = sum(p[1] for p in c) / len(c)
        new_centers.append((x, y))
    return new_centers

def k_median_approx(points, k=3, iterations=50):
    if not points or k <= 0:
        return []
    centers = kmeans_plus_plus(points, k)
    for it in range(iterations):
        clusters = assign_points(points, centers)
        new_centers = recompute_centers(clusters)
        # check convergence with small tolerance
        converged = True
        for i in range(k):
            if math.hypot(new_centers[i][0] - centers[i][0], new_centers[i][1] - centers[i][1]) > 1e-6:
                converged = False
                break
        centers = new_centers
        if converged:
            break
    return centers

# Example usage:
# points2d = [(random.uniform(0, 100), random.uniform(0, 100)) for _ in range(300)]
# centers = k_median_approx(points2d, k=4, iterations=40)
# print('centers', centers)
\`
  },

  {
    id: 2,
    title: "School Allocation to Students",
    desc: `<strong>Problem summary:</strong> Assign students to schools respecting capacity and geographic constraints. Model as a flow / matching problem. Solve using Dinic's max flow for robust capacity handling.`,
    complexity: `<strong>Time Complexity:</strong> Dinic's algorithm average practical performance: O(E sqrt(V)) or O(min(V^{2/3}, sqrt(E)) E) depending on implementation; for bipartite matching it is efficient for city-scale graphs.`,

    code:
\`# School Allocation to Students — Dinic's implementation (detailed)

from collections import deque

class Dinic:
    def __init__(self, n):
        self.n = n
        self.adj = [[] for _ in range(n)]

    def add_edge(self, u, v, cap):
        # adjacency stores [to, cap, rev_index]
        self.adj[u].append([v, cap, len(self.adj[v])])
        self.adj[v].append([u, 0, len(self.adj[u]) - 1])

    def bfs(self, s, t, level):
        for i in range(len(level)):
            level[i] = -1
        q = deque([s])
        level[s] = 0
        while q:
            u = q.popleft()
            for v, cap, rev in self.adj[u]:
                if cap and level[v] < 0:
                    level[v] = level[u] + 1
                    q.append(v)
        return level[t] >= 0

    def send(self, u, t, f, level, it):
        if u == t:
            return f
        for i in range(it[u], len(self.adj[u])):
            v, cap, rev = self.adj[u][i]
            if cap and level[v] == level[u] + 1:
                pushed = self.send(v, t, min(f, cap), level, it)
                if pushed:
                    self.adj[u][i][1] -= pushed
                    self.adj[v][self.adj[u][i][2]][1] += pushed
                    return pushed
            it[u] += 1
        return 0

    def max_flow(self, s, t):
        flow = 0
        level = [-1] * self.n
        while self.bfs(s, t, level):
            it = [0] * self.n
            while True:
                pushed = self.send(s, t, 10**18, level, it)
                if not pushed:
                    break
                flow += pushed
        return flow

# Build a sample bipartite network:
# nodes: source (0), students (1..S), schools (S+1..S+K), sink (S+K+1)
# capacities from source->student = 1, student->school = 1 (if feasible), school->sink = school_capacity

# Use case: compute maximum assignment count, then recover matches by inspecting edges
\`
  },

  {
    id: 3,
    title: "Smart Parking Slot Allocation",
    desc: `<strong>Problem summary:</strong> Assign cars to parking slots to minimize total walking distance and honor slot suitability and priorities. The Hungarian algorithm provides an exact min-cost perfect matching for equal-sized sets; for unequal sizes consider padding costs or greedy + DP alternatives.`,
    complexity: `<strong>Time Complexity:</strong> Hungarian algorithm O(n^3); greedy heuristics O(n^2).`,

    code:
\`# Smart Parking Slot Allocation — Hungarian algorithm (dense O(n^3) approach)
# This code is a classical implementation adapted for clarity and educational use.

def hungarian(cost):
    # cost: n x n matrix (square). If rectangular, pad with zeros or large values.
    n = len(cost)
    u = [0] * (n + 1)
    v = [0] * (n + 1)
    p = [0] * (n + 1)
    way = [0] * (n + 1)
    for i in range(1, n+1):
        p[0] = i
        j0 = 0
        minv = [float('inf')] * (n + 1)
        used = [False] * (n + 1)
        while True:
            used[j0] = True
            i0 = p[j0]
            delta = float('inf')
            j1 = 0
            for j in range(1, n+1):
                if not used[j]:
                    cur = cost[i0-1][j-1] - u[i0] - v[j]
                    if cur < minv[j]:
                        minv[j] = cur
                        way[j] = j0
                    if minv[j] < delta:
                        delta = minv[j]
                        j1 = j
            for j in range(n+1):
                if used[j]:
                    u[p[j]] += delta
                    v[j] -= delta
                else:
                    minv[j] -= delta
            j0 = j1
            if p[j0] == 0:
                break
        while True:
            j1 = way[j0]
            p[j0] = p[j1]
            j0 = j1
            if j0 == 0:
                break
    assignment = [-1] * n
    for j in range(1, n+1):
        if p[j] != 0:
            assignment[p[j]-1] = j-1
    total_cost = -v[0]
    return assignment, total_cost

# Example usage:
# cars = [...]
# slots = [...]
# cost_matrix = [[abs(car_x - slot_x) + abs(car_y - slot_y) for slot in slots] for car in cars]
# match, cost = hungarian(cost_matrix)
\`
  },

  {
    id: 4,
    title: "Industrial vs Residential Separation",
    desc: `<strong>Problem summary:</strong> Color map regions such that industrial and residential zones do not touch; check if the region partition graph is bipartite, otherwise apply greedy recoloring or minimal-edge adjustments.`,
    complexity: `<strong>Time Complexity:</strong> Bipartite check O(V + E). Greedy coloring O(V^2) in naive form.`,

    code:
\`# Industrial vs Residential Separation — bipartite check + greedy fallback
def is_bipartite(graph):
    color = {}
    for start in graph:
        if start in color:
            continue
        stack = [start]
        color[start] = 0
        while stack:
            u = stack.pop()
            for v in graph[u]:
                if v not in color:
                    color[v] = color[u] ^ 1
                    stack.append(v)
                elif color[v] == color[u]:
                    return False, None
    return True, color

def greedy_coloring(graph):
    order = sorted(graph.keys(), key=lambda x: -len(graph[x]))
    color = {}
    for node in order:
        forbidden = {color.get(nb) for nb in graph[node] if nb in color}
        c = 0
        while c in forbidden:
            c += 1
        color[node] = c
    return color

# In practice, a combination of planar graph heuristics and local adjustments produces nicer visual zones.
\`
  },

  {
    id: 5,
    title: "Public Park Placement Optimization",
    desc: `<strong>Problem summary:</strong> Select park locations to maximize covered population within walking radius. Use greedy max-cover with efficient query structures (Fenwick/Segment tree) to track served population and recompute gains.`,
    complexity: `<strong>Time Complexity:</strong> Greedy max cover with Fenwick tree: O(k * n * log n).`,

    code:
\`# Public Park Placement Optimization — Fenwick tree (BIT) demo for range sums

class Fenwick:
    def __init__(self, n):
        self.n = n
        self.bit = [0] * (n + 1)

    def update(self, i, delta):
        while i <= self.n:
            self.bit[i] += delta
            i += i & -i

    def query(self, i):
        s = 0
        while i > 0:
            s += self.bit[i]
            i -= i & -i
        return s

    def range_sum(self, l, r):
        if l > r:
            return 0
        return self.query(r) - self.query(l - 1)

def greedy_max_cover(population, candidate_positions, k, radius):
    # population: list indexed 1..n (we will use 1-based indexing)
    n = len(population)
    fen = Fenwick(n)
    for i, p in enumerate(population, start=1):
        fen.update(i, p)
    chosen = []
    for _ in range(k):
        best_gain = -1
        best_pos = None
        for pos in candidate_positions:
            l = max(1, pos - radius)
            r = min(n, pos + radius)
            gain = fen.range_sum(l, r)
            if gain > best_gain:
                best_gain = gain
                best_pos = pos
        if best_pos is None or best_gain <= 0:
            break
        chosen.append((best_pos, best_gain))
        l = max(1, best_pos - radius)
        r = min(n, best_pos + radius)
        # remove served population (mark as zero)
        for i in range(l, r+1):
            val = population[i-1]
            if val > 0:
                fen.update(i, -val)
                population[i-1] = 0
    return chosen
\`
  },

  {
    id: 6,
    title: "Land Subdivision Optimization",
    desc: `<strong>Problem summary:</strong> Partition large land parcels into smaller usable lots optimizing for balance, accessibility and minimal infrastructure cost. A kd-tree-like recursive spatial partitioning works well for many heuristics.`,
    complexity: `<strong>Time Complexity:</strong> Balanced recursive splits: O(n log n). Unbalanced worst-case: O(n^2).`,

    code:
\`# Land Subdivision Optimization — recursive kd-like splitting (conceptual)

def area_of_polygon(points):
    \"\"\"Compute polygon area using shoelace formula.\"\"\"
    s = 0
    n = len(points)
    for i in range(n):
        x1, y1 = points[i]
        x2, y2 = points[(i+1) % n]
        s += x1 * y2 - x2 * y1
    return abs(s) / 2.0

def split_bbox_midpoint(points, axis='x'):
    xs = [p[0] for p in points]
    ys = [p[1] for p in points]
    if axis == 'x':
        mid = (min(xs) + max(xs)) / 2.0
        left = [p for p in points if p[0] <= mid]
        right = [p for p in points if p[0] > mid]
    else:
        mid = (min(ys) + max(ys)) / 2.0
        left = [p for p in points if p[1] <= mid]
        right = [p for p in points if p[1] > mid]
    return left, right

def recursive_partition(points, depth=0, max_depth=4):
    if depth >= max_depth or len(points) <= 3:
        return [points]
    axis = 'x' if depth % 2 == 0 else 'y'
    left, right = split_bbox_midpoint(points, axis=axis)
    if not left or not right:
        return [points]
    return recursive_partition(left, depth+1, max_depth) + recursive_partition(right, depth+1, max_depth)
\`
  },

  {
    id: 7,
    title: "High Footfall Commercial Zone Prediction",
    desc: `<strong>Problem summary:</strong> Identify likely commercial hotspots using mobility density, clustering and temporal smoothing. Simple density estimation plus top-k extraction gives actionable candidates.`,
    complexity: `<strong>Time Complexity:</strong> Naive density O(n^2); spatial indexing reduces to O(n log n).`,

    code:
\`# High Footfall Prediction — naive approach + heap selection example

import heapq
import math

def euclid(a, b):
    return math.hypot(a[0] - b[0], a[1] - b[1])

def naive_density(points, radius):
    densities = [0] * len(points)
    for i, p in enumerate(points):
        for j, q in enumerate(points):
            if euclid(p, q) <= radius:
                densities[i] += 1
    return densities

def top_k_density(points, radius, k):
    densities = naive_density(points, radius)
    heap = [(-densities[i], i) for i in range(len(points))]
    heapq.heapify(heap)
    result = []
    for _ in range(min(k, len(heap))):
        d, idx = heapq.heappop(heap)
        result.append((idx, -d, points[idx]))
    return result

# Use spatial indices (kd-tree, r-tree) for large-scale data.
\`
  },

  {
    id: 8,
    title: "Creation of Green Belt Buffers",
    desc: `<strong>Problem summary:</strong> Place green belts such that minimum spacing constraints are satisfied and restricted land is avoided. Use backtracking with pruning heuristics and greedy ordering.`,
    complexity: `<strong>Time Complexity:</strong> Backtracking worst-case O(2^n), pruning reduces practical runtime.`,

    code:
\`# Green Belt Buffers — backtracking with pruning demonstration

def feasible(placed, candidate, min_dist):
    for p in placed:
        if abs(p - candidate) < min_dist:
            return False
    return True

def place_belts(candidates, min_dist):
    placed = []
    solutions = []

    def dfs(idx):
        if idx == len(candidates):
            solutions.append(list(placed))
            return
        # Option 1: skip
        dfs(idx + 1)
        # Option 2: take if feasible
        if feasible(placed, candidates[idx], min_dist):
            placed.append(candidates[idx])
            dfs(idx + 1)
            placed.pop()

    dfs(0)
    return solutions

# Heuristics: sort candidates by degree (more constrained candidates first)
\`
  },

  {
    id: 9,
    title: "Footpath Connectivity Plan",
    desc: `<strong>Problem summary:</strong> Compute connectivity in pedestrian networks, detect disconnected components, compute all-pairs shortest paths, and propose minimal links to improve connectivity.`,
    complexity: `<strong>Time Complexity:</strong> Floyd-Warshall O(V^3) for dense graphs; Dijkstra O((V+E) log V) for sparse graphs.`,

    code:
\`# Footpath Connectivity — Floyd-Warshall & component heuristics

def floyd_warshall(adj_matrix):
    n = len(adj_matrix)
    dist = [row[:] for row in adj_matrix]
    for k in range(n):
        for i in range(n):
            for j in range(n):
                if dist[i][k] + dist[k][j] < dist[i][j]:
                    dist[i][j] = dist[i][k] + dist[k][j]
    return dist

def connected_components(adj_list):
    visited = set()
    comps = []
    for node in adj_list:
        if node not in visited:
            stack = [node]; comp = []
            while stack:
                u = stack.pop()
                if u in visited: continue
                visited.add(u); comp.append(u)
                for v in adj_list[u]:
                    if v not in visited:
                        stack.append(v)
            comps.append(comp)
    return comps

def propose_links(adj_list):
    comps = connected_components(adj_list)
    if len(comps) <= 1:
        return []
    links = []
    # naive heuristic: connect first node of each component pairwise
    for i in range(len(comps) - 1):
        a = comps[i][0]
        b = comps[i+1][0]
        links.append((a, b))
    return links
\`
  },

  {
    id: 10,
    title: "Underground Utility Routing",
    desc: `<strong>Problem summary:</strong> Route underground utilities (power, fiber, water) as disjoint paths or with minimal overlaps; sequential Dijkstra routing with reservations is a common heuristic for multi-commodity routing.`,
    complexity: `<strong>Time Complexity:</strong> Dijkstra O((V+E) log V) per commodity; multi-commodity increases cost multiplicatively.`,

    code:
\`# Underground Utility Routing — sequential Dijkstra with reservation heuristic

import heapq

def dijkstra(graph, source):
    dist = {node: float('inf') for node in graph}
    prev = {node: None for node in graph}
    dist[source] = 0
    pq = [(0, source)]
    while pq:
        d, u = heapq.heappop(pq)
        if d != dist[u]:
            continue
        for v, w in graph[u]:
            nd = d + w
            if nd < dist[v]:
                dist[v] = nd
                prev[v] = u
                heapq.heappush(pq, (nd, v))
    return dist, prev

def reserve_path(prev, target):
    path = []
    u = target
    while prev[u] is not None:
        v = prev[u]
        path.append((v, u))
        u = v
    return list(reversed(path))

def sequential_routing(graph, commodities):
    reserved = set()
    routes = []
    for s, t in commodities:
        dist, prev = dijkstra(graph, s)
        if dist[t] == float('inf'):
            routes.append(None)
            continue
        path_edges = reserve_path(prev, t)
        for e in path_edges:
            reserved.add(e)
        routes.append(path_edges)
    return routes
\`
  }
];

/* ============================
   DOM references
   ============================ */
const listEl = document.getElementById('problemList');
const centerContent = document.getElementById('centerContent');
const problemArea = document.getElementById('problemArea');
const titleEl = document.getElementById('problemTitle');
const descEl = document.getElementById('problemDesc');
const compEl = document.getElementById('problemComplexity');
const codeEl = document.getElementById('problemCode');
const toggleBtn = document.getElementById('toggleBtn');

/* ============================
   Render sidebar items
   ============================ */
function renderSidebar() {
  listEl.innerHTML = '';
  problems.forEach(p => {
    const div = document.createElement('div');
    div.className = 'problem-item';
    div.dataset.id = p.id;
    div.setAttribute('role', 'button');
    div.setAttribute('tabindex', '0');
    div.setAttribute('aria-pressed', 'false');
    div.innerHTML = \`
      <div style="display:flex; align-items:center;">
        <span class="problem-index">#\${p.id}</span>
        <span style="font-weight:600;">\${p.title}</span>
      </div>
    \`;
    div.addEventListener('click', () => setActiveProblem(p.id));
    div.addEventListener('keydown', (ev) => {
      if (ev.key === 'Enter' || ev.key === ' ') {
        ev.preventDefault();
        setActiveProblem(p.id);
      }
    });
    listEl.appendChild(div);
  });
}

/* ============================
   No selection by default:
   Show welcome screen until user clicks a problem
   ============================ */

let activeId = null;

function setActiveProblem(id) {
  // find existing active element and class
  activeId = id;
  // update list active classes and aria pressed
  Array.from(document.querySelectorAll('.problem-item')).forEach(el => {
    if (String(el.dataset.id) === String(id)) {
      el.classList.add('active');
      el.setAttribute('aria-pressed', 'true');
    } else {
      el.classList.remove('active');
      el.setAttribute('aria-pressed', 'false');
    }
  });

  const p = problems.find(x => x.id === id);
  if (!p) return;

  // hide welcome, show problem area
  centerContent.classList.add('hidden');
  problemArea.classList.remove('hidden');
  problemArea.setAttribute('aria-hidden', 'false');

  // set title, desc, complexity
  titleEl.innerHTML = p.title;
  descEl.innerHTML = p.desc;
  compEl.innerHTML = p.complexity;

  // set code safely and highlight
  // Use textContent so indentation is preserved; then highlight with Prism
  codeEl.textContent = p.code.trim();
  try {
    Prism.highlightElement(codeEl);
  } catch (err) {
    // ignore highlight errors
  }

  // scroll center to top
  document.querySelector('.center').scrollTop = 0;
}

/* ============================
   Initialize: render list, but do NOT auto-select
   ============================ */
renderSidebar();
// Leave activeId as null; welcome screen visible
problemArea.classList.add('hidden');
problemArea.setAttribute('aria-hidden', 'true');
centerContent.classList.remove('hidden');

/* ============================
   Keyboard Up/Down navigation (changes focus in sidebar)
   ============================ */
document.addEventListener('keydown', (e) => {
  const items = Array.from(document.querySelectorAll('.problem-item'));
  if (!items.length) return;

  // find focused index
  const focusedIndex = items.findIndex(it => it === document.activeElement);
  if (e.key === 'ArrowDown') {
    e.preventDefault();
    const next = (focusedIndex === -1) ? 0 : Math.min(items.length - 1, focusedIndex + 1);
    items[next].focus();
  } else if (e.key === 'ArrowUp') {
    e.preventDefault();
    const prev = (focusedIndex === -1) ? items.length - 1 : Math.max(0, focusedIndex - 1);
    items[prev].focus();
  }
});

/* ============================
   Dark / Light toggle
   ============================ */
toggleBtn.addEventListener('click', () => {
  document.documentElement.classList.toggle('light');
  document.body.classList.toggle('light');
  // leaving Prism theme as is; it's readable in both modes
});

/* ============================
   Small accessibility improvement:
   Allow clicking an already active item to re-show welcome screen (optional)
   ============================ */
function resetToWelcome() {
  activeId = null;
  Array.from(document.querySelectorAll('.problem-item')).forEach(el => {
    el.classList.remove('active');
    el.setAttribute('aria-pressed', 'false');
  });
  // hide problem area and show welcome
  problemArea.classList.add('hidden');
  problemArea.setAttribute('aria-hidden', 'true');
  centerContent.classList.remove('hidden');
}

// Optional: double-click header title to reset to welcome (developer convenience)
document.querySelector('.top-left h1').addEventListener('dblclick', resetToWelcome);

/* ============================
   Small touch: if user presses ESC, go back to welcome
   ============================ */
document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') {
    resetToWelcome();
  }
});

</script>

</body>
</html>
