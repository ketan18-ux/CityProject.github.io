#include <bits/stdc++.h>
using namespace std;

/* ===================== Utilities ===================== */
template<typename T>
void printVec(const vector<T>& a, const string& label=""){
    if(!label.empty()) cout<<label;
    for(size_t i=0;i<a.size();++i) cout<<(i?" ":"")<<a[i];
    cout<<"\n";
}
struct DSU {
    vector<int> p, r;
    DSU(int n): p(n), r(n,0){ iota(p.begin(), p.end(), 0); }
    int find(int x){ return p[x]==x?x:p[x]=find(p[x]); }
    bool unite(int a,int b){
        a=find(a); b=find(b);
        if(a==b) return false;
        if(r[a]<r[b]) swap(a,b);
        p[b]=a; if(r[a]==r[b]) r[a]++;
        return true;
    }
};

/* ================= Towers of Hanoi ================= */
void hanoi(int n, char from, char to, char aux, vector<string>& moves){
    if(n==0) return;
    hanoi(n-1, from, aux, to, moves);
    moves.push_back(string("Move disk ") + to_string(n) + " from " + from + " to " + to);
    hanoi(n-1, aux, to, from, moves);
}

/* ================= N-Queens (Backtracking) ================= */
bool isSafeNQ(const vector<string>& b, int r, int c, int n){
    for(int i=0;i<r;i++) if(b[i][c]=='Q') return false;
    for(int i=r-1,j=c-1;i>=0&&j>=0;i--,j--) if(b[i][j]=='Q') return false;
    for(int i=r-1,j=c+1;i>=0&&j<n;i--,j++) if(b[i][j]=='Q') return false;
    return true;
}
bool nQueensUtil(vector<string>& b, int r, int n){
    if(r==n) return true;
    for(int c=0;c<n;c++){
        if(isSafeNQ(b,r,c,n)){
            b[r][c]='Q';
            if(nQueensUtil(b,r+1,n)) return true;
            b[r][c]='.';
        }
    }
    return false;
}
vector<string> solveNQueens(int n){
    vector<string> board(n,string(n,'.'));
    nQueensUtil(board,0,n);
    return board;
}

/* ================= Fenwick Tree (BIT) ================= */
struct Fenwick {
    int n; vector<long long> bit;
    Fenwick(int n): n(n), bit(n+1,0) {}
    void add(int idx, long long val){ for(; idx<=n; idx+=idx&-idx) bit[idx]+=val; }
    long long sum(int idx){ long long r=0; for(; idx>0; idx-=idx&-idx) r+=bit[idx]; return r; }
    long long rangeSum(int l,int r){ return sum(r)-sum(l-1); }
};

/* ================= Segment Tree (Range Sum) ================= */
struct SegmentTree {
    int n; vector<long long> seg;
    SegmentTree(const vector<int>& a){
        n=a.size(); seg.assign(4*n,0); build(a,1,0,n-1);
    }
    void build(const vector<int>& a, int idx, int l, int r){
        if(l==r){ seg[idx]=a[l]; return; }
        int m=(l+r)/2;
        build(a,idx*2,l,m); build(a,idx*2+1,m+1,r);
        seg[idx]=seg[idx*2]+seg[idx*2+1];
    }
    long long query(int idx,int l,int r,int ql,int qr){
        if(qr<l||ql>r) return 0;
        if(ql<=l && r<=qr) return seg[idx];
        int m=(l+r)/2;
        return query(idx*2,l,m,ql,qr)+query(idx*2+1,m+1,r,ql,qr);
    }
    void update(int idx,int l,int r,int pos,int val){
        if(l==r){ seg[idx]=val; return; }
        int m=(l+r)/2;
        if(pos<=m) update(idx*2,l,m,pos,val);
        else update(idx*2+1,m+1,r,pos,val);
        seg[idx]=seg[idx*2]+seg[idx*2+1];
    }
};

/* ================= Skip List (basic) ================= */
struct SkipNode {
    int key; vector<SkipNode*> next;
    SkipNode(int key,int level): key(key), next(level,nullptr) {}
};
struct SkipList {
    static const int MAXL=16;
    float P=0.5;
    SkipNode* head;
    int level;
    SkipList(): head(new SkipNode(INT_MIN, MAXL)), level(1) { srand(123); }
    int randomLevel(){
        int lvl=1; while(((float)rand()/RAND_MAX)<P && lvl<MAXL) lvl++; return lvl;
    }
    void insert(int key){
        vector<SkipNode*> update(MAXL, nullptr);
        SkipNode* x=head;
        for(int i=level-1;i>=0;i--){
            while(x->next[i] && x->next[i]->key<key) x=x->next[i];
            update[i]=x;
        }
        x = x->next[0];
        if(!x || x->key!=key){
            int lvl=randomLevel();
            if(lvl>level){ for(int i=level;i<lvl;i++) update[i]=head; level=lvl; }
            SkipNode* n=new SkipNode(key,lvl);
            for(int i=0;i<lvl;i++){ n->next[i]=update[i]->next[i]; update[i]->next[i]=n; }
        }
    }
    bool search(int key){
        SkipNode* x=head;
        for(int i=level-1;i>=0;i--){
            while(x->next[i] && x->next[i]->key<key) x=x->next[i];
        }
        x=x->next[0];
        return x && x->key==key;
    }
};

/* ================= Trie ================= */
struct TrieNode {
    bool end=false; unordered_map<char, TrieNode*> child;
};
struct Trie {
    TrieNode* root;
    Trie(): root(new TrieNode()) {}
    void insert(const string& s){
        TrieNode* cur=root;
        for(char ch: s){
            if(!cur->child[ch]) cur->child[ch]=new TrieNode();
            cur=cur->child[ch];
        }
        cur->end=true;
    }
    bool search(const string& s){
        TrieNode* cur=root;
        for(char ch: s){
            if(!cur->child.count(ch)) return false;
            cur=cur->child[ch];
        }
        return cur->end;
    }
};

/* ================= Sorting Algorithms ================= */
void bubbleSort(vector<int>& a){
    int n=a.size();
    for(int i=0;i<n-1;i++)
        for(int j=0;j<n-1-i;j++)
            if(a[j]>a[j+1]) swap(a[j],a[j+1]);
}
void insertionSort(vector<int>& a){
    for(int i=1;i<(int)a.size();i++){
        int key=a[i], j=i-1;
        while(j>=0 && a[j]>key){ a[j+1]=a[j]; j--; }
        a[j+1]=key;
    }
}
void selectionSort(vector<int>& a){
    for(int i=0;i<(int)a.size();i++){
        int m=i;
        for(int j=i+1;j<(int)a.size();j++) if(a[j]<a[m]) m=j;
        swap(a[i],a[m]);
    }
}
void mergeVec(vector<int>& a,int l,int m,int r){
    vector<int> L(a.begin()+l,a.begin()+m+1), R(a.begin()+m+1,a.begin()+r+1);
    int i=0,j=0,k=l;
    while(i<(int)L.size() && j<(int)R.size()) a[k++]=(L[i]<=R[j]?L[i++]:R[j++]);
    while(i<(int)L.size()) a[k++]=L[i++];
    while(j<(int)R.size()) a[k++]=R[j++];
}
void mergeSort(vector<int>& a,int l,int r){
    if(l>=r) return;
    int m=(l+r)/2;
    mergeSort(a,l,m); mergeSort(a,m+1,r);
    mergeVec(a,l,m,r);
}
int partitionQS(vector<int>& a,int l,int r){
    int p=a[r], i=l;
    for(int j=l;j<r;j++) if(a[j]<=p) swap(a[i++],a[j]);
    swap(a[i],a[r]); return i;
}
void quickSort(vector<int>& a,int l,int r){
    if(l<r){ int pi=partitionQS(a,l,r); quickSort(a,l,pi-1); quickSort(a,pi+1,r); }
}
// Heap sort uses heapify
void heapify(vector<int>& a,int n,int i){
    int largest=i, l=2*i+1, r=2*i+2;
    if(l<n && a[l]>a[largest]) largest=l;
    if(r<n && a[r]>a[largest]) largest=r;
    if(largest!=i){ swap(a[i],a[largest]); heapify(a,n,largest); }
}
void heapSort(vector<int>& a){
    int n=a.size();
    for(int i=n/2-1;i>=0;i--) heapify(a,n,i);
    for(int i=n-1;i>0;i--){ swap(a[0],a[i]); heapify(a,i,0); }
}

/* ================= String Search ================= */
// Brute force
vector<int> bruteForceSearch(const string& t, const string& p){
    vector<int> idx;
    for(int i=0;i+ (int)p.size() <= (int)t.size(); i++){
        int j=0; while(j<(int)p.size() && t[i+j]==p[j]) j++;
        if(j==(int)p.size()) idx.push_back(i);
    }
    return idx;
}
// KMP
vector<int> kmpSearch(const string& t, const string& p){
    int n=t.size(), m=p.size();
    vector<int> lps(m,0), res;
    for(int i=1,len=0;i<m;){
        if(p[i]==p[len]) lps[i++]=++len;
        else if(len) len=lps[len-1]; else lps[i++]=0;
    }
    for(int i=0,j=0;i<n;){
        if(t[i]==p[j]){ i++; j++; }
        if(j==m){ res.push_back(i-j); j=lps[j-1]; }
        else if(i<n && t[i]!=p[j]){ if(j) j=lps[j-1]; else i++; }
    }
    return res;
}
// Rabin-Karp (rolling hash)
vector<int> rabinKarp(const string& t, const string& p){
    const long long B=256, M=1000000007;
    int n=t.size(), m=p.size();
    vector<int> res; if(m>n) return res;
    long long hP=0, hT=0, powB=1;
    for(int i=0;i<m-1;i++) powB=(powB*B)%M;
    for(int i=0;i<m;i++){ hP=(hP*B + p[i])%M; hT=(hT*B + t[i])%M; }
    for(int i=0;i<=n-m;i++){
        if(hP==hT){
            bool match=true; for(int j=0;j<m;j++) if(t[i+j]!=p[j]){match=false;break;}
            if(match) res.push_back(i);
        }
        if(i<n-m){
            hT = ( (hT - t[i]*powB % M + M) % M * B + t[i+m] ) % M;
        }
    }
    return res;
}
// Boyer-Moore (bad character rule)
vector<int> boyerMoore(const string& t, const string& p){
    int n=t.size(), m=p.size();
    vector<int> bad(256,-1), res;
    for(int i=0;i<m;i++) bad[(unsigned char)p[i]]=i;
    int s=0;
    while(s<=n-m){
        int j=m-1;
        while(j>=0 && p[j]==t[s+j]) j--;
        if(j<0){ res.push_back(s); s += (s+m<n)? m - bad[(unsigned char)t[s+m]] : 1; }
        else s += max(1, j - bad[(unsigned char)t[s+j]]);
    }
    return res;
}

/* ================= Graph Algorithms ================= */
// Dijkstra (non-negative)
vector<int> dijkstra(int V, const vector<vector<pair<int,int>>>& adj, int src){
    vector<int> dist(V, INT_MAX);
    dist[src]=0;
    priority_queue<pair<int,int>, vector<pair<int,int>>, greater<>> pq;
    pq.push({0,src});
    while(!pq.empty()){
        auto [d,u]=pq.top(); pq.pop();
        if(d>dist[u]) continue;
        for(auto [v,w]: adj[u]){
            if(dist[v] > dist[u] + w){
                dist[v] = dist[u] + w;
                pq.push({dist[v], v});
            }
        }
    }
    return dist;
}
// Bellman-Ford (handles negative edges, detects negative cycles)
pair<vector<int>, bool> bellmanFord(int V, const vector<tuple<int,int,int>>& edges, int src){
    vector<int> dist(V, INT_MAX); dist[src]=0;
    for(int i=1;i<V;i++){
        bool any=false;
        for(auto [u,v,w]: edges){
            if(dist[u]!=INT_MAX && dist[v] > dist[u] + w){
                dist[v] = dist[u] + w; any=true;
            }
        }
        if(!any) break;
    }
    bool negCycle=false;
    for(auto [u,v,w]: edges){
        if(dist[u]!=INT_MAX && dist[v] > dist[u] + w){ negCycle=true; break; }
    }
    return {dist, negCycle};
}
// Floyd-Warshall (all-pairs shortest paths)
vector<vector<int>> floydWarshall(const vector<vector<int>>& W){
    int n=W.size();
    const int INF=1e9;
    vector<vector<int>> d=W;
    for(int k=0;k<n;k++)
        for(int i=0;i<n;i++)
            for(int j=0;j<n;j++)
                if(d[i][k]<INF && d[k][j]<INF)
                    d[i][j]=min(d[i][j], d[i][k]+d[k][j]);
    return d;
}
// Warshall (transitive closure)
vector<vector<int>> warshallTC(const vector<vector<int>>& G){
    int n=G.size();
    vector<vector<int>> T=G;
    for(int k=0;k<n;k++)
        for(int i=0;i<n;i++)
            for(int j=0;j<n;j++)
                T[i][j] = T[i][j] || (T[i][k] && T[k][j]);
    return T;
}
// Kruskal (MST)
int kruskalMST(int V, vector<tuple<int,int,int>> edges){
    sort(edges.begin(), edges.end(), [](auto &a, auto &b){ return get<2>(a) < get<2>(b); });
    DSU dsu(V);
    int cost=0, cnt=0;
    for(auto [u,v,w]: edges){
        if(dsu.unite(u,v)){ cost+=w; cnt++; if(cnt==V-1) break; }
    }
    return cost;
}
// Prim (MST)
int primMST(int V, const vector<vector<pair<int,int>>>& adj){
    vector<int> key(V, INT_MAX), inMST(V,0);
    key[0]=0;
    priority_queue<pair<int,int>, vector<pair<int,int>>, greater<>> pq;
    pq.push({0,0});
    int cost=0;
    while(!pq.empty()){
        auto [w,u]=pq.top(); pq.pop();
        if(inMST[u]) continue; inMST[u]=1; cost+=w;
        for(auto [v,wt]: adj[u]){
            if(!inMST[v] && wt<key[v]){
                key[v]=wt; pq.push({key[v], v});
            }
        }
    }
    return cost;
}

/* ================= Main: Run demos ================= */
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    // 1) Towers of Hanoi
    vector<string> moves;
    hanoi(3,'A','C','B',moves);
    cout<<"Towers of Hanoi (3 disks):\n";
    for(auto &m:moves) cout<<m<<"\n";
    cout<<"\n";

    // 2) N-Queens
    auto board = solveNQueens(4);
    cout<<"One 4-Queens solution:\n";
    for(auto &row: board) cout<<row<<"\n";
    cout<<"\n";

    // 3) Fenwick Tree
    cout<<"Fenwick Tree demo:\n";
    Fenwick ft(6);
    vector<int> fenArr={0,2,4,5,7,8}; // 1-indexed convenience, ignore fenArr[0]
    for(int i=1;i<=5;i++) ft.add(i, fenArr[i]);
    cout<<"Sum [1..3] = "<<ft.rangeSum(1,3)<<"\n";
    ft.add(3,2); // update index 3 by +2
    cout<<"After update (+2 at 3), Sum [1..3] = "<<ft.rangeSum(1,3)<<"\n\n";

    // 4) Segment Tree
    cout<<"Segment Tree demo:\n";
    vector<int> segArr={2,4,5,7,8,9};
    SegmentTree st(segArr);
    cout<<"Sum [1..4] = "<<st.query(1,0,(int)segArr.size()-1,1,4)<<"\n";
    st.update(1,0,(int)segArr.size()-1,2,10); // set arr[2]=10
    cout<<"After update arr[2]=10, Sum [1..4] = "<<st.query(1,0,(int)segArr.size()-1,1,4)<<"\n\n";

    // 5) Skip List
    cout<<"Skip List demo:\n";
    SkipList sk;
    for(int x: {5,1,9,3,7}) sk.insert(x);
    cout<<"Search 7: "<<(sk.search(7)?"found":"not found")<<"\n";
    cout<<"Search 4: "<<(sk.search(4)?"found":"not found")<<"\n\n";

    // 6) Trie
    cout<<"Trie demo:\n";
    Trie trie;
    for(string s: {"road","roads","route","router","rout"}) trie.insert(s);
    cout<<"Search 'route': "<<(trie.search("route")?"true":"false")<<"\n";
    cout<<"Search 'routa': "<<(trie.search("routa")?"true":"false")<<"\n\n";

    // 7) Sorting suite
    vector<int> base={9,4,6,2,7,3,8,1,5};

    auto A=base; bubbleSort(A); printVec(A,"Bubble: ");
    A=base; insertionSort(A); printVec(A,"Insertion: ");
    A=base; selectionSort(A); printVec(A,"Selection: ");
    A=base; mergeSort(A,0,(int)A.size()-1); printVec(A,"Merge: ");
    A=base; quickSort(A,0,(int)A.size()-1); printVec(A,"Quick: ");
    A=base; heapSort(A); printVec(A,"Heap: ");
    cout<<"\n";

    // 8) String search
    string text="abracadabra abracadabra", pat="abra";
    auto idxBF=bruteForceSearch(text,pat);
    auto idxKMP=kmpSearch(text,pat);
    auto idxRK=rabinKarp(text,pat);
    auto idxBM=boyerMoore(text,pat);
    cout<<"String search indices for '"<<pat<<"' in text:\n";
    cout<<"Brute: "; for(int i:idxBF) cout<<i<<" "; cout<<"\n";
    cout<<"KMP:   "; for(int i:idxKMP) cout<<i<<" "; cout<<"\n";
    cout<<"Rabin: "; for(int i:idxRK) cout<<i<<" "; cout<<"\n";
    cout<<"BM:    "; for(int i:idxBM) cout<<i<<" "; cout<<"\n\n";

    // 9) Graph: Dijkstra, Bellman-Ford
    int V=5;
    vector<vector<pair<int,int>>> adj(V);
    adj[0]={{1,10},{2,3}};
    adj[2]={{1,1},{3,8}};
    adj[1]={{3,2}};
    adj[3]={{4,7}};
    auto distD=dijkstra(V,adj,0);
    cout<<"Dijkstra dist from 0 to 4: "<<(distD[4]==INT_MAX?-1:distD[4])<<"\n";

    vector<tuple<int,int,int>> edges = {
        {0,1,10},{0,2,3},{2,1,1},{1,3,2},{2,3,8},{3,4,7}
    };
    auto [distB,neg] = bellmanFord(V, edges, 0);
    cout<<"Bellman-Ford dist from 0 to 4: "<<(neg?-1:distB[4])<<" (negCycle="<<(neg?"true":"false")<<")\n\n";

    // 10) Floyd-Warshall & Warshall (TC)
    const int INF=1e9;
    vector<vector<int>> W = {
        {0,   3, INF,  7},
        {8,   0,   2, INF},
        {5, INF,   0,   1},
        {2, INF, INF,   0}
    };
    auto APSP = floydWarshall(W);
    cout<<"Floyd-Warshall dist[0][3] = "<<APSP[0][3]<<"\n";
    vector<vector<int>> G = {
        {0,1,0,0},
        {0,0,1,0},
        {0,0,0,1},
        {0,0,0,0}
    };
    auto TC = warshallTC(G);
    cout<<"Warshall TC reachability 0->3: "<<TC[0][3]<<"\n\n";

    // 11) Kruskal & Prim (MST)
    vector<tuple<int,int,int>> E = {
        {0,1,4},{0,2,3},{1,2,1},{1,3,2},{2,3,4},{3,4,2},{4,5,6}
    };
    int mstK = kruskalMST(6, E);
    cout<<"Kruskal MST cost = "<<mstK<<"\n";

    vector<vector<pair<int,int>>> adjM(6);
    for(auto [u,v,w]: E){ adjM[u].push_back({v,w}); adjM[v].push_back({u,w}); }
    int mstP = primMST(6, adjM);
    cout<<"Prim MST cost = "<<mstP<<"\n";

    return 0;
}
